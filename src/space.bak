/***************************************************************************
*                           STAR WARS REALITY 1.0                          *
*--------------------------------------------------------------------------*
* Star Wars Reality Code Additions and changes from the Smaug Code         *
* copyright (c) 1997 by Sean Cooper                                        *
* -------------------------------------------------------------------------*
* Starwars and Starwars Names copyright(c) Lucas Film Ltd.                 *
*--------------------------------------------------------------------------*
* SMAUG 1.0 (C) 1994, 1995, 1996 by Derek Snider                           *
* SMAUG code team: Thoric, Altrag, Blodkai, Narn, Haus,                    *
* Scryn, Rennard, Swordbearer, Gorog, Grishnakh and Tricops                *
* ------------------------------------------------------------------------ *
* Merc 2.1 Diku Mud improvments copyright (C) 1992, 1993 by Michael        *
* Chastain, Michael Quan, and Mitchell Tse.                                *
* Original Diku Mud copyright (C) 1990, 1991 by Sebastian Hammer,          *
* Michael Seifert, Hans Henrik St{rfeldt, Tom Madsen, and Katja Nyboe.     *
* ------------------------------------------------------------------------ *
*		                Space Module    								   *
****************************************************************************/
#include <math.h>
#include <sys/types.h>
#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include "mud.h"

SHIP_DATA * first_ship;
SHIP_DATA * last_ship;

MISSILE_DATA * first_missile;
MISSILE_DATA * last_missile;

SPACE_DATA * first_starsystem;
SPACE_DATA * last_starsystem;

int bus_pos =0;
int bus1_planet =0;
int bus2_planet = 0;
int turbocar_stop =0;
int corus_shuttle =0;

#define MAX_STATION    10
#define MAX_BUS1_STOP 6
#define MAX_BUS2_STOP 5

#define STOP_PLANET     202
#define STOP_SHIPYARD   32015

int     const   station_vnum [MAX_STATION] =
{
    215 , 216 , 217 , 218 , 219 , 220 , 221 ,222 , 223 , 224
};

char *  const   station_name [MAX_STATION] =
{
   "Menari Spaceport" , "Skydome Botanical Gardens" , "Grand Towers" ,
   "Grandis Mon Theater" , "Palace Station" , "Great Galactic Museum" ,
   "College Station" , "Holographic Zoo of Extinct Animals" ,
   "Dometown Station " , "Monument Plaza"
};

int     const   bus1_vnum [MAX_BUS1_STOP] =
{
    67000 , 507, 32297, 21331, 100000, 6200
};

char *  const   bus1_stop [MAX_BUS1_STOP+1] =
{
	"Corellia", "Bus Transfer Pad", "Wayland Cloning Facility", 
	"Kashyyyk", "Tatooine", "Sluis Van",
	"Corellia"  /* last should always be same as first */
};

int     const   bus2_vnum [MAX_BUS2_STOP] =
{
    508, 201 , 51014, 8002, 26500
};

char *  const   bus2_stop [MAX_BUS2_STOP+1] =
{
	"Bus Transfer Pad", "Coruscant", "Hapes", "Rudrig", "Wroona",
	"Bus Transfer Pad"  /* last should always be same as first */
};


char *  const   ship_flags [] =
{
	"canflyindoors", "bayopen", "autopilot", "masked", "mobship","sf5",
	"sf6", "sf7", "sf8", "sf9", "sf10", "sf11", "sf12", "sf13", "sf14",
	"sf15", "sf16", "sf17", "sf18", "sf19", "sf20", "sf21", "sf22", "sf23",
	"sf24","sf25","sf26","sf27", "sf28", "sf29", "sf30", "sf31"
};

char *	const	system_flags	[] =
{
	"Secret","s1","s2","s3","s4","","","","","","",
"","","","","","","","","","","","","","","","","","","","","","s31"
};

/* local routines */
void	fread_ship				args	( ( SHIP_DATA *ship, FILE *fp ) );
bool	load_ship_file			args	( ( char *shipfile ) );
void	write_ship_list			args	( ( void ) );
void	fread_starsystem		args	( ( SPACE_DATA *starsystem, FILE *fp ) );
bool	load_starsystem			args	( ( char *starsystemfile ) );
void	write_starsystem_list	args	( ( void ) );
void	resetship				args	( ( SHIP_DATA *ship ) );
void	landship				args	( ( SHIP_DATA *ship, char *arg ) );
void	launchship				args	( ( SHIP_DATA *ship ) );
bool	land_bus				args	( ( SHIP_DATA *ship, int destination ) );
void	launch_bus				args	( ( SHIP_DATA *ship ) );
void	echo_to_room_dnr		args	( ( int ecolor , ROOM_INDEX_DATA *room ,  char *argument ) );
ch_ret	drive_ship				args	( ( CHAR_DATA *ch, SHIP_DATA *ship, EXIT_DATA  *exit , int fall ) );
bool	autofly					args	( ( SHIP_DATA *ship) );
bool	is_facing				args	( ( SHIP_DATA *ship , SHIP_DATA *target ) );
void	sound_to_ship			args	( ( SHIP_DATA *ship , char *argument ) );
void	undockship				args	( ( SHIP_DATA *ship ) );
char*	get_hyperspeed			args	( ( int hyper ) );
int		get_systemflag			args	( ( char *flag ) );
int		get_shipflag			args	( ( char *flag ) );
int		system_ship_status		args	( ( SHIP_DATA *ship, SPACE_DATA *system) );
bool	system_attack			args	( ( SHIP_DATA *ship, SPACE_DATA *system) );
bool	hyper_allowed_FCZ		args	( ( float x, float y, float z, SHIP_DATA *ship, SPACE_DATA *starsystem) );

/* from act_comm.c */

bool	has_comlink				args	( ( CHAR_DATA *ch ) );

ROOM_INDEX_DATA *generate_exit( ROOM_INDEX_DATA *in_room, EXIT_DATA **pexit );

int get_systemflag( char *flag )
{
    int x;

    for ( x = 0; x < 32; x++ )
      if ( !str_cmp( flag, system_flags[x] ) )
        return x;
    return -1;
}

int get_shipflag( char *flag )
{
    int x;

    for ( x = 0; x < 32; x++ )
      if ( !str_cmp( flag, ship_flags[x] ) )
        return x;
    return -1;
}


void echo_to_room_dnr ( int ecolor , ROOM_INDEX_DATA *room ,  char *argument )
{
    CHAR_DATA *vic;

    if ( room == NULL )
    	return;

    for ( vic = room->first_person; vic; vic = vic->next_in_room )
    {
	set_char_color( ecolor, vic );
	send_to_char( argument, vic );
    }
}

bool land_bus( SHIP_DATA *ship, int destination )
{
    char buf[MAX_STRING_LENGTH];

    if ( !ship_to_room( ship , destination ) )
    {
       return FALSE;
    }
    echo_to_ship( AT_YELLOW , ship , "You feel a slight thud as the ship sets down on the ground.");
    ship->location = destination;
    ship->lastdoc = ship->location;
    ship->shipstate = SHIP_DOCKED;
    if (ship->starsystem)
        ship_from_starsystem( ship, ship->starsystem );
    sprintf( buf, "%s lands on the platform.", ship->name );
    echo_to_room( AT_YELLOW , get_room_index(ship->location) , buf );
    sprintf( buf , "The hatch on %s opens." , ship->name);
    echo_to_room( AT_YELLOW , get_room_index(ship->location) , buf );
    echo_to_room( AT_YELLOW , get_room_index(ship->entrance) , "The hatch opens." );
    ship->hatchopen = TRUE;
    sound_to_room( get_room_index(ship->entrance) , "!!SOUND(door U=http://mercury.spaceports.com/~gavin1/)" );
    sound_to_room( get_room_index(ship->location) , "!!SOUND(door U=http://mercury.spaceports.com/~gavin1/)" );
    return TRUE;
}

void launch_bus( SHIP_DATA *ship )
{
      char buf[MAX_STRING_LENGTH];

      sound_to_room( get_room_index(ship->entrance) , "!!SOUND(door U=http://mercury.spaceports.com/~gavin1/)" );
       sound_to_room( get_room_index(ship->location) , "!!SOUND(door U=http://mercury.spaceports.com/~gavin1/)" );
      sprintf( buf , "The hatch on %s closes and it begins to launch." , ship->name);
      echo_to_room( AT_YELLOW , get_room_index(ship->location) , buf );
      echo_to_room( AT_YELLOW , get_room_index(ship->entrance) , "The hatch slides shut." );
      ship->hatchopen = FALSE;
      extract_ship( ship );
      echo_to_ship( AT_YELLOW , ship , "The ship begins to launch.");
      ship->location = 0;
      ship->shipstate = SHIP_READY;
}

void update_traffic( )
{
    SHIP_DATA *shuttle, *senate;
    SHIP_DATA *turbocar;
    char       buf[MAX_STRING_LENGTH];

    shuttle = ship_from_cockpit( ROOM_CORUSCANT_SHUTTLE );
    senate = ship_from_cockpit( ROOM_SHUTTLE1 );
    if ( senate != NULL && shuttle != NULL )
    {
        switch (corus_shuttle)
        {
             default:
                corus_shuttle++;
                break;

             case 0:
                land_bus( shuttle , STOP_PLANET );
                land_bus( senate , SHUTTLE1_STOP1 );
                corus_shuttle++;
                echo_to_ship( AT_CYAN , shuttle , "Welcome to Menari Spaceport." );
                echo_to_ship( AT_CYAN , senate , SHUTTLE1_STOP1_MSG );
                break;

             case 4:
                launch_bus( shuttle );
                launch_bus( senate );
                corus_shuttle++;
                break;

             case 5:
                land_bus( shuttle , STOP_SHIPYARD );
                land_bus( senate , SHUTTLE1_STOP2 );
                echo_to_ship( AT_CYAN , shuttle , "Welcome to Coruscant Shipyard." );
                echo_to_ship( AT_CYAN , senate , SHUTTLE1_STOP2_MSG );
                corus_shuttle++;
                break;

             case 9:
                launch_bus( shuttle );
                launch_bus( senate );
                corus_shuttle++;
                break;

        }

        if ( corus_shuttle >= 10 )
             corus_shuttle = 0;
    }

    turbocar = ship_from_cockpit( ROOM_CORUSCANT_TURBOCAR );
    if ( turbocar != NULL )
    {
      	sprintf( buf , "The turbocar doors close and it speeds out of the station.");
      	echo_to_room( AT_YELLOW , get_room_index(turbocar->location) , buf );
      	extract_ship( turbocar );
      	turbocar->location = 0;
       	ship_to_room( turbocar , station_vnum[turbocar_stop] );
       	echo_to_ship( AT_YELLOW , turbocar , "The turbocar makes a quick journey to the next station.");
       	turbocar->location = station_vnum[turbocar_stop];
       	turbocar->lastdoc = turbocar->location;
       	turbocar->shipstate = SHIP_DOCKED;
       	if (turbocar->starsystem)
          ship_from_starsystem( turbocar, turbocar->starsystem );
    	sprintf( buf, "A turbocar pulls into the platform and the doors slide open.");
    	echo_to_room( AT_YELLOW , get_room_index(turbocar->location) , buf );
    	sprintf( buf, "Welcome to %s." , station_name[turbocar_stop] );
    	echo_to_ship( AT_CYAN , turbocar , buf );
        turbocar->hatchopen = TRUE;

        turbocar_stop++;
        if ( turbocar_stop >= MAX_STATION )
           turbocar_stop = 0;
    }
}

void update_bus( )
{
	SHIP_DATA *ship;
    SHIP_DATA *ship2;
    SHIP_DATA *bus2;
	SHIP_DATA *bus1;
    int        destination;
    char       buf[MAX_STRING_LENGTH];

    ship = ship_from_cockpit( ROOM_SHUTTLE_BUS );
    ship2 = ship_from_cockpit( ROOM_SHUTTLE_BUS_2 );

    if ( ship == NULL && ship2 == NULL )
    	return;

    switch (bus_pos)
    {
       case 0:
			bus1 = ship_from_hanger( bus1_vnum[bus1_planet] );
			if ( bus1 != NULL && !bus1->starsystem )
            {
               sprintf( buf,  "An electronic voice says, 'Cannot land at %s ... it seems to have
               disappeared.'", bus1_stop[bus1_planet] );
               echo_to_ship( AT_CYAN , ship , buf );
               bus_pos = 5;
            }

            bus2 = ship_from_hanger( bus2_vnum[bus2_planet] );
            if ( bus2 != NULL && !bus2->starsystem )
            {
               sprintf( buf,  "An electronic voice says, 'Cannot land at %s ... it seems to have
               disappeared.'", bus2_stop[bus2_planet] );
               echo_to_ship( AT_CYAN , ship2 , buf );
               bus_pos = 5;
            }

            bus_pos++;
            break;

       case 6:
            launch_bus ( ship );
            launch_bus ( ship2 );
            bus_pos++;
            break;

       case 7:
            echo_to_ship( AT_YELLOW , ship , "The ship lurches slightly as it makes the jump to lightspeed.");
            echo_to_ship( AT_YELLOW , ship2 , "The ship lurches slightly as it makes the jump to lightspeed.");
            bus_pos++;
            break;

       case 9:
            echo_to_ship( AT_YELLOW , ship , "The ship lurches slightly as it comes out of hyperspace..");
            echo_to_ship( AT_YELLOW , ship2 , "The ship lurches slightly as it comes out of hyperspace..");
            bus_pos++;
            break;

       case 1:
            destination = bus1_vnum[bus1_planet];
            if ( !land_bus( ship, destination ) )
            {
               sprintf( buf, "An electronic voice says, 'Oh My, %s seems to have disappeared.'" ,
               bus1_stop[bus1_planet] );
               echo_to_ship( AT_CYAN , ship , buf );
               echo_to_ship( AT_CYAN , ship , "An electronic voice says, 'I do hope it wasn't a superlaser. Landing aborted.'");
            }
            else
            {
               sprintf( buf,  "An electronic voice says, 'Welcome to %s'" , bus1_stop[bus1_planet] );
               echo_to_ship( AT_CYAN , ship , buf);
               echo_to_ship( AT_CYAN , ship , "It continues, 'Please exit through the main ramp. Enjoy your stay.'");
            }
            destination = bus2_vnum[bus2_planet];
            if ( !land_bus( ship2, destination ) )
            {
               sprintf( buf, "An electronic voice says, 'Oh My, %s seems to have disappeared.'" ,
               bus2_stop[bus2_planet] );
               echo_to_ship( AT_CYAN , ship2 , buf );
               echo_to_ship( AT_CYAN , ship2 , "An electronic voice says, 'I do hope it wasn't a superlaser. Landing aborted.'");
            }
            else
            {
               sprintf( buf,  "An electronic voice says, 'Welcome to %s'" , bus2_stop[bus2_planet] );
               echo_to_ship( AT_CYAN , ship2 , buf);
               echo_to_ship( AT_CYAN , ship2 , "It continues, 'Please exit through the main ramp. Enjoy your stay.'");
            }
            bus_pos++;
            break;

       case 5:
            sprintf( buf, "It continues, 'Next stop, %s'" , bus1_stop[bus1_planet+1] );
            echo_to_ship( AT_CYAN , ship , "An electronic voice says, 'Preparing for launch.'");
            echo_to_ship( AT_CYAN , ship , buf);
            sprintf( buf, "It continues, 'Next stop, %s'" , bus2_stop[bus2_planet+1] );
            echo_to_ship( AT_CYAN , ship2 , "An electronic voice says, 'Preparing for launch.'");
            echo_to_ship( AT_CYAN , ship2 , buf);
            bus_pos++;
            break;

       default:
            bus_pos++;
            break;
    }

    if ( bus_pos >= 10 )
    {
       bus_pos = 0;
       bus1_planet++;
       bus2_planet++;
    }

    if ( bus1_planet >= MAX_BUS1_STOP )
       bus1_planet = 0;
    if ( bus2_planet >= MAX_BUS2_STOP )
       bus2_planet = 0;

}

void move_ships( )
{
	SHIP_DATA *ship;
	MISSILE_DATA *missile;
	MISSILE_DATA *m_next;
	SHIP_DATA *target;
	float dx, dy, dz, change;
	char buf[MAX_STRING_LENGTH];
	CHAR_DATA *ch;
	bool ch_found = FALSE;

	for ( missile = first_missile; missile; missile = m_next )
	{
		m_next = missile->next;
		ship = missile->fired_from;
		target = missile->target;

		if ( target->starsystem && target->starsystem == missile->starsystem )
		{
			if ( missile->mx < target->vx )
				missile->mx += UMIN( missile->speed/5 , target->vx - missile->mx );
			else if ( missile->mx > target->vx )
				missile->mx -= UMIN( missile->speed/5 , missile->mx - target->vx );
			if ( missile->my < target->vy )
				missile->my += UMIN( missile->speed/5 , target->vy - missile->my );
			else if ( missile->my > target->vy )
				missile->my -= UMIN( missile->speed/5 , missile->my - target->vy );
			if ( missile->mz < target->vz )
				missile->mz += UMIN( missile->speed/5 , target->vz - missile->mz );
			else if ( missile->mz > target->vz )
				missile->mz -= UMIN( missile->speed/5 , missile->mz - target->vz );

			if ( abs(missile->mx) - abs(target->vx) <= 20 && abs(missile->mx) - abs(target->vx) >= -20
				&& abs(missile->my) - abs(target->vy) <= 20 && abs(missile->my) - abs(target->vy) >= -20
				&& abs(missile->mz) - abs(target->vz) <= 20 && abs(missile->mz) - abs(target->vz) >= -20 )
			{
				if ( target->chaff_released <= 0)
				{
					echo_to_room( AT_YELLOW , get_room_index(ship->gunseat), "Your missile hits its target dead on!" );
					echo_to_cockpit( AT_BLOOD, target, "The ship is hit by a missile.");
                    echo_to_ship( AT_RED , target , "A loud explosion shakes the ship violently!" );
                    sprintf( buf, "You see a small explosion as %s is hit by a missile" , target->name );
                    echo_to_system( AT_ORANGE , target , buf , ship );
					for ( ch = first_char; ch; ch = ch->next )
					{
						if ( !IS_NPC( ch ) && nifty_is_name( missile->fired_by, ch->name ) )
						{
							ch_found = TRUE;
							damage_ship_ch( target , 20+missile->missiletype*missile->missiletype*20 ,
								30+missile->missiletype*missile->missiletype*missile->missiletype*30 , ch );
						}
					}
					if ( !ch_found )
						damage_ship( target , 20+missile->missiletype*missile->missiletype*20 ,
							30+missile->missiletype*missile->missiletype*ship->missiletype*30 );
					extract_missile( missile );
				}
				else
				{
					echo_to_room( AT_YELLOW , get_room_index(ship->gunseat), "Your missile explodes harmlessly in a cloud of chaff!" );
					echo_to_cockpit( AT_YELLOW, target, "A missile explodes in your chaff.");
					extract_missile( missile );
				}
				continue;
			}
			else
			{
				missile->age++;
				if (missile->age >= 50)
				{
					extract_missile( missile );
					continue;
				}
			}
		}
		else
		{
			extract_missile( missile );
			continue;
		}
	}/* End Missile*/
	for ( ship = first_ship; ship; ship = ship->next )
	{
		if ( !ship->starsystem )
			continue;
		if ( ship->currspeed > 0 )
		{
			change = sqrt( ship->hx*ship->hx + ship->hy*ship->hy + ship->hz*ship->hz );
			if (change > 0)
			{
				dx = ship->hx/change;
				dy = ship->hy/change;
				dz = ship->hz/change;
				ship->vx += (dx * ship->currspeed/5);
				ship->vy += (dy * ship->currspeed/5);
				ship->vz += (dz * ship->currspeed/5);
			}
		}

		if ( autofly(ship) )
			continue;

		for ( target = ship->starsystem->first_ship; target; target = target->next_in_starsystem)
		{
			if ( target != ship &&
				abs(ship->vx - target->vx) < 5 &&
				abs(ship->vy - target->vy) < 5 &&
				abs(ship->vz - target->vz) < 5 )
			{
				if ( target->currspeed > 60 || ship->currspeed > 60 )
				{
					/* Forumla Devised by Atvar */
					ship->collision = ((ship->currspeed-60) + (target->currspeed-60));
					ship->collision *= 0.5;
					ship->collision *= ship->hull;
					ship->collision -= (ship->shield+target->shield);
					ship->collision -= target->hull;
					ship->collision = URANGE( 0,ship->collision, 3000);
					target->collision = ((ship->currspeed-60) + (target->currspeed-60));
					target->collision *= 0.5;
					target->collision *= ship->hull;
					target->collision -= (ship->shield+target->shield);
					target->collision -= target->hull;
					target->collision = URANGE( 0,target->collision, 3000);
/*					ship->collision = ( target->hull * abs(target->currspeed - 60) );
					target->collision = ( ship->hull * abs( ship->currspeed - 60) );*/
				}
			}
		}

		if ( ship->starsystem->star1 && strcmp(ship->starsystem->star1,"") &&
			abs(ship->vx - ship->starsystem->s1x) < 50 &&
			abs(ship->vy - ship->starsystem->s1y) < 50 &&
			abs(ship->vz - ship->starsystem->s1z) < 50 )
		{
			echo_to_cockpit( AT_BLOOD, ship, "&G&W[&R^zWARNING&W^x] Temperature Raiseing. Please Back Away");
			continue;
		}

		if ( ship->starsystem->star1 && strcmp(ship->starsystem->star1,"") &&
			abs(ship->vx - ship->starsystem->s1x) < 10 &&
			abs(ship->vy - ship->starsystem->s1y) < 10 &&
			abs(ship->vz - ship->starsystem->s1z) < 10 )
		{
			echo_to_cockpit( AT_BLOOD+AT_BLINK, ship, "You fly directly into the sun.");
			sprintf( buf , "%s flys directly into %s!", ship->name, ship->starsystem->star1);
			echo_to_system( AT_ORANGE , ship , buf , NULL );
			destroy_ship(ship, NULL);
			continue;
		}
		if ( ship->starsystem->star2 && strcmp(ship->starsystem->star2,"") &&
			abs(ship->vx - ship->starsystem->s2x) < 10 &&
			abs(ship->vy - ship->starsystem->s2y) < 10 &&
			abs(ship->vz - ship->starsystem->s2z) < 10 )
		{
			echo_to_cockpit( AT_BLOOD+AT_BLINK, ship, "You fly directly into the sun.");
			sprintf( buf , "%s flys directly into %s!", ship->name, ship->starsystem->star2);
			echo_to_system( AT_ORANGE , ship , buf , NULL );
			destroy_ship(ship , NULL);
			continue;
		}

        if ( ship->currspeed > 0 )
		{
			if ( ship->starsystem->planet1 && strcmp(ship->starsystem->planet1,"") &&
				abs(ship->vx - ship->starsystem->p1x) < 10 &&
				abs(ship->vy - ship->starsystem->p1y) < 10 &&
				abs(ship->vz - ship->starsystem->p1z) < 10 )
			{
				sprintf( buf , "You begin orbitting %s.", ship->starsystem->planet1);
				echo_to_cockpit( AT_YELLOW, ship, buf);
				if ( IS_SET(ship->flags, SHIP_MASKED) )
				{
					sprintf( buf , "%s begins orbiting %s.", ship->name, ship->starsystem->planet1);
					echo_to_system( AT_ORANGE , ship , buf , NULL );
				}
				ship->currspeed = 0;
				continue;
			}
			if ( ship->starsystem->planet2 && strcmp(ship->starsystem->planet2,"") &&
				abs(ship->vx - ship->starsystem->p2x) < 10 &&
				abs(ship->vy - ship->starsystem->p2y) < 10 &&
				abs(ship->vz - ship->starsystem->p2z) < 10 )
			{
				sprintf( buf , "You begin orbitting %s.", ship->starsystem->planet2);
				echo_to_cockpit( AT_YELLOW, ship, buf);
				if ( IS_SET(ship->flags, SHIP_MASKED) )
				{
					sprintf( buf , "%s begins orbiting %s.", ship->name, ship->starsystem->planet2);
					echo_to_system( AT_ORANGE , ship , buf , NULL );
				}
				ship->currspeed = 0;
				continue;
			}
			if ( ship->starsystem->planet3 && strcmp(ship->starsystem->planet3,"") &&
				abs(ship->vx - ship->starsystem->p3x) < 10 &&
				abs(ship->vy - ship->starsystem->p3y) < 10 &&
				abs(ship->vz - ship->starsystem->p3z) < 10 )
			{
				sprintf( buf , "You begin orbitting %s.", ship->starsystem->planet2);
				echo_to_cockpit( AT_YELLOW, ship, buf);
				if ( IS_SET(ship->flags, SHIP_MASKED) )
				{
					sprintf( buf , "%s begins orbiting %s.", ship->name, ship->starsystem->planet2);
					echo_to_system( AT_ORANGE , ship , buf , NULL );
				}
				ship->currspeed = 0;
				continue;
			}
		}
	}

	for ( ship = first_ship; ship; ship = ship->next )
	{
		if (ship->collision)
		{
			echo_to_cockpit( AT_WHITE+AT_BLINK , ship,  "You have collided with another ship!" );
			echo_to_ship( AT_RED , ship , "A loud explosion shakes the ship violently!" );
			damage_ship( ship , ship->collision , ship->collision );
			ship->collision = 0;
		}
	}
}

void recharge_ships( )
{
	SHIP_DATA *ship;
	char buf[MAX_STRING_LENGTH];

	for ( ship = first_ship; ship; ship = ship->next )
	{
		if (ship->statet0 > 0)
		{
			ship->energy -= ship->statet0;
			ship->statet0 = 0;
		}
		if (ship->statet1 > 0)
		{
			ship->energy -= ship->statet1;
			ship->statet1 = 0;
		}
		if (ship->statet2 > 0)
		{
			ship->energy -= ship->statet2;
			ship->statet2 = 0;
		}
		if (ship->statet3 > 0)
		{
			ship->energy -= ship->statet3*ship->ion;
			ship->statet3 = 0;
		}
		if ( IS_SET(ship->flags, SHIP_MASKED) )
		{
			ship->energy /= 4;
		}
		if (ship->missilestate == MISSILE_RELOAD_2)
		{
			ship->missilestate = MISSILE_READY;
			if ( ship->missiles > 0 )
				echo_to_room( AT_YELLOW, get_room_index(ship->gunseat), "Missile launcher reloaded.");
		}
		if (ship->missilestate == MISSILE_RELOAD )
		{
			ship->missilestate = MISSILE_RELOAD_2;
		}
		if (ship->missilestate == MISSILE_FIRED )
			ship->missilestate = MISSILE_RELOAD;
		if ( autofly(ship) )
		{
			if ( ship->starsystem )
			{
				if (ship->target0 && ship->statet0 != LASER_DAMAGED )
				{
					int chance = 50;
					SHIP_DATA * target = ship->target0;
					int shots;
					if ( !IS_SET(target->flags, SHIP_MASKED) )
					{
						for ( shots=0 ; shots <= ship->lasers ; shots++ )
						{
							if (ship->shipstate != SHIP_HYPERSPACE && ship->energy > 25
								&& ship->target0->starsystem == ship->starsystem
								&& abs(target->vx - ship->vx) <= 1000
								&& abs(target->vy - ship->vy) <= 1000
								&& abs(target->vz - ship->vz) <= 1000
								&& ship->statet0 < ship->lasers )
							{
								if ( ship->class > 1 || is_facing ( ship , target ) )
								{
									chance += target->class*25;
									chance -= target->manuever/10;
									chance -= target->currspeed/20;
									chance -= ( abs(target->vx - ship->vx)/70 );
									chance -= ( abs(target->vy - ship->vy)/70 );
									chance -= ( abs(target->vz - ship->vz)/70 );
									chance = URANGE( 10 , chance , 90 );
									if ( number_percent( ) > chance )
									{
										sprintf( buf , "%s fires at you but misses." , ship->name);
										echo_to_cockpit( AT_ORANGE , target , buf );
										sprintf( buf, "Laserfire from %s barely misses %s." , ship->name , target->name );
										echo_to_system( AT_ORANGE , target , buf , NULL );
									}
									else
									{
									sprintf( buf, "Laserfire from %s hits %s." , ship->name, target->name );
									echo_to_system( AT_ORANGE , target , buf , NULL );
									sprintf( buf , "You are hit by lasers from %s!" , ship->name);
									echo_to_cockpit( AT_BLOOD , target , buf );
									echo_to_ship( AT_RED , target , "A small explosion vibrates through the ship." );
									damage_ship( target , 5 , 10 );
									}
									ship->statet0++;
								}
							}
						}
					}
					else
					{
						echo_to_cockpit( AT_RED, ship, "&R[&WShip Weapons&R] &WUnable To Locate Target!" );
					}/* if ( !IS_SET(target->flags, SHIP_MASKED) )*/
				}
			}
		}
	}
}

void update_space( )
{
	SHIP_DATA *ship;
	SHIP_DATA *target;
	char buf[MAX_STRING_LENGTH];
	int too_close, target_too_close;
	int recharge;

#if 0
	PLANET_DATA *planet;
	SPACE_DATA *starsystem;

	for ( starsystem = first_starsystem; starsystem; starsystem = starsystem->next )
	{
		starsystem->controls = 0; /*what git added this!!! ;-) */ /*I did, otherwise too many ships appear - Gavin */
		for ( planet = first_planet; planet; planet = planet->next )
		{
			if ( planet->starsystem && planet->starsystem == starsystem )
				starsystem->controls += planet->controls;
		}
	}
#endif

	for ( ship = first_ship; ship; ship = ship->next )
	{
		if (ship->starsystem)
		{
			if ( ship->energy > 0 && ship->shipstate == SHIP_DISABLED && ship->class != SHIP_PLATFORM )
				ship->energy -= 100;
			else if ( ship->energy > 0 )
				ship->energy += ( 5 + ship->class*5 );
			else
				ship->currspeed = 0;
		}

        if ( ship->chaff_released > 0 )
			ship->chaff_released--;

        if (ship->shipstate == SHIP_HYPERSPACE)
        {
            ship->hyperdistance -= ship->hyperspeed*2;
            if (ship->hyperdistance <= 0)
            {
            	ship_to_starsystem (ship, ship->currjump);
            	if (ship->starsystem == NULL)
            	{
            	    echo_to_cockpit( AT_RED, ship, "Ship lost in Hyperspace. Make new calculations.");
            	}
            	else
            	{
            	    echo_to_room( AT_YELLOW, get_room_index(ship->pilotseat), "Hyperjump complete.");
            	    echo_to_ship( AT_YELLOW, ship, "The ship lurches slightly as it comes out of hyperspace.");
					if ( IS_SET(ship->flags, SHIP_MASKED) )
					{
						sprintf( buf ,"%s enters the starsystem at %.0f %.0f %.0f" , ship->name, ship->vx, ship->vy, ship->vz );
						echo_to_system( AT_YELLOW, ship, buf , NULL );
					}
            	    ship->shipstate = SHIP_READY;
            	    STRFREE( ship->home );
            	    ship->home = STRALLOC( ship->starsystem->name );
            	    if ( str_cmp("Public",ship->owner) )
                        save_ship(ship);
            	}
            }
            else
            {
               sprintf( buf ,"%d" , ship->hyperdistance );
               echo_to_room_dnr( AT_YELLOW , get_room_index(ship->pilotseat), "Remaining jump distance: " );
               echo_to_room( AT_WHITE , get_room_index(ship->pilotseat),  buf );
            }
        }

        /* following was originaly to fix ships that lost their pilot
           in the middle of a manuever and are stuck in a busy state
           but now used for timed manouevers such as turning */

    	if (ship->shipstate == SHIP_BUSY_3)
		{
			echo_to_room( AT_YELLOW, get_room_index(ship->pilotseat), "Manuever complete.");
			ship->shipstate = SHIP_READY;
		}
		if (ship->shipstate == SHIP_BUSY_2)
			ship->shipstate = SHIP_BUSY_3;
		if (ship->shipstate == SHIP_BUSY)
			ship->shipstate = SHIP_BUSY_2;
		if (ship->shipstate == SHIP_LAND_2)
			landship( ship , ship->dest );
		if (ship->shipstate == SHIP_LAND)
			ship->shipstate = SHIP_LAND_2;
        if (ship->shipstate == SHIP_LAUNCH_2)
			launchship( ship );
		if (ship->shipstate == SHIP_LAUNCH)
			ship->shipstate = SHIP_LAUNCH_2;
        if (ship->shipstate == SHIP_SHIP2SHIP_2)
			undockship( ship );

		ship->shield = UMAX( 0 , ship->shield-1-ship->class);

		if (ship->autorecharge && ship->maxshield > ship->shield && ship->energy > 100)
		{
			recharge  = UMIN( ship->maxshield-ship->shield, 10 + ship->class*10 );
			recharge  = UMIN( recharge , ship->energy/2 -100 );
			recharge  = UMAX( 1, recharge );
			ship->shield += recharge;
			ship->energy -= recharge;
		}

		if (ship->shield > 0)
		{
			if (ship->energy < 200)
			{
				ship->shield = 0;
				echo_to_cockpit( AT_RED, ship,"The ships shields fizzle and die.");
				ship->autorecharge = FALSE;
			}
		}
		if ( IS_SET(ship->flags, SHIP_MASKED) )
		{
			if ( ship->energy < 500 )
			{
				REMOVE_BIT( ship->flags, SHIP_MASKED);
				echo_to_cockpit( AT_RED, ship, "&R[&WShip Status&R]&W Masking Field Out Of Energy. Disabling.");
				sprintf( buf, "&R[&WShip Status&R]&W %s suddenly appears on sensors." , ship->name);
				echo_to_system( AT_ORANGE , ship , buf , NULL );
				ship->energy = 250;
			}
		}

        if ( ship->starsystem && ship->currspeed > 0 )
		{
			sprintf( buf, "%d", ship->currspeed );
			echo_to_room_dnr( AT_BLUE , get_room_index(ship->pilotseat),  "Speed: " );
			echo_to_room_dnr( AT_LBLUE , get_room_index(ship->pilotseat),  buf );
			sprintf( buf, "%.0f %.0f %.0f", ship->vx , ship->vy, ship->vz );
			echo_to_room_dnr( AT_BLUE , get_room_index(ship->pilotseat),  "  Coords: " );
			echo_to_room_dnr( AT_LBLUE ,get_room_index(ship->pilotseat), buf );
			sprintf( buf, "[%d|%d|%d]", ship->shield, ship->hull, ship->energy);
			echo_to_room_dnr( AT_BLUE , get_room_index(ship->pilotseat),  "  [S|H|E]: " );
			echo_to_room( AT_LBLUE , get_room_index(ship->pilotseat),  buf );
			if ( ship->pilotseat != ship->coseat )
			{
				sprintf( buf, "%d", ship->currspeed );
				echo_to_room_dnr( AT_BLUE , get_room_index(ship->coseat),  "Speed: " );
				echo_to_room_dnr( AT_LBLUE , get_room_index(ship->coseat),  buf );
				sprintf( buf, "%.0f %.0f %.0f", ship->vx , ship->vy, ship->vz );
				echo_to_room_dnr( AT_BLUE , get_room_index(ship->coseat),  "  Coords: " );
				echo_to_room( AT_LBLUE , get_room_index(ship->coseat),  buf );
			}
		}

		if ( ship->starsystem )
		{
			too_close = ship->currspeed + 50;
			for ( target = ship->starsystem->first_ship; target; target = target->next_in_starsystem)
			{
				target_too_close = too_close+target->currspeed;
				if ( target != ship &&
					abs(ship->vx - target->vx) < target_too_close &&
					abs(ship->vy - target->vy) < target_too_close &&
					abs(ship->vz - target->vz) < target_too_close )
				{
					if (ship->shipstate != SHIP_SHIP2SHIP && ship->shipstate != SHIP_SHIP2SHIP_2)
					{
						sprintf( buf, "Proximity alert: %s  %.0f %.0f %.0f" , target->name, target->vx, target->vy, target->vz);
						echo_to_room( AT_RED , get_room_index(ship->pilotseat),  buf );
					}
				}
			}
			too_close = ship->currspeed + 100;
			if ( ship->starsystem->star1 &&  strcmp(ship->starsystem->star1,"") &&
				abs(ship->vx - ship->starsystem->s1x) < too_close &&
				abs(ship->vy - ship->starsystem->s1y) < too_close &&
				abs(ship->vz - ship->starsystem->s1z) < too_close )
			{
				sprintf( buf, "Proximity alert: %s  %d %d %d", ship->starsystem->star1,
					ship->starsystem->s1x, ship->starsystem->s1y, ship->starsystem->s1z);
				echo_to_room( AT_RED , get_room_index(ship->pilotseat),  buf );
			}
			if ( ship->starsystem->star2 && strcmp(ship->starsystem->star2,"") &&
				abs(ship->vx - ship->starsystem->s2x) < too_close &&
				abs(ship->vy - ship->starsystem->s2y) < too_close &&
				abs(ship->vz - ship->starsystem->s2z) < too_close )
			{
				sprintf( buf, "Proximity alert: %s  %d %d %d", ship->starsystem->star2,
					ship->starsystem->s2x, ship->starsystem->s2y, ship->starsystem->s2z);
				echo_to_room( AT_RED , get_room_index(ship->pilotseat),  buf );
			}
			if ( ship->starsystem->planet1 && strcmp(ship->starsystem->planet1,"") &&
				abs(ship->vx - ship->starsystem->p1x) < too_close &&
				abs(ship->vy - ship->starsystem->p1y) < too_close &&
				abs(ship->vz - ship->starsystem->p1z) < too_close )
			{
				sprintf( buf, "Proximity alert: %s  %d %d %d", ship->starsystem->planet1,
					ship->starsystem->p1x, ship->starsystem->p1y, ship->starsystem->p1z);
				echo_to_room( AT_RED , get_room_index(ship->pilotseat),  buf );
			}
			if ( ship->starsystem->planet2 && strcmp(ship->starsystem->planet2,"") &&
				abs(ship->vx - ship->starsystem->p2x) < too_close &&
				abs(ship->vy - ship->starsystem->p2y) < too_close &&
				abs(ship->vz - ship->starsystem->p2z) < too_close )
			{
				sprintf( buf, "Proximity alert: %s  %d %d %d", ship->starsystem->planet2,
					ship->starsystem->p2x, ship->starsystem->p2y, ship->starsystem->p2z);
				echo_to_room( AT_RED , get_room_index(ship->pilotseat),  buf );
			}
			if ( ship->starsystem->planet3 && strcmp(ship->starsystem->planet3,"") &&
				abs(ship->vx - ship->starsystem->p3x) < too_close &&
				abs(ship->vy - ship->starsystem->p3y) < too_close &&
				abs(ship->vz - ship->starsystem->p3z) < too_close )
			{
				sprintf( buf, "Proximity alert: %s  %d %d %d", ship->starsystem->planet3,
					ship->starsystem->p3x, ship->starsystem->p3y, ship->starsystem->p3z);
				echo_to_room( AT_RED , get_room_index(ship->pilotseat),  buf );
			}
		}
	
		if (ship->target0)
        {
			sprintf( buf, "%s   %.0f %.0f %.0f", ship->target0->name,
				ship->target0->vx , ship->target0->vy, ship->target0->vz );
			echo_to_room_dnr( AT_BLUE , get_room_index(ship->gunseat), "Target: " );
			echo_to_room( AT_LBLUE , get_room_index(ship->gunseat),  buf );
			if ( IS_SET(ship->target0->flags, SHIP_MASKED) )
			{
				ship->target0 = NULL;
				echo_to_cockpit( AT_RED, ship, "&R[&WShip Weapons&R] &WTarget has disappeared from scanners.");
			}
			else if (ship->starsystem != ship->target0->starsystem)
				ship->target0 = NULL;
		}
		
		if (ship->target1)
		{
			sprintf( buf, "%s   %.0f %.0f %.0f", ship->target1->name,
				ship->target1->vx , ship->target1->vy, ship->target1->vz );
			echo_to_room_dnr( AT_BLUE , get_room_index(ship->turret1), "Target: " );
			echo_to_room( AT_LBLUE , get_room_index(ship->turret1),  buf );
			if ( IS_SET(ship->target1->flags, SHIP_MASKED) )
			{
				ship->target1 = NULL;
				echo_to_cockpit( AT_RED, ship, "&R[&WShip Weapons&R] &WTarget has disappeared from scanners.");
			}
			else if (ship->starsystem != ship->target1->starsystem)
				ship->target1 = NULL;
		}
		
		if (ship->target2)
		{
			sprintf( buf, "%s   %.0f %.0f %.0f", ship->target2->name,
				ship->target2->vx , ship->target2->vy, ship->target2->vz );
			echo_to_room_dnr( AT_BLUE , get_room_index(ship->turret2), "Target: " );
			echo_to_room( AT_LBLUE , get_room_index(ship->turret2),  buf );
			if ( IS_SET(ship->target2->flags, SHIP_MASKED) )
			{
				ship->target2 = NULL;
				echo_to_cockpit( AT_RED, ship, "&R[&WShip Weapons&R] &WTarget has disappeared from scanners.");
			}
			else if (ship->starsystem != ship->target2->starsystem)
				ship->target2 = NULL;
		}
		
		if (ship->energy < 100 && ship->starsystem )
			echo_to_cockpit( AT_RED , ship,  "Warning: Ship fuel low." );
		ship->energy = URANGE( 0 , ship->energy, ship->maxenergy );
	}
	
	for ( ship = first_ship; ship; ship = ship->next )
	{
		if (ship->autotrack && ship->target0 && ship->class < 3 )
		{
			target = ship->target0;
			too_close = ship->currspeed + 10;
			target_too_close = too_close+target->currspeed;
			if ( target != ship && ship->shipstate == SHIP_READY &&
				abs(ship->vx - target->vx) < target_too_close &&
				abs(ship->vy - target->vy) < target_too_close &&
				abs(ship->vz - target->vz) < target_too_close )
			{
				ship->hx = 0-(ship->target0->vx - ship->vx);
				ship->hy = 0-(ship->target0->vy - ship->vy);
				ship->hz = 0-(ship->target0->vz - ship->vz);
				ship->energy -= ship->currspeed/10;
				echo_to_room( AT_RED , get_room_index(ship->pilotseat), "Autotrack: Evading to avoid collision!\n\r" );
				if ( ship->class == FIGHTER_SHIP || ( ship->class == MIDSIZE_SHIP && ship->manuever > 50 ) )
					ship->shipstate = SHIP_BUSY_3;
				else if ( ship->class == MIDSIZE_SHIP || ( ship->class == CAPITAL_SHIP && ship->manuever > 50 ) )
					ship->shipstate = SHIP_BUSY_2;
				else
					ship->shipstate = SHIP_BUSY;
			}
			else if  ( !is_facing(ship, ship->target0) )
			{
				ship->hx = ship->target0->vx - ship->vx;
				ship->hy = ship->target0->vy - ship->vy;
				ship->hz = ship->target0->vz - ship->vz;
				ship->energy -= ship->currspeed/10;
				echo_to_room( AT_BLUE , get_room_index(ship->pilotseat), "Autotracking target ... setting new course.\n\r" );
				if ( ship->class == FIGHTER_SHIP || ( ship->class == MIDSIZE_SHIP && ship->manuever > 50 ) )
					ship->shipstate = SHIP_BUSY_3;
				else if ( ship->class == MIDSIZE_SHIP || ( ship->class == CAPITAL_SHIP && ship->manuever > 50 ) )
					ship->shipstate = SHIP_BUSY_2;
				else
					ship->shipstate = SHIP_BUSY;
			}
		}
		
		if ( autofly(ship) )
		{
			if ( ship->starsystem )
			{
				if (ship->target0)
				{
					int chance = 50;
					/* auto assist ships */
					for ( target = ship->starsystem->first_ship; target; target = target->next_in_starsystem)
					{
						if ( autofly(target) )
						{
							if ( !str_cmp ( target->owner , ship->owner ) && target != ship )
							{
								if ( target->target0 == NULL && ship->target0 != target )
								{
									target->target0 = ship->target0;
									sprintf( buf , "&G&W[&R^zBattle Stations!&R^x&W]&R The ship is being targetted by %s!" , target->name);
									echo_to_cockpit( AT_BLOOD , target->target0 , buf );
									break;
								}
							}
						}
					}
					target = ship->target0;
					ship->autotrack = TRUE;
					if( ship->class != SHIP_PLATFORM )
						ship->currspeed = ship->realspeed;
					if ( ship->energy >200  )
						ship->autorecharge=TRUE;
					if (ship->shipstate != SHIP_HYPERSPACE && ship->energy > 25
						&& ship->missilestate == MISSILE_READY && ship->target0->starsystem == ship->starsystem
						&& abs(target->vx - ship->vx) <= 1200
						&& abs(target->vy - ship->vy) <= 1200
						&& abs(target->vz - ship->vz) <= 1200
						&& ship->missiles > 0 )
					{
						if ( ship->class > 1 || is_facing( ship , target ) )
						{
							chance -= target->manuever/5;
							chance -= target->currspeed/20;
							chance += target->class*target->class*25;
							chance -= ( abs(target->vx - ship->vx)/100 );
							chance -= ( abs(target->vy - ship->vy)/100 );
							chance -= ( abs(target->vz - ship->vz)/100 );
							chance += ( 30 );
							chance = URANGE( 10 , chance , 90 );
							
							if ( number_percent( ) > chance )
							{
							}
							else
							{
								new_missile( ship , target , NULL , CONCUSSION_MISSILE );
								ship->missiles-- ;
								sprintf( buf , "Incoming missile from %s." , ship->name);
								echo_to_cockpit( AT_BLOOD , target , buf );
								sprintf( buf, "%s fires a missile towards %s." , ship->name, target->name );
								echo_to_system( AT_ORANGE , target , buf , NULL );
								
								if ( ship->class == CAPITAL_SHIP || ship->class == SHIP_PLATFORM )
									ship->missilestate = MISSILE_RELOAD_2;
								else
									ship->missilestate = MISSILE_FIRED;
							}
						}
					}
					
					if( ship->missilestate ==  MISSILE_DAMAGED )
						ship->missilestate =  MISSILE_READY;
					if( ship->statet0 ==  LASER_DAMAGED )
						ship->statet0 =  LASER_READY;
					if( ship->shipstate ==  SHIP_DISABLED )
						ship->shipstate =  SHIP_READY;
				}/* if (ship->target0)*/
				else
				{
					ship->currspeed = 0;
					
					if ( atoi(ship->filename) < 0  && IS_SET(ship->flags,SHIP_MOB) )
					{
						for ( target = first_ship; target; target = target->next )
						{
							if ( ship->starsystem == target->starsystem && system_attack(target, target->starsystem) == TRUE )
							{
								ship->target0 = target;
								sprintf( buf , "&G&W[&R^zBattle Stations!&R^x&W]&R The ship is being targetted by %s!" ,ship->name);
								echo_to_cockpit( AT_BLOOD , target , buf );
								break;
							}
						}
					}
				}
			}
			else
			{
				if ( number_range(1, 25) == 25 )
				{
					ship_to_starsystem(ship, starsystem_from_name(ship->home) );
					ship->vx = number_range( -5000 , 5000 );
					ship->vy = number_range( -5000 , 5000 );
					ship->vz = number_range( -5000 , 5000 );
					ship->hx = 1;
					ship->hy = 1;
					ship->hz = 1;
				}
			}
		}
		
		if ( ( ship->class == CAPITAL_SHIP || ship->class == SHIP_PLATFORM )
			&& ship->target0 == NULL )
		{
			if( ship->missiles < ship->maxmissiles )
				ship->missiles++;
		}
	}
}

void write_starsystem_list( )
{
    SPACE_DATA *tstarsystem;
    FILE *fpout;
    char filename[256];

    sprintf( filename, "%s%s", SPACE_DIR, SPACE_LIST );
    fpout = fopen( filename, "w" );
    if ( !fpout )
    {
         bug( "FATAL: cannot open starsystem.lst for writing!\n\r", 0 );
         return;
    }
    for ( tstarsystem = first_starsystem; tstarsystem; tstarsystem = tstarsystem->next )
    fprintf( fpout, "%s\n", tstarsystem->filename );
    fprintf( fpout, "$\n" );
    fclose( fpout );
}

/*
 * Get pointer to space structure from starsystem name.
 */
SPACE_DATA *starsystem_from_name( char *name )
{
    SPACE_DATA *starsystem;

    for ( starsystem = first_starsystem; starsystem; starsystem = starsystem->next )
       if ( !str_cmp( name, starsystem->name ) )
         return starsystem;

    for ( starsystem = first_starsystem; starsystem; starsystem = starsystem->next )
       if ( !str_prefix( name, starsystem->name ) )
         return starsystem;

    return NULL;
}

/*
 * Get pointer to space structure from the dock vnun.
 */
SPACE_DATA *starsystem_from_vnum( int vnum )
{
    SPACE_DATA *starsystem;
    SHIP_DATA *ship;

    for ( starsystem = first_starsystem; starsystem; starsystem = starsystem->next )
       if ( vnum == starsystem->doc1a || vnum == starsystem->doc2a    || vnum == starsystem->doc3a ||
            vnum == starsystem->doc1b || vnum == starsystem->doc2b    || vnum == starsystem->doc3b ||
            vnum == starsystem->doc1c || vnum == starsystem->doc2c    || vnum == starsystem->doc3c )
         return starsystem;

    for ( ship = first_ship; ship; ship = ship->next )
       if ( vnum == ship->hanger )
            return ship->starsystem;

    return NULL;
}

/*
 * Save a starsystem's data to its data file
 */
void save_starsystem( SPACE_DATA *starsystem )
{
    FILE *fp;
    char filename[256];
    char buf[MAX_STRING_LENGTH];
    if ( !starsystem )
    {
	bug( "save_starsystem: null starsystem pointer!", 0 );
	return;
    }

    if ( !starsystem->filename || starsystem->filename[0] == '\0' )
    {
	sprintf( buf, "save_starsystem: %s has no filename", starsystem->name );
	bug( buf, 0 );
	return;
    }

    sprintf( filename, "%s%s", SPACE_DIR, starsystem->filename );

    fclose( fpReserve );
    if ( ( fp = fopen( filename, "w" ) ) == NULL )
    {
    	bug( "save_starsystem: fopen", 0 );
    	perror( filename );
    }
    else
    {
	fprintf( fp, "#SPACE\n" );
	if ( starsystem->name )
		fprintf( fp, "Name         %s~\n",	starsystem->name	);
	if ( starsystem->filename )
		fprintf( fp, "Filename     %s~\n",	starsystem->filename	);
	fprintf( fp, "Planet1      %s~\n",	starsystem->planet1	);
	fprintf( fp, "Planet2      %s~\n",	starsystem->planet2	);
	fprintf( fp, "Planet3      %s~\n",	starsystem->planet3	);
	fprintf( fp, "Star1        %s~\n",	starsystem->star1	);
	fprintf( fp, "Star2        %s~\n",	starsystem->star2	);
	fprintf( fp, "Location1a      %s~\n",	starsystem->location1a	);
	fprintf( fp, "Location1b      %s~\n",	starsystem->location1b	);
	fprintf( fp, "Location1c      %s~\n",	starsystem->location1c	);
	fprintf( fp, "Location2a       %s~\n",	starsystem->location2a	);
	fprintf( fp, "Location2b      %s~\n",	starsystem->location2b	);
	fprintf( fp, "Location2c      %s~\n",	starsystem->location2c	);
	fprintf( fp, "Location3a      %s~\n",	starsystem->location3a	);
	fprintf( fp, "Location3b      %s~\n",	starsystem->location3b	);
	fprintf( fp, "Location3c      %s~\n",	starsystem->location3c	);
	fprintf( fp, "Doc1a          %d\n",	starsystem->doc1a	);
	fprintf( fp, "Doc2a          %d\n",      starsystem->doc2a       );
	fprintf( fp, "Doc3a          %d\n",      starsystem->doc3a       );
	fprintf( fp, "Doc1b          %d\n", 	 starsystem->doc1b	);
	fprintf( fp, "Doc2b          %d\n",      starsystem->doc2b       );
	fprintf( fp, "Doc3b          %d\n",      starsystem->doc3b       );
	fprintf( fp, "Doc1c          %d\n",	 starsystem->doc1c	);
	fprintf( fp, "Doc2c          %d\n",      starsystem->doc2c       );
	fprintf( fp, "Doc3c          %d\n",      starsystem->doc3c       );
	fprintf( fp, "P1x          %d\n",       starsystem->p1x         );
	fprintf( fp, "P1y          %d\n",       starsystem->p1y         );
	fprintf( fp, "P1z          %d\n",       starsystem->p1z         );
	fprintf( fp, "P2x          %d\n",       starsystem->p2x         );
	fprintf( fp, "P2y          %d\n",       starsystem->p2y         );
	fprintf( fp, "P2z          %d\n",       starsystem->p2z         );
	fprintf( fp, "P3x          %d\n",       starsystem->p3x         );
	fprintf( fp, "P3y          %d\n",       starsystem->p3y         );
	fprintf( fp, "P3z          %d\n",       starsystem->p3z         );
	fprintf( fp, "S1x          %d\n",       starsystem->s1x         );
	fprintf( fp, "S1y          %d\n",       starsystem->s1y         );
	fprintf( fp, "S1z          %d\n",       starsystem->s1z         );
	fprintf( fp, "S2x          %d\n",       starsystem->s2x         );
	fprintf( fp, "S2y          %d\n",       starsystem->s2y         );
	fprintf( fp, "S2z          %d\n",       starsystem->s2z         );
	fprintf( fp, "Xpos          %d\n",       starsystem->xpos    );
	fprintf( fp, "Ypos          %d\n",       starsystem->ypos    );
	fprintf( fp, "Flags         %d\n",       starsystem->flags    );
	fprintf( fp, "Fcz			%d\n",		 starsystem->fcz		);
	fprintf( fp, "Controls		%d\n",		 starsystem->controls	);
	if ( starsystem->governed_by && starsystem->governed_by->name )
        	fprintf( fp, "GovernedBy   %s~\n",	starsystem->governed_by->name);
	fprintf( fp, "Code		%d\n",		starsystem->code	);
	fprintf( fp, "Alertstatus	%d\n",		starsystem->alertstatus	);
	fprintf( fp, "End\n\n"						);
	fprintf( fp, "#END\n"						);
    }
    fclose( fp );
    fpReserve = fopen( NULL_FILE, "r" );
    return;
}


/*
 * Read in actual starsystem data.
 */

#if defined(KEY)
#undef KEY
#endif

#define KEY( literal, field, value )					\
			if ( !str_cmp( word, literal ) )	\
			{					\
			    field  = value;			\
			    fMatch = TRUE;			\
			    break;				\
			}
void fread_starsystem( SPACE_DATA *starsystem, FILE *fp )
{
    char buf[MAX_STRING_LENGTH];
    char *word;
    bool fMatch;


    for ( ; ; )
    {
	word   = feof( fp ) ? "End" : fread_word( fp );
	fMatch = FALSE;

	switch ( UPPER(word[0]) )
	{
	case '*':
	    fMatch = TRUE;
	    fread_to_eol( fp );
	    break;

	case 'A':
		KEY( "Alertstatus", starsystem->alertstatus,	fread_number( fp ) );
		break;

	case 'C':
		KEY( "Controls", starsystem->controls,			fread_number( fp ) );
		KEY( "Code", starsystem->code,		fread_number ( fp ) );
		break;

    case 'D':
         KEY( "Doc1a",  starsystem->doc1a,          fread_number( fp ) );
         KEY( "Doc2a",  starsystem->doc2a,          fread_number( fp ) );
         KEY( "Doc3a",  starsystem->doc3a,          fread_number( fp ) );
         KEY( "Doc1b",  starsystem->doc1b,          fread_number( fp ) );
         KEY( "Doc2b",  starsystem->doc2b,          fread_number( fp ) );
         KEY( "Doc3b",  starsystem->doc3b,          fread_number( fp ) );
         KEY( "Doc1c",  starsystem->doc1c,          fread_number( fp ) );
         KEY( "Doc2c",  starsystem->doc2c,          fread_number( fp ) );
         KEY( "Doc3c",  starsystem->doc3c,          fread_number( fp ) );
         break;


	case 'E':
	    if ( !str_cmp( word, "End" ) )
	    {
		if (!starsystem->name)
		  starsystem->name				= STRALLOC( "" );
		if (!starsystem->location1a)
		  starsystem->location1a		= STRALLOC( "" );
		if (!starsystem->location2a)
		  starsystem->location2a		= STRALLOC( "" );
		if (!starsystem->location3a)
		  starsystem->location3a		= STRALLOC( "" );
		if (!starsystem->location1b)
		  starsystem->location1b		= STRALLOC( "" );
		if (!starsystem->location2b)
		  starsystem->location2b		= STRALLOC( "" );
		if (!starsystem->location3b)
		  starsystem->location3b		= STRALLOC( "" );
		if (!starsystem->location1c)
		  starsystem->location1c		= STRALLOC( "" );
		if (!starsystem->location2c)
		  starsystem->location2c		= STRALLOC( "" );
		if (!starsystem->location3c)
		  starsystem->location3c		= STRALLOC( "" );
		if (!starsystem->planet1)
		  starsystem->planet1			= STRALLOC( "" );
		if (!starsystem->planet2)
		  starsystem->planet2			= STRALLOC( "" );
		if (!starsystem->planet3)
		  starsystem->planet3			= STRALLOC( "" );
		if (!starsystem->star1)
		  starsystem->star1				= STRALLOC( "" );
		if (!starsystem->star2)
		  starsystem->star2				= STRALLOC( "" );
		if (!starsystem->controls)
			starsystem->controls		= 0;
		if (!starsystem->fcz)
			starsystem->fcz				= 0;

		return;
	    }
	    break;

	case 'F':
	    KEY( "Filename",	starsystem->filename,		fread_string_nohash( fp ) );
		KEY( "Flags",	starsystem->flags,		fread_number( fp )  );
		KEY( "Fcz",		starsystem->fcz,		fread_number( fp )  );
	    break;

        case 'G':
			if ( !str_cmp( word, "GovernedBy" ) )
	    {
	     	starsystem->governed_by = get_clan ( fread_string(fp) );
                fMatch = TRUE;
	    }
            break;

        case 'L':
	    KEY( "Location1a",	starsystem->location1a,	fread_string( fp ) );
	    KEY( "Location2a",	starsystem->location2a,	fread_string( fp ) );
	    KEY( "Location3a",	starsystem->location3a,	fread_string( fp ) );
	    KEY( "Location1b",	starsystem->location1b,	fread_string( fp ) );
	    KEY( "Location2b",	starsystem->location2b,	fread_string( fp ) );
	    KEY( "Location3b",	starsystem->location3b,	fread_string( fp ) );
	    KEY( "Location1c",	starsystem->location1c,	fread_string( fp ) );
	    KEY( "Location2c",	starsystem->location2c,	fread_string( fp ) );
	    KEY( "Location3c",	starsystem->location3c,	fread_string( fp ) );
	    break;

	case 'N':
	    KEY( "Name",	starsystem->name,		fread_string( fp ) );
	    break;

        case 'P':
             KEY( "Planet1",	starsystem->planet1,	fread_string( fp ) );
	     KEY( "Planet2",	starsystem->planet2,	fread_string( fp ) );
	     KEY( "Planet3",	starsystem->planet3,	fread_string( fp ) );
	     KEY( "P1x",  starsystem->p1x,          fread_number( fp ) );
             KEY( "P1y",  starsystem->p1y,          fread_number( fp ) );
             KEY( "P1z",  starsystem->p1z,          fread_number( fp ) );
             KEY( "P2x",  starsystem->p2x,          fread_number( fp ) );
             KEY( "P2y",  starsystem->p2y,          fread_number( fp ) );
             KEY( "P2z",  starsystem->p2z,          fread_number( fp ) );
             KEY( "P3x",  starsystem->p3x,          fread_number( fp ) );
             KEY( "P3y",  starsystem->p3y,          fread_number( fp ) );
             KEY( "P3z",  starsystem->p3z,          fread_number( fp ) );
             break;


       	case 'S':
       	     KEY( "Star1",	starsystem->star1,	fread_string( fp ) );
		     KEY( "Star2",	starsystem->star2,	fread_string( fp ) );
	         KEY( "S1x",  starsystem->s1x,          fread_number( fp ) );
             KEY( "S1y",  starsystem->s1y,          fread_number( fp ) );
             KEY( "S1z",  starsystem->s1z,          fread_number( fp ) );
             KEY( "S2x",  starsystem->s2x,          fread_number( fp ) );
             KEY( "S2y",  starsystem->s2y,          fread_number( fp ) );
             KEY( "S2z",  starsystem->s2z,          fread_number( fp ) );

        case 'X':
            KEY( "Xpos",  starsystem->xpos,     fread_number( fp ) );

        case 'Y':
            KEY( "Ypos",  starsystem->ypos,     fread_number( fp ) );

       	}

	if ( !fMatch )
	{
	    sprintf( buf, "Fread_starsystem: no match: %s", word );
	    bug( buf, 0 );
	}
    }
}

/*
 * Load a starsystem file
 */

bool load_starsystem( char *starsystemfile )
{
    char filename[256];
    SPACE_DATA *starsystem;
    FILE *fp;
    bool found;

    CREATE( starsystem, SPACE_DATA, 1 );

    found = FALSE;
    sprintf( filename, "%s%s", SPACE_DIR, starsystemfile );

    if ( ( fp = fopen( filename, "r" ) ) != NULL )
    {

	found = TRUE;
        LINK( starsystem, first_starsystem, last_starsystem, next, prev );
	for ( ; ; )
	{
	    char letter;
	    char *word;

	    letter = fread_letter( fp );
	    if ( letter == '*' )
	    {
		fread_to_eol( fp );
		continue;
	    }

	    if ( letter != '#' )
	    {
		bug( "Load_starsystem_file: # not found.", 0 );
		break;
	    }

	    word = fread_word( fp );
	    if ( !str_cmp( word, "SPACE"	) )
	    	fread_starsystem( starsystem, fp );
	    else if ( !str_cmp( word, "END"	) )
	        break;
	    else
	    {
		char buf[MAX_STRING_LENGTH];

		sprintf( buf, "Load_starsystem_file: bad section: %s.", word );
		bug( buf, 0 );
		break;
	    }
	}
	fclose( fp );
    }

    if ( !(found) )
      DISPOSE( starsystem );

    return found;
}

/*
 * Load in all the starsystem files.
 */
void load_space( )
{
    FILE *fpList;
    char *filename;
    char starsystemlist[256];
    char buf[MAX_STRING_LENGTH];


    first_starsystem	= NULL;
    last_starsystem	= NULL;

    log_string( "Loading space..." );

    sprintf( starsystemlist, "%s%s", SPACE_DIR, SPACE_LIST );
    fclose( fpReserve );
    if ( ( fpList = fopen( starsystemlist, "r" ) ) == NULL )
    {
	perror( starsystemlist );
	exit( 1 );
    }


   for ( ; ; )
    {
	filename = feof( fpList ) ? "$" : fread_word( fpList );
	if ( filename[0] == '$' )
	  break;


	if ( !load_starsystem( filename ) )
	{
	  sprintf( buf, "Cannot load starsystem file: %s", filename );
	  bug( buf, 0 );
	}
    }
    fclose( fpList );
    log_string(" Done starsystems " );
    fpReserve = fopen( NULL_FILE, "r" );
    return;
}

void do_setstarsystem( CHAR_DATA *ch, char *argument )
{
	char arg1[MAX_INPUT_LENGTH];
	char arg2[MAX_INPUT_LENGTH];
	char arg3[MAX_INPUT_LENGTH];
	SPACE_DATA *starsystem;
	int value;
	
	if ( IS_NPC( ch ) )
	{
		send_to_char( "Huh?\n\r", ch );
		return;
	}
    
	argument = one_argument( argument, arg1 );
	argument = one_argument( argument, arg2 );
    
	if ( arg2[0] == '\0' || arg1[0] == '\0' )
	{
		send_to_char( "Usage: setstarsystem <starsystem> <field> <values>\n\r", ch );
		send_to_char( "\n\rField being one of:\n\r", ch );
		send_to_char( "name filename xpos ypos,\n\r", ch );
		send_to_char( "star1 s1x s1y s1z\n\r", ch );
		send_to_char( "star2 s2x s2y s2z\n\r", ch );
		send_to_char( "planet1 p1x p1y p1z\n\r", ch );
		send_to_char( "planet2 p2x p2y p2z\n\r", ch );
		send_to_char( "planet3 p3x p3y p3z\n\r", ch );
		send_to_char( "location1a location1b location1c doc1a doc1b doc1c\n\r", ch );
		send_to_char( "location2a location2b location2c doc2a doc2b doc2c\n\r", ch );
		send_to_char( "location3a location3b location3c doc3a doc3b doc3c\n\r", ch );
		send_to_char( "flags fcz controls governed_by ship_status alertstatus code", ch );
		return;
	}
    starsystem = starsystem_from_name( arg1 );
	if ( !starsystem )
    {
	send_to_char( "No such starsystem.\n\r", ch );
	return;
    }

	if ( !str_cmp( arg2, "alertstatus" ) )
	{
		if ( atoi(argument) < 0 || atoi(argument) > 2 )
		{
			send_to_char( "Must be 0, 1 or 2 (0 peace, 1 neutral, 2 war).\n\r", ch );
			return;
		}
		starsystem->alertstatus = atoi( argument );
		send_to_char( "Done.\n\r", ch );
		save_starsystem( starsystem );
		return;
	}

	if ( !str_cmp( arg2, "code" ) )
	{
		if ( atoi(argument) < 0 || atoi(argument) > 99999999 )
		{
			send_to_char( "Must be 0-99999999 (0 being safe to all).\n\r", ch );
			return;
		}
		starsystem->code = atoi( argument );
		send_to_char( "Done.\n\r", ch );
		save_starsystem( starsystem );
		return;
	}


    if ( !str_cmp( arg2, "doc1a" ) )
    {
	starsystem->doc1a = atoi( argument );
	send_to_char( "Done.\n\r", ch );
	save_starsystem( starsystem );
	return;
    }

	if ( !strcmp( arg2, "governed_by" ) )
    {
		CLAN_DATA *clan;
        clan = get_clan( argument );
		if ( !strcmp( argument, "none" ) ) {
           starsystem->governed_by = NULL;
		   send_to_char( "Done.\n\r", ch );
       	   save_starsystem( starsystem );
		   return;
		}
        if ( clan )
        {
           starsystem->governed_by = clan;
           send_to_char( "Done.\n\r", ch );
       	   save_starsystem( starsystem );
        }
        else
           send_to_char( "No such clan.\n\r", ch );
	return;
    }


    if ( !str_cmp( arg2, "doc1b" ) )
    {
	starsystem->doc1b = atoi( argument );
	send_to_char( "Done.\n\r", ch );
	save_starsystem( starsystem );
	return;
    }
    if ( !str_cmp( arg2, "doc1c" ) )
    {
	starsystem->doc1c = atoi( argument );
	send_to_char( "Done.\n\r", ch );
	save_starsystem( starsystem );
	return;
    }

    if ( !str_cmp( arg2, "doc2a" ) )
    {
	starsystem->doc2a = atoi( argument );
	send_to_char( "Done.\n\r", ch );
	save_starsystem( starsystem );
	return;
    }
    if ( !str_cmp( arg2, "doc2b" ) )
    {
	starsystem->doc2b = atoi( argument );
	send_to_char( "Done.\n\r", ch );
	save_starsystem( starsystem );
	return;
    }
    if ( !str_cmp( arg2, "doc2c" ) )
    {
	starsystem->doc2c = atoi( argument );
	send_to_char( "Done.\n\r", ch );
	save_starsystem( starsystem );
	return;
    }

    if ( !str_cmp( arg2, "doc3a" ) )
    {
	starsystem->doc3a = atoi( argument );
	send_to_char( "Done.\n\r", ch );
	save_starsystem( starsystem );
	return;
    }
    if ( !str_cmp( arg2, "doc3b" ) )
    {
	starsystem->doc3b = atoi( argument );
	send_to_char( "Done.\n\r", ch );
	save_starsystem( starsystem );
	return;
    }
    if ( !str_cmp( arg2, "doc3c" ) )
    {
	starsystem->doc3c = atoi( argument );
	send_to_char( "Done.\n\r", ch );
	save_starsystem( starsystem );
	return;
    }

    if ( !str_cmp( arg2, "s1x" ) )
    {
	starsystem->s1x = atoi( argument );
	send_to_char( "Done.\n\r", ch );
	save_starsystem( starsystem );
	return;
    }
    if ( !str_cmp( arg2, "s1y" ) )
    {
	starsystem->s1y = atoi( argument );
	send_to_char( "Done.\n\r", ch );
	save_starsystem( starsystem );
	return;
    }
    if ( !str_cmp( arg2, "s1z" ) )
    {
	starsystem->s1z = atoi( argument );
	send_to_char( "Done.\n\r", ch );
	save_starsystem( starsystem );
	return;
    }

    if ( !str_cmp( arg2, "s2x" ) )
    {
	starsystem->s2x = atoi( argument );
	send_to_char( "Done.\n\r", ch );
	save_starsystem( starsystem );
	return;
    }
    if ( !str_cmp( arg2, "s2y" ) )
    {
	starsystem->s2y = atoi( argument );
	send_to_char( "Done.\n\r", ch );
	save_starsystem( starsystem );
	return;
    }
    if ( !str_cmp( arg2, "s2z" ) )
    {
	starsystem->s2z = atoi( argument );
	send_to_char( "Done.\n\r", ch );
	save_starsystem( starsystem );
	return;
    }
    if ( !str_cmp( arg2, "p1x" ) )
    {
	starsystem->p1x = atoi( argument );
	send_to_char( "Done.\n\r", ch );
	save_starsystem( starsystem );
	return;
    }
    if ( !str_cmp( arg2, "p1y" ) )
    {
	starsystem->p1y = atoi( argument );
	send_to_char( "Done.\n\r", ch );
	save_starsystem( starsystem );
	return;
    }
    if ( !str_cmp( arg2, "p1z" ) )
    {
	starsystem->p1z = atoi( argument );
	send_to_char( "Done.\n\r", ch );
	save_starsystem( starsystem );
	return;
    }

    if ( !str_cmp( arg2, "p2x" ) )
    {
	starsystem->p2x = atoi( argument );
	send_to_char( "Done.\n\r", ch );
	save_starsystem( starsystem );
	return;
    }
    if ( !str_cmp( arg2, "p2y" ) )
    {
	starsystem->p2y = atoi( argument );
	send_to_char( "Done.\n\r", ch );
	save_starsystem( starsystem );
	return;
    }
    if ( !str_cmp( arg2, "p2z" ) )
    {
	starsystem->p2z = atoi( argument );
	send_to_char( "Done.\n\r", ch );
	save_starsystem( starsystem );
	return;
    }
    if ( !str_cmp( arg2, "p3x" ) )
    {
	starsystem->p3x = atoi( argument );
	send_to_char( "Done.\n\r", ch );
	save_starsystem( starsystem );
	return;
    }
    if ( !str_cmp( arg2, "p3y" ) )
    {
	starsystem->p3y = atoi( argument );
	send_to_char( "Done.\n\r", ch );
	save_starsystem( starsystem );
	return;
    }
    if ( !str_cmp( arg2, "p3z" ) )
    {
	starsystem->p3z = atoi( argument );
	send_to_char( "Done.\n\r", ch );
	save_starsystem( starsystem );
	return;
    }
    if ( !str_cmp( arg2, "xpos" ) )
    {
	starsystem->xpos = atoi( argument );
	send_to_char( "Done.\n\r", ch );
	save_starsystem( starsystem );
	return;
    }

    if ( !str_cmp( arg2, "ypos" ) )
    {
	starsystem->ypos = atoi( argument );
	send_to_char( "Done.\n\r", ch );
	save_starsystem( starsystem );
	return;
    }

    if ( !str_cmp( arg2, "name" ) )
    {
	STRFREE( starsystem->name );
	starsystem->name = STRALLOC( argument );
	send_to_char( "Done.\n\r", ch );
	save_starsystem( starsystem );
	return;
    }

    if ( !str_cmp( arg2, "star1" ) )
    {
	STRFREE( starsystem->star1 );
	starsystem->star1 = STRALLOC( argument );
	send_to_char( "Done.\n\r", ch );
	save_starsystem( starsystem );
	return;
    }

    if ( !str_cmp( arg2, "star2" ) )
    {
	STRFREE( starsystem->star2 );
	starsystem->star2 = STRALLOC( argument );
	send_to_char( "Done.\n\r", ch );
	save_starsystem( starsystem );
	return;
    }

    if ( !str_cmp( arg2, "planet1" ) )
    {
	STRFREE( starsystem->planet1 );
	starsystem->planet1 = STRALLOC( argument );
	send_to_char( "Done.\n\r", ch );
	save_starsystem( starsystem );
	return;
    }

    if ( !str_cmp( arg2, "planet2" ) )
    {
	STRFREE( starsystem->planet2 );
	starsystem->planet2 = STRALLOC( argument );
	send_to_char( "Done.\n\r", ch );
	save_starsystem( starsystem );
	return;
    }

    if ( !str_cmp( arg2, "planet3" ) )
    {
	STRFREE( starsystem->planet3 );
	starsystem->planet3 = STRALLOC( argument );
	send_to_char( "Done.\n\r", ch );
	save_starsystem( starsystem );
	return;
    }

    if ( !str_cmp( arg2, "location1a" ) )
    {
	STRFREE( starsystem->location1a );
	starsystem->location1a = STRALLOC( argument );
	send_to_char( "Done.\n\r", ch );
	save_starsystem( starsystem );
	return;
    }
    if ( !str_cmp( arg2, "location1b" ) )
    {
	STRFREE( starsystem->location1b );
	starsystem->location1b = STRALLOC( argument );
	send_to_char( "Done.\n\r", ch );
	save_starsystem( starsystem );
	return;
    }
    if ( !str_cmp( arg2, "location1c" ) )
    {
	STRFREE( starsystem->location1c );
	starsystem->location1c = STRALLOC( argument );
	send_to_char( "Done.\n\r", ch );
	save_starsystem( starsystem );
	return;
    }

    if ( !str_cmp( arg2, "location2a" ) )
    {
	STRFREE( starsystem->location2a  );
	starsystem->location2a = STRALLOC( argument );
	send_to_char( "Done.\n\r", ch );
	save_starsystem( starsystem );
	return;
    }
    if ( !str_cmp( arg2, "location2b" ) )
    {
	STRFREE( starsystem->location2a );
	starsystem->location2b = STRALLOC( argument );
	send_to_char( "Done.\n\r", ch );
	save_starsystem( starsystem );
	return;
    }
    if ( !str_cmp( arg2, "location2c" ) )
    {
	STRFREE( starsystem->location2c );
	starsystem->location2c = STRALLOC( argument );
	send_to_char( "Done.\n\r", ch );
	save_starsystem( starsystem );
	return;
    }

    if ( !str_cmp( arg2, "location3a" ) )
    {
	STRFREE( starsystem->location3a );
	starsystem->location3a = STRALLOC( argument );
	send_to_char( "Done.\n\r", ch );
	save_starsystem( starsystem );
	return;
    }
    if ( !str_cmp( arg2, "location3b" ) )
    {
	STRFREE( starsystem->location3b );
	starsystem->location3b = STRALLOC( argument );
	send_to_char( "Done.\n\r", ch );
	save_starsystem( starsystem );
	return;
    }
    if ( !str_cmp( arg2, "location3c" ) )
    {
	STRFREE( starsystem->location3c );
	starsystem->location3c = STRALLOC( argument );
	send_to_char( "Done.\n\r", ch );
	save_starsystem( starsystem );
	return;
    }

	if ( !str_cmp( arg2, "flags" ) )
	{
/*	while ( argument[0] != '\0' )
	{*/
	   argument = one_argument( argument, arg3 );
	   value = get_systemflag( arg3 );

	   if ( value < 0 || value > 31 )
		   ch_printf( ch, "Unknown flag: %s\n\r", arg3 );
	   else
		   TOGGLE_BIT( starsystem->flags, 1 << value );
	/*}*/
	return;
    }

    if ( !str_cmp( arg2, "fcz" ) )
    {
		if ( atoi(argument) < 0 || atoi(argument) > 10000 )
		{
			send_to_char("Must be within range 0-10000\n\r",ch);
			return;
		}
		else
		{
			starsystem->fcz= atoi( argument );
			send_to_char( "Done.\n\r", ch );
			save_starsystem( starsystem );
			return;
		}
    }

	if ( !str_cmp( arg2, "controls" ) )
    {
		if ( atoi(argument) < 0 || atoi(argument) > 1000 )
		{
			send_to_char("Must be within range 0-1000\n\r",ch);
			return;
		}
		else
		{
			starsystem->controls= atoi( argument );
			send_to_char( "Done.\n\r", ch );
			save_starsystem( starsystem );
			return;
		}
    }




    do_setstarsystem( ch, "" );
    return;
}

void showstarsystem( CHAR_DATA *ch , SPACE_DATA *starsystem )
{
    ch_printf( ch, "Starsystem:%s     Filename: %s    Xpos: %d   Ypos: %d\n\r",
    			starsystem->name,
    			starsystem->filename,
    			starsystem->xpos, starsystem->ypos);
    ch_printf( ch, "Star1: %s   Coordinates: %d %d %d\n\r",
    			starsystem->star1, starsystem->s1x , starsystem->s1y, starsystem->s1z);
    ch_printf( ch, "Star2: %s   Coordinates: %d %d %d\n\r",
    			starsystem->star2, starsystem->s2x , starsystem->s2y, starsystem->s2z);
    ch_printf( ch, "Planet1: %s   Coordinates: %d %d %d\n\r",
    			starsystem->planet1, starsystem->p1x , starsystem->p1y, starsystem->p1z);
    ch_printf( ch, "     Doc1a: %5d (%s)\n\r",
    			starsystem->doc1a, starsystem->location1a);
    ch_printf( ch, "     Doc1b: %5d (%s)\n\r",
    			starsystem->doc1b, starsystem->location1b);
    ch_printf( ch, "     Doc1c: %5d (%s)\n\r",
    			starsystem->doc1c, starsystem->location1c);
    ch_printf( ch, "Planet2: %s   Coordinates: %d %d %d\n\r",
    			starsystem->planet2, starsystem->p2x , starsystem->p2y, starsystem->p2z);
    ch_printf( ch, "     Doc2a: %5d (%s)\n\r",
    			starsystem->doc2a, starsystem->location2a);
    ch_printf( ch, "     Doc2b: %5d (%s)\n\r",
    			starsystem->doc2b, starsystem->location2b);
    ch_printf( ch, "     Doc2c: %5d (%s)\n\r",
    			starsystem->doc2c, starsystem->location2c);
    ch_printf( ch, "Planet3: %s   Coordinates: %d %d %d\n\r",
    			starsystem->planet3, starsystem->p3x , starsystem->p3y, starsystem->p3z);
    ch_printf( ch, "     Doc3a: %5d (%s)\n\r",
    			starsystem->doc3a, starsystem->location3a);
    ch_printf( ch, "     Doc3b: %5d (%s)\n\r",
    			starsystem->doc3b, starsystem->location3b);
    ch_printf( ch, "     Doc3c: %5d (%s)\n\r",
    			starsystem->doc3c, starsystem->location3c);
	ch_printf( ch, "     FCZ: %5d	Controls %5d\n\r", starsystem->fcz, starsystem->controls);
	if ( starsystem->governed_by && starsystem->governed_by->name )
		ch_printf( ch, "     Governed by: %5s\n\r", starsystem->governed_by->name);

	ch_printf( ch, "     Alertstatus: %5d    Code: %5d\n\r",starsystem->alertstatus,starsystem->code);


    return;
}

void do_showstarsystem( CHAR_DATA *ch, char *argument )
{
   SPACE_DATA *starsystem;
   starsystem = starsystem_from_name( argument );
   if ( starsystem == NULL )
      send_to_char("&RNo such starsystem.\n\r",ch);
   else
      showstarsystem(ch , starsystem);
}

void do_makestarsystem( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    char filename[256];
    SPACE_DATA *starsystem;

    if ( !argument || argument[0] == '\0' )
    {
	send_to_char( "Usage: makestarsystem <starsystem name>\n\r", ch );
	return;
    }

    CREATE( starsystem, SPACE_DATA, 1 );
    LINK( starsystem, first_starsystem, last_starsystem, next, prev );

    starsystem->name		= STRALLOC( argument );

		  starsystem->location1a            = STRALLOC( "" );
		  starsystem->location2a            = STRALLOC( "" );
		  starsystem->location3a            = STRALLOC( "" );
		  starsystem->location1b            = STRALLOC( "" );
		  starsystem->location2b            = STRALLOC( "" );
		  starsystem->location3b            = STRALLOC( "" );
		  starsystem->location1c            = STRALLOC( "" );
		  starsystem->location2c            = STRALLOC( "" );
		  starsystem->location3c            = STRALLOC( "" );
		  starsystem->planet1            = STRALLOC( "" );
		  starsystem->planet2            = STRALLOC( "" );
		  starsystem->planet3            = STRALLOC( "" );
		  starsystem->star1            = STRALLOC( "" );
		  starsystem->star2            = STRALLOC( "" );
		  starsystem->fcz				= 0;
		  starsystem->controls			= 0;
	    argument = one_argument( argument, arg );
	    sprintf( filename, "%s.system" , strlower(arg) );
	    starsystem->filename = str_dup( filename );
		save_starsystem( starsystem );
	    write_starsystem_list();
}

void do_starsystems( CHAR_DATA *ch, char *argument )
{
    SPACE_DATA *starsystem;
    int count = 0;

    for ( starsystem = first_starsystem; starsystem; starsystem = starsystem->next )
    {
        set_char_color( AT_NOTE, ch );
        ch_printf( ch, "%s\n\r", starsystem->name );
        count++;
    }

    if ( !count )
    {
        send_to_char( "There are no starsystems currently formed.\n\r", ch );
	return;
    }
}

void echo_to_ship( int color , SHIP_DATA *ship , char *argument )
{
     int room;
     for ( room = ship->firstroom ; room <= ship->lastroom ;room++ )
     {
         echo_to_room( color , get_room_index(room) , argument );
     }

}

void sound_to_ship( SHIP_DATA *ship , char *argument )
{
     int roomnum;
     ROOM_INDEX_DATA *room;
     CHAR_DATA *vic;

     for ( roomnum = ship->firstroom ; roomnum <= ship->lastroom ;roomnum++ )
     {
        room = get_room_index( roomnum );
        if ( room == NULL ) continue;

        for ( vic = room->first_person; vic; vic = vic->next_in_room )
        {
	   if ( !IS_NPC(vic) && IS_SET( vic->act, PLR_SOUND ) )
	     send_to_char( argument, vic );
        }
     }

}

void echo_to_cockpit( int color , SHIP_DATA *ship , char *argument )
{
     int room;

     for ( room = ship->firstroom ; room <= ship->lastroom ;room++ )
     {
         if ( room == ship->cockpit || room == ship->navseat
         || room == ship->pilotseat || room == ship->coseat
         || room == ship->gunseat || room == ship->engineroom
         || room == ship->turret1 || room == ship->turret2 )
               echo_to_room( color , get_room_index(room) , argument );
     }

}

void echo_to_system( int color , SHIP_DATA *ship , char *argument , SHIP_DATA *ignore )
{
     SHIP_DATA *target;

     if (!ship->starsystem)
        return;

     for ( target = ship->starsystem->first_ship; target; target = target->next_in_starsystem )
     {
       if (target != ship && target != ignore )
         echo_to_cockpit( color , target , argument );
     }

}

bool is_facing( SHIP_DATA *ship , SHIP_DATA *target )
{
	float dy, dx, dz, hx, hy, hz;
	float cosofa;

	hx = ship->hx;
	hy = ship->hy;
	hz = ship->hz;

	dx = target->vx - ship->vx;
	dy = target->vy - ship->vy;
	dz = target->vz - ship->vz;

	cosofa = ( hx*dx + hy*dy + hz*dz ) / ( sqrt(hx*hx+hy*hy+hz*hz) + sqrt(dx*dx+dy*dy+dz*dz) );

	if ( cosofa > 0.75 )
		return TRUE;


	return FALSE;
}

long int get_ship_value( SHIP_DATA *ship )
{
     long int price;

     if (ship->class == FIGHTER_SHIP)
        price = 5000;
     else if (ship->class == MIDSIZE_SHIP)
     	price = 50000;
     else if (ship->class == CAPITAL_SHIP)
        price = 500000;
     else
        price = 2000;

     if ( ship->class <= CAPITAL_SHIP )
       price += ( ship->manuever*100*(1+ship->class) );

     price += ( ship->tractorbeam * 500 );
     price += ( ship->realspeed * 10 );
     price += ( ship->astro_array *5 );
     price += ( 5 * ship->maxhull );
     price += ( 5 * ship->maxenergy );
     price += ( 500 * ship->maxchaff );
	 price += ( 500 * ship->maxbombs );

     if (ship->maxenergy > 5000 )
          price += ( (ship->maxenergy-5000)*20 ) ;

     if (ship->maxenergy > 10000 )
          price += ( (ship->maxenergy-10000)*50 );

     if (ship->maxhull > 1000)
        price += ( (ship->maxhull-1000)*10 );

     if (ship->maxhull > 10000)
        price += ( (ship->maxhull-10000)*20 );

     if (ship->maxshield > 200)
          price += ( (ship->maxshield-200)*50 );

     if (ship->maxshield > 1000)
          price += ( (ship->maxshield-1000)*100 );

     if (ship->realspeed > 100 )
        price += ( (ship->realspeed-100)*500 ) ;

     if (ship->lasers > 5 )
        price += ( (ship->lasers-5)*500 );

     if (ship->maxshield)
     	price += ( 1000 + 10 * ship->maxshield);

     if (ship->lasers)
     	price += ( 500 + 500 * ship->lasers );
     if (ship->ion)
     	price += ( 5000 + 500 * ship->ion );

     if (ship->maxmissiles)
     	price += ( 1000 + 100 * ship->maxmissiles );

     if (ship->missiles )
     	price += ( 100 * ship->missiles );

     if (ship->turret1)
        price += 5000;

     if (ship->turret2)
        price += 5000;

     if (ship->hyperspeed)
        price += ( 1000 + ship->hyperspeed * 10 );

     if (ship->hanger)
        price += ( ship->class == MIDSIZE_SHIP ? 75000 : 500000 );

	 if (ship->alarm)
		 price += ( ship->alarm * 100 + number_range(1,200) );

     price *= 1.5;

     return price;
}

void write_ship_list( )
{
    SHIP_DATA *tship;
    FILE *fpout;
    char filename[256];

    sprintf( filename, "%s%s", SHIP_DIR, SHIP_LIST );
    fpout = fopen( filename, "w" );
    if ( !fpout )
    {
         bug( "FATAL: cannot open ship.lst for writing!\n\r", 0 );
         return;
    }
    for ( tship = first_ship; tship; tship = tship->next )
    fprintf( fpout, "%s\n", tship->filename );
    fprintf( fpout, "$\n" );
    fclose( fpout );
}

SHIP_DATA * ship_in_room( ROOM_INDEX_DATA *room, char *name )
{
	SHIP_DATA *ship;

	if ( !room )
		return NULL;

	for ( ship = room->first_ship ; ship ; ship = ship->next_in_room )
		if ( !str_cmp( name, ship->name ) )
			return ship;

	for ( ship = room->first_ship ; ship ; ship = ship->next_in_room )
		if ( nifty_is_name_prefix( name, ship->name ) )
			return ship;

	for ( ship = room->first_ship ; ship ; ship = ship->next_in_room )
		if ( !str_prefix( name, ship->name ) )
			return ship;

	for ( ship = room->first_ship ; ship ; ship = ship->next_in_room )
		if ( nifty_is_name_prefix( name, ship->name ) )
			return ship;

	return NULL;
}

/*
 * Get pointer to ship structure from ship name.
 */

SHIP_DATA *get_ship( char *name )
{
    SHIP_DATA *ship;

    for ( ship = first_ship; ship; ship = ship->next )
       if ( !str_cmp( name, ship->name ) )
         return ship;

    for ( ship = first_ship; ship; ship = ship->next )
       if ( nifty_is_name( name, ship->name ) )
         return ship;

    for ( ship = first_ship; ship; ship = ship->next )
       if ( !str_prefix( name, ship->name ) )
         return ship;

    for ( ship = first_ship; ship; ship = ship->next )
       if ( nifty_is_name_prefix( name, ship->name ) )
         return ship;

    return NULL;
}

/*
 * Checks if ships in a starsystem and returns poiner if it is.
 */

SHIP_DATA *get_ship_here( char *name , SPACE_DATA *starsystem)
{
    SHIP_DATA *ship;

    if ( starsystem == NULL )
         return NULL;

    for ( ship = starsystem->first_ship ; ship; ship = ship->next_in_starsystem )
       if ( !str_cmp( name, ship->name ) )
         return ship;

    for ( ship = starsystem->first_ship; ship; ship = ship->next_in_starsystem )
       if ( nifty_is_name( name, ship->name ) )
         return ship;

    for ( ship = starsystem->first_ship ; ship; ship = ship->next_in_starsystem )
       if ( !str_prefix( name, ship->name ) )
         return ship;

    for ( ship = starsystem->first_ship; ship; ship = ship->next_in_starsystem )
       if ( nifty_is_name_prefix( name, ship->name ) )
         return ship;

    return NULL;
}

/*
 * Get pointer to ship structure from cockpit, turret, or entrance ramp vnum.
 */

SHIP_DATA *ship_from_cockpit( int vnum )
{
    SHIP_DATA *ship;

    for ( ship = first_ship; ship; ship = ship->next )
       if ( vnum == ship->cockpit || vnum == ship->turret1 || vnum == ship->turret2
       || vnum == ship->pilotseat || vnum == ship->coseat || vnum == ship->navseat
        || vnum == ship->gunseat  || vnum == ship->engineroom )
         return ship;
    return NULL;
}

SHIP_DATA *ship_from_pilotseat( int vnum )
{
    SHIP_DATA *ship;

    for ( ship = first_ship; ship; ship = ship->next )
       if ( vnum == ship->pilotseat )
         return ship;
    return NULL;
}

SHIP_DATA *ship_from_coseat( int vnum )
{
    SHIP_DATA *ship;

    for ( ship = first_ship; ship; ship = ship->next )
       if ( vnum == ship->coseat )
         return ship;
    return NULL;
}

SHIP_DATA *ship_from_navseat( int vnum )
{
    SHIP_DATA *ship;

    for ( ship = first_ship; ship; ship = ship->next )
       if ( vnum == ship->navseat )
         return ship;
    return NULL;
}

SHIP_DATA *ship_from_gunseat( int vnum )
{
    SHIP_DATA *ship;

    for ( ship = first_ship; ship; ship = ship->next )
       if ( vnum == ship->gunseat )
         return ship;
    return NULL;
}

SHIP_DATA *ship_from_engine( int vnum )
{
    SHIP_DATA *ship;

    for ( ship = first_ship; ship; ship = ship->next )
    {
      if (ship->engineroom)
      {
        if ( vnum == ship->engineroom )
          return ship;
      }
      else
      {
        if ( vnum == ship->cockpit )
          return ship;
      }
    }

    return NULL;
}



SHIP_DATA *ship_from_turret( int vnum )
{
    SHIP_DATA *ship;

    for ( ship = first_ship; ship; ship = ship->next )
       if ( vnum == ship->gunseat || vnum == ship->turret1 || vnum == ship->turret2 )
         return ship;
    return NULL;
}

SHIP_DATA *ship_from_entrance( int vnum )
{
    SHIP_DATA *ship;

    for ( ship = first_ship; ship; ship = ship->next )
       if ( vnum == ship->entrance )
         return ship;
    return NULL;
}

SHIP_DATA *ship_from_hanger( int vnum )
{
    SHIP_DATA *ship;

    for ( ship = first_ship; ship; ship = ship->next )
       if ( vnum == ship->hanger )
         return ship;
    return NULL;
}


void save_ship( SHIP_DATA *ship )
{
    FILE *fp;
    char filename[256];
    char buf[MAX_STRING_LENGTH];

    if ( !ship )
    {
	bug( "save_ship: null ship pointer!", 0 );
	return;
    }

    if ( !ship->filename || ship->filename[0] == '\0' )
	{
		sprintf( buf, "save_ship: %s has no filename", ship->name );
		bug( buf, 0 );
		return;
    }

	if ( IS_SET(ship->flags,SHIP_MOB) && atoi(ship->filename) < 0 )
		return;
		
	sprintf( filename, "%s%s", SHIP_DIR, ship->filename );

	fclose( fpReserve );
	if ( ( fp = fopen( filename, "w" ) ) == NULL )
    {
    	bug( "save_ship: fopen", 0 );
    	perror( filename );
    }
    else
    {
		fprintf( fp, "#SHIP\n" );
		if ( ship->name )
			fprintf( fp, "Name         %s~\n",	ship->name		    );
		if ( ship->origname )
			fprintf( fp, "OrigName     %s~\n",  ship->origname      );
		if ( ship->filename )
			fprintf( fp, "Filename     %s~\n",	ship->filename		);
		if ( ship->description )
			fprintf( fp, "Description  %s~\n",	ship->description	);
		if ( ship->owner )
			fprintf( fp, "Owner        %s~\n",	ship->owner			);
		if ( ship->pilot )
			fprintf( fp, "Pilot        %s~\n",  ship->pilot     );
		if ( ship->copilot )
			fprintf( fp, "Copilot      %s~\n",  ship->copilot   );
		if ( ship->color )
			fprintf( fp, "Color        %s~\n",      ship->color     );
		if (ship->code && ship->code != 0)
			fprintf( fp, "Code        %d\n",	ship->code			);
		fprintf( fp, "Class        %d\n",	ship->class			);
		fprintf( fp, "Shipyard     %d\n",	ship->shipyard		);
		fprintf( fp, "Hanger       %d\n",	ship->hanger    	);
		fprintf( fp, "Turret1      %d\n",	ship->turret1		);
		fprintf( fp, "Turret2      %d\n",	ship->turret2		);
		fprintf( fp, "Statet0      %d\n",	ship->statet0		);
		fprintf( fp, "Statet1      %d\n",	ship->statet1		);
		fprintf( fp, "Statet2      %d\n",	ship->statet2		);
		fprintf( fp, "Lastdoc      %d\n",	ship->lastdoc		);
		fprintf( fp, "Firstroom    %d\n",	ship->firstroom		);
		fprintf( fp, "Lastroom     %d\n",	ship->lastroom		);
		fprintf( fp, "Cockpit      %d\n",	ship->cockpit		);
		fprintf( fp, "Coseat       %d\n",	ship->coseat		);
		fprintf( fp, "Pilotseat    %d\n",	ship->pilotseat		);
		fprintf( fp, "Gunseat      %d\n",	ship->gunseat		);
		fprintf( fp, "Navseat      %d\n",	ship->navseat		);
		fprintf( fp, "Engineroom   %d\n",   ship->engineroom    );
		fprintf( fp, "Entrance     %d\n",   ship->entrance      );

		if ( ship->prototype == NULL )
		{
			fprintf( fp, "Hyperspeed   %d\n", ship->hyperspeed);
			fprintf( fp, "Comm         %d\n", ship->comm );
			fprintf( fp, "Tractorbeam  %d\n", ship->tractorbeam );
			fprintf( fp, "Sensor       %d\n", ship->sensor );
			fprintf( fp, "Astro_array  %d\n", ship->astro_array );
			fprintf( fp, "Realspeed    %d\n", ship->realspeed );
			fprintf( fp, "Maxshield    %d\n", ship->maxshield );
			fprintf( fp, "Maxhull      %d\n", ship->maxhull );
			fprintf( fp, "Maxenergy    %d\n", ship->maxenergy );
			fprintf( fp, "Manuever     %d\n", ship->manuever );
			fprintf( fp, "Maxchaff     %d\n", ship->maxchaff );
			fprintf( fp, "Maxmissiles  %d\n", ship->maxmissiles );
			fprintf( fp, "MaxBombs     %d\n", ship->maxbombs );
			fprintf( fp, "Ion	       %d\n", ship->ion );
			fprintf( fp, "Lasers       %d\n", ship->lasers );
		}
		else
			fprintf( fp, "Prototype    %s~\n",  ship->prototype->name );

		fprintf( fp, "LaserDamage  %d\n",	ship->laserdamage   );
		fprintf( fp, "Shipstate    %d\n",	ship->shipstate		);
		fprintf( fp, "Missilestate %d\n",	ship->missilestate	);
		fprintf( fp, "Home         %s~\n",  ship->home          );
		fprintf( fp, "Flags		   %d\n",	ship->flags    );
		fprintf( fp, "Alarm	       %d\n",	ship->alarm			);
		fprintf( fp, "End\n\n"						);
		fprintf( fp, "#END\n"						);
    }
    fclose( fp );
    fpReserve = fopen( NULL_FILE, "r" );
    return;
}

/*
 * Read in actual ship data.
 */

#if defined(KEY)
#undef KEY
#endif

#define KEY( literal, field, value )					\
			if ( !str_cmp( word, literal ) )	\
			{					\
			    field  = value;			\
			    fMatch = TRUE;			\
			    break;				\
			}
void fread_ship( SHIP_DATA *ship, FILE *fp )
{
    char buf[MAX_STRING_LENGTH];
    char *word;
    bool fMatch;
    int dummy_number = 0;

    for ( ; ; )
    {
	word   = feof( fp ) ? "End" : fread_word( fp );
	fMatch = FALSE;

	switch ( UPPER(word[0]) )
	{
	case '*':

		fMatch = TRUE;
	    fread_to_eol( fp );
	    break;

	case 'A':
		KEY( "Alarm" , ship->alarm, fread_number( fp ) );
		KEY( "Astro_array",      ship->astro_array,       fread_number( fp ) );
		break;
	case 'B':
		KEY( "Bayopen",	ship->bayopen, fread_number(fp) );
		KEY( "Bombs",	ship->bombs, fread_number(fp) );
		break;

	case 'C':
		KEY( "Cockpit",     ship->cockpit,          fread_number( fp ) );
		KEY( "Code",     ship->code,          fread_number( fp ) );
		KEY( "Color",     ship->color,          fread_string( fp ) );
		KEY( "Coseat",     ship->coseat,          fread_number( fp ) );
		KEY( "Class",       ship->class,            fread_number( fp ) );
		KEY( "Copilot",     ship->copilot,          fread_string( fp ) );
		KEY( "Comm",        ship->comm,      fread_number( fp ) );
		KEY( "Chaff",       ship->chaff,      fread_number( fp ) );
		break;

	case 'D':
	    KEY( "Description",	ship->description,	fread_string( fp ) );
	    KEY( "Docked2",	ship->docked2,	fread_number( fp ) );
		break;

	case 'E':
		KEY( "Engineroom",    ship->engineroom,      fread_number( fp ) );
		KEY( "Entrance",	ship->entrance,	        fread_number( fp ) );
		KEY( "Energy",      ship->energy,        fread_number( fp ) );
		if ( !str_cmp( word, "End" ) )
		{
			if (!ship->flags)
				ship->flags = 0;
			if (!ship->home)
				ship->home		= STRALLOC( "" );
			if (!ship->name || strlen(ship->name) <= 3 )
				ship->name		= STRALLOC( ship->filename );
			if (!ship->origname)
				ship->origname	= STRALLOC( ship->name );
			if (!ship->color)
				ship->color		= STRALLOC( "Cyan" );
			if (!ship->owner)
				ship->owner		= STRALLOC( "Unowned" );
			if (!ship->description)
				ship->description 	= STRALLOC( "" );
			if (!ship->copilot)
				ship->copilot 	= STRALLOC( "" );
			if (!ship->pilot)
				ship->pilot   	= STRALLOC( "" );
			if (!ship->code)
				ship->code		= 0;
			if (ship->shipstate != SHIP_DISABLED)
				ship->shipstate = SHIP_DOCKED;
			if (ship->statet0 != LASER_DAMAGED)
				ship->statet0 = LASER_READY;
			if (ship->statet1 != LASER_DAMAGED)
				ship->statet1 = LASER_READY;
			if (ship->statet2 != LASER_DAMAGED)
				ship->statet2 = LASER_READY;
			if (ship->missilestate != MISSILE_DAMAGED)
				ship->missilestate = MISSILE_READY;
			if (ship->shipyard <= 0)
				ship->shipyard = ROOM_LIMBO_SHIPYARD;
			if (ship->lastdoc <= 0)
				ship->lastdoc = ship->shipyard;
			ship->bayopen     = TRUE;
			ship->autopilot   = FALSE;
			ship->hatchopen = FALSE;
			if (ship->navseat <= 0)
				ship->navseat = ship->cockpit;
			if (ship->gunseat <= 0)
				ship->gunseat = ship->cockpit;
			if (ship->coseat <= 0)
				ship->coseat = ship->cockpit;
			if (ship->pilotseat <= 0)
				ship->pilotseat = ship->cockpit;
			if (ship->missiletype == 1)
			{
				ship->missiles = ship->missiles;    /* for back compatability */
				ship->missiles = 0;
			}
			ship->starsystem = NULL;
			ship->energy = ship->maxenergy;
			ship->hull = ship->maxhull;
			ship->in_room=NULL;
			ship->next_in_room=NULL;
			ship->prev_in_room=NULL;
			ship->allowdock = STRALLOC( "" );
			ship->repulsor = 0;
			if (dummy_number == 3)
				SET_BIT(ship->flags,SHIP_MOB);
			return;

		}
		break;

	case 'F':
	    KEY( "Filename",	ship->filename,		fread_string_nohash( fp ) );
        KEY( "Firstroom",   ship->firstroom,        fread_number( fp ) );
		KEY( "Flags",   ship->flags,        fread_number( fp ) );
            break;


	case 'G':
            KEY( "Gunseat",     ship->gunseat,          fread_number( fp ) );
            break;


	case 'H':
            KEY( "Home" , ship->home, fread_string( fp ) );
            KEY( "Hyperspeed",   ship->hyperspeed,      fread_number( fp ) );
            KEY( "Hull",      ship->hull,        fread_number( fp ) );
            KEY( "Hanger",  ship->hanger,      fread_number( fp ) );
            break;

	case 'I':
			KEY( "Ion" , ship->ion, fread_number( fp ) );
			break;
	case 'L':
			KEY( "LaserDamage",   ship->laserdamage,      fread_number( fp ) );
            KEY( "Laserstr",   ship->lasers,   (sh_int)  ( fread_number( fp )/10 ) );
            KEY( "Lasers",   ship->lasers,      fread_number( fp ) );
            KEY( "Lastdoc",    ship->lastdoc,       fread_number( fp ) );
            KEY( "Lastroom",   ship->lastroom,        fread_number( fp ) );
            break;

	case 'M':
            KEY( "Manuever",   ship->manuever,      fread_number( fp ) );
            KEY( "Maxmissiles",   ship->maxmissiles,      fread_number( fp ) );
            KEY( "Missiles",   ship->missiles,      fread_number( fp ) );
            KEY( "Missiletype",   ship->missiletype,      fread_number( fp ) );
            KEY( "Maxshield",      ship->maxshield,        fread_number( fp ) );
            KEY( "Maxenergy",      ship->maxenergy,        fread_number( fp ) );
            KEY( "Missilestate",   ship->missilestate,        fread_number( fp ) );
			KEY( "Maxbombs",		ship->maxbombs,		fread_number(fp) );
            KEY( "Maxhull",      ship->maxhull,        fread_number( fp ) );
            KEY( "Maxchaff",       ship->maxchaff,      fread_number( fp ) );
             break;

	case 'N':
	    KEY( "Name",	ship->name,		fread_string( fp ) );
	    KEY( "Navseat",     ship->navseat,          fread_number( fp ) );
            break;


	case 'O':
			KEY( "OrigName",		 ship->origname,       fread_string( fp ) );
            KEY( "Owner",            ship->owner,            fread_string( fp ) );
            break;


	case 'P':
            KEY( "Pilot",            ship->pilot,            fread_string( fp ) );
            KEY( "Pilotseat",     ship->pilotseat,          fread_number( fp ) );
			if ( !str_cmp( word, "Prototype" ) )
			{
				char * prototype_name;
				prototype_name = fread_string( fp );
				
				if ( prototype_name[0] != '\0' 
					&& ( ship->prototype = get_ship_prototype( prototype_name )) == NULL )
				{
					STRFREE( prototype_name );
				}
				if ( ship->prototype != NULL )
					ship->prototype->count++;

				fMatch = TRUE;
				break;
			}
            break;

    case 'R':
            KEY( "Realspeed",   ship->realspeed,       fread_number( fp ) );
            break;


    case 'S':
            KEY( "Shipyard",    ship->shipyard,      fread_number( fp ) );
            KEY( "Sensor",      ship->sensor,       fread_number( fp ) );
            KEY( "Shield",      ship->shield,        fread_number( fp ) );
            KEY( "Shipstate",   ship->shipstate,        fread_number( fp ) );
            KEY( "Statet0",   ship->statet0,        fread_number( fp ) );
            KEY( "Statet1",   ship->statet1,        fread_number( fp ) );
            KEY( "Statet2",   ship->statet2,        fread_number( fp ) );
            break;

	case 'T':
	    KEY( "Type",	dummy_number,	fread_number( fp ) );
	    KEY( "Tractorbeam", ship->tractorbeam,      fread_number( fp ) );
	    KEY( "Turret1",	ship->turret1,	fread_number( fp ) );
	    KEY( "Turret2",	ship->turret2,	fread_number( fp ) );
	    break;

	}
	if ( !fMatch )
	{
	    sprintf( buf, "Fread_ship: no match: %s", word );
	    bug( buf, 0 );
	}
    }
}

/*
 * Load a ship file
 */

bool load_ship_file( char *shipfile )
{
	char filename[256];
	SHIP_DATA *ship;
	FILE *fp;
    bool found;
    ROOM_INDEX_DATA *pRoomIndex;
    CLAN_DATA *clan;

    CREATE( ship, SHIP_DATA, 1 );

    found = FALSE;
    sprintf( filename, "%s%s", SHIP_DIR, shipfile );

    if ( ( fp = fopen( filename, "r" ) ) != NULL )
	{
	
		found = TRUE;
		for ( ; ; )
		{
			char letter;
			char *word;
			
			letter = fread_letter( fp );
			if ( letter == '*' )
			{
				fread_to_eol( fp );
				continue;
			}

			if ( letter != '#' )
			{
				bug( "Load_ship_file: # not found in %s",filename, 0 );
				break;
			}
			
			word = fread_word( fp );
			if ( !str_cmp( word, "SHIP"	) )
			{
				fread_ship( ship, fp );
			}
			else if ( !str_cmp( word, "END"	) )
				break;
			else
			{
				char buf[MAX_STRING_LENGTH];
				
				sprintf( buf, "Load_ship_file: bad section: %s.", word );
				bug( buf, 0 );
				break;
			}
		}
		
		fclose( fp );
	}
	if ( !(found) )
		DISPOSE( ship );
	else
	{
		LINK( ship, first_ship, last_ship, next, prev );
		if ( ship->prototype )
		{
			ship->class = ship->prototype->class;
			ship->maxenergy = ship->prototype->maxenergy;
			ship->maxshield = ship->prototype->maxshield;
			ship->maxhull = ship->prototype->maxhull;
			ship->comm = ship->prototype->comm;
			ship->sensor = ship->prototype->sensor;
			ship->astro_array = ship->prototype->astro_array;
			ship->hyperspeed = ship->prototype->hyperspeed;
			ship->realspeed = ship->prototype->realspeed;
			ship->maxmissiles = ship->prototype->maxmissiles;
			ship->maxchaff = ship->prototype->maxchaff;
			ship->lasers = ship->prototype->lasers;
			ship->tractorbeam = ship->prototype->tractorbeam;
			ship->manuever = ship->prototype->manuever;
			ship->ion = ship->prototype->ion;
			ship->maxbombs = ship->prototype->maxbombs;
		}

		ship->energy = ship->maxenergy;
		ship->chaff = ship->maxchaff;
		ship->hull = ship->maxhull;
		ship->shield = 0;
		ship->bombs = ship->maxbombs;
		ship->missiles = ship->maxmissiles;

		if ( !str_cmp("Public",ship->owner) || IS_SET(ship->flags,SHIP_MOB) )
		{
			if ( ship->class != SHIP_PLATFORM && 
				!IS_SET(ship->flags,SHIP_MOB) && ship->class != CAPITAL_SHIP )
			{
				extract_ship( ship );
				ship_to_room( ship , ship->shipyard );
				
				ship->location = ship->shipyard;
				ship->lastdoc = ship->shipyard;
				ship->shipstate = SHIP_DOCKED;
			}
			if ( get_room_index( ship->entrance ) == NULL && 
				ship->class < SHIP_PLATFORM && 
				!IS_SET(ship->flags,SHIP_MOB) )
			{
				ship->shipyard = ROOM_LIMBO_SHIPYARD;
				ship->shipstate = SHIP_READY;
				
				extract_ship( ship );
				ship_to_room( ship , ship->shipyard );
				
				ship->location = ship->shipyard;
				ship->lastdoc = ship->shipyard;
				ship->shipstate = SHIP_DOCKED;
			}
			
			ship->currspeed=0;
			ship->energy=ship->maxenergy;
			ship->chaff=ship->maxchaff;
			ship->hull=ship->maxhull;
			ship->shield=0;
			
			ship->bombs=ship->maxbombs;
			
			ship->statet1 = LASER_READY;
			ship->statet2 = LASER_READY;
			ship->statet0 = LASER_READY;
			ship->missilestate = LASER_READY;
			
			ship->currjump=NULL;
			ship->target0=NULL;
			ship->target1=NULL;
			ship->target2=NULL;
			
			ship->hatchopen = FALSE;
			ship->bayopen = TRUE;
			
			ship->missiles = ship->maxmissiles;
			ship->autorecharge = FALSE;
			ship->autotrack = FALSE;
			ship->autospeed = FALSE;
			
		}
		else if ( ship->cockpit == ROOM_SHUTTLE_BUS 
			|| ship->cockpit == ROOM_SHUTTLE_BUS_2 
			|| ship->cockpit == ROOM_SHUTTLE1 
			|| ship->cockpit == ROOM_CORUSCANT_TURBOCAR 
			|| ship->cockpit == ROOM_CORUSCANT_SHUTTLE ) 
		{}
		else if ( ( pRoomIndex = get_room_index( ship->lastdoc ) ) != NULL
			&& ship->class != CAPITAL_SHIP && ship->class != SHIP_PLATFORM )
		{
			if ( get_room_index( ship->entrance ) == NULL && 
				ship->class != CAPITAL_SHIP && 
				ship->class != SHIP_PLATFORM && 
				!IS_SET(ship->flags,SHIP_MOB) )
			{
				ship->shipyard = ROOM_LIMBO_SHIPYARD;
				ship->shipstate = SHIP_READY;
				
				extract_ship( ship );
				ship_to_room( ship , ship->shipyard );
				
				ship->location = ship->shipyard;
				ship->lastdoc = ship->shipyard;
				ship->shipstate = SHIP_DOCKED;
			}
			else
			{
				LINK( ship, pRoomIndex->first_ship, pRoomIndex->last_ship, next_in_room, prev_in_room );
				ship->in_room = pRoomIndex;
				ship->location = ship->lastdoc;
			}
		}
		if ( ship->class == SHIP_PLATFORM || 
			IS_SET(ship->flags,SHIP_MOB) || 
			ship->class == CAPITAL_SHIP )
		{
			ship_to_starsystem(ship, starsystem_from_name(ship->home) );
			ship->vx = number_range( -5000 , 5000 );
			ship->vy = number_range( -5000 , 5000 );
			ship->vz = number_range( -5000 , 5000 );
			ship->hx = 1;
			ship->hy = 1;
			ship->hz = 1;
			ship->shipstate = SHIP_READY;
			ship->autopilot = TRUE;
			ship->autorecharge = TRUE;
			ship->shield = ship->maxshield;
			ship->energy = ship->maxenergy;
		}
		if ( !IS_SET(ship->flags,SHIP_MOB) && (clan = get_clan( ship->owner )) != NULL )
			clan->spacecraft++;
    }

    return found;
}

/*
 * Load in all the ship files.
 */
void load_ships( )
{
    FILE *fpList;
    char *filename;
    char shiplist[256];
    char buf[MAX_STRING_LENGTH];
    first_ship	= NULL;
    last_ship	= NULL;
    first_missile = NULL;
    last_missile = NULL;

    log_string( "Loading ships..." );

    sprintf( shiplist, "%s%s", SHIP_DIR, SHIP_LIST );
    fclose( fpReserve );

    if ( ( fpList = fopen( shiplist, "r" ) ) == NULL )
    {
	perror( shiplist );
	exit( 1 );
    }

    for ( ; ; )
    {

	filename = feof( fpList ) ? "$" : fread_word( fpList );

	if ( filename[0] == '$' )
	  break;

	if ( !load_ship_file( filename ) )
	{
	  sprintf( buf, "Cannot load ship file: %s", filename );
	  bug( buf, 0 );
	}

    }
    fclose( fpList );
    log_string(" Done ships " );
    fpReserve = fopen( NULL_FILE, "r" );
    return;
}

void resetship( SHIP_DATA *ship )
{
     ship->shipstate = SHIP_READY;

     if ( ship->class != SHIP_PLATFORM && 
		 !IS_SET(ship->flags,SHIP_MOB) )
     {
           extract_ship( ship );
           ship_to_room( ship , ship->shipyard );

           ship->location = ship->shipyard;
           ship->lastdoc = ship->shipyard;
           ship->shipstate = SHIP_DOCKED;
     }

     if (ship->starsystem)
        ship_from_starsystem( ship, ship->starsystem );

	if ( ship->prototype )
	{
		ship->class = ship->prototype->class;
		ship->maxenergy = ship->prototype->maxenergy;
		ship->maxshield = ship->prototype->maxshield;
		ship->maxhull = ship->prototype->maxhull;
		ship->comm = ship->prototype->comm;
		ship->sensor = ship->prototype->sensor;
		ship->astro_array = ship->prototype->astro_array;
		ship->hyperspeed = ship->prototype->hyperspeed;
		ship->realspeed = ship->prototype->realspeed;
		ship->maxmissiles = ship->prototype->maxmissiles;
		ship->maxchaff = ship->prototype->maxchaff;
		ship->lasers = ship->prototype->lasers;
		ship->tractorbeam = ship->prototype->tractorbeam;
		ship->manuever = ship->prototype->manuever;
		ship->ion = ship->prototype->ion;
		ship->maxbombs = ship->prototype->maxbombs;
	}

	REMOVE_BIT(ship->flags, SHIP_MASKED);
	ship->currspeed=0;
	ship->energy=ship->maxenergy;
	ship->chaff=ship->maxchaff;
	ship->hull=ship->maxhull;
	ship->shield=0;
	
	ship->bombs=ship->maxbombs;
	
	ship->statet1 = LASER_READY;
	ship->statet2 = LASER_READY;
	ship->statet0 = LASER_READY;
	ship->missilestate = LASER_READY;
	
	ship->currjump=NULL;
	ship->target0=NULL;
	ship->target1=NULL;
	ship->target2=NULL;
	
	ship->hatchopen = FALSE;
	ship->bayopen = TRUE;
	
	ship->missiles = ship->maxmissiles;
	ship->autorecharge = FALSE;
	ship->autotrack = FALSE;
	ship->autospeed = FALSE;

	if ( get_room_index( ship->entrance ) == NULL && 
		ship->class < SHIP_PLATFORM && 
		!IS_SET(ship->flags,SHIP_MOB) )
	{
		ship->shipyard = ROOM_LIMBO_SHIPYARD;
		ship->shipstate = SHIP_READY;
		
		extract_ship( ship );
		ship_to_room( ship , ship->shipyard );
		
		ship->location = ship->shipyard;
		ship->lastdoc = ship->shipyard;
		ship->shipstate = SHIP_DOCKED;
		if (ship->starsystem)	
			ship_from_starsystem( ship, ship->starsystem );
		
		save_ship(ship);
	}
	
	if ( ship->origname && ship->origname[0] != '\0')
		ship->name = ship->origname;
		
	if ( str_cmp("Public",ship->owner) && 
		!IS_SET(ship->flags,SHIP_MOB) )
	{
		CLAN_DATA *clan;
		
		if ( !IS_SET(ship->flags,SHIP_MOB) && (clan = get_clan( ship->owner )) != NULL )
			clan->spacecraft--;
		STRFREE( ship->owner );
		ship->owner = STRALLOC( "Unowned" );
		STRFREE( ship->pilot );
		ship->pilot = STRALLOC( "" );
		STRFREE( ship->copilot );
		ship->copilot = STRALLOC( "" );
	}
	else
	{
		STRFREE( ship->home );
		ship->home = STRALLOC( "coruscant" );
	}
	save_ship(ship);
}

void do_resetship( CHAR_DATA *ch, char *argument )
{
     SHIP_DATA *ship;

     ship = get_ship( argument );
     if (ship == NULL)
     {
        send_to_char("&RNo such ship!",ch);
        return;
     }

     resetship( ship );

     if ( ( ship->class == SHIP_PLATFORM || IS_SET(ship->flags,SHIP_MOB) || 
		 ship->class == CAPITAL_SHIP ) && ship->home )
     {
          ship_to_starsystem(ship, starsystem_from_name(ship->home) );
          ship->vx = number_range( -5000 , 5000 );
          ship->vy = number_range( -5000 , 5000 );
          ship->vz = number_range( -5000 , 5000 );
          ship->shipstate = SHIP_READY;
          ship->autopilot = TRUE;
          ship->autorecharge = TRUE;
          ship->shield = ship->maxshield;
     }

}
void do_setship( CHAR_DATA *ch, char *argument )
{
	char arg1[MAX_INPUT_LENGTH];
	char arg2[MAX_INPUT_LENGTH];
	char arg3[MAX_INPUT_LENGTH];
    SHIP_DATA *ship;
    int  tempnum,value;
    ROOM_INDEX_DATA *roomindex;

	if ( IS_NPC( ch ) )
    {
		send_to_char( "Huh?\n\r", ch );
		return;
    }

    argument = one_argument( argument, arg1 );
    argument = one_argument( argument, arg2 );
	strcpy( arg3, argument );

    value = is_number( arg3 ) ? atoi( arg3 ) : -1;

	if ( atoi(arg3) < -1 && value == -1 )
		value = atoi(arg3);

    if ( arg1[0] == '\0' || arg2[0] == '\0' || arg1[0] == '\0' )
    {
		send_to_char( "Usage: setship <ship> <field> <values>\n\r", ch );
		send_to_char( "\n\rField being one of:\n\r", ch );
		send_to_char( "filename origname\n\r", ch );
		send_to_char( "name description owner pilot copilot class\n\r", ch );
		send_to_char( "home lastdoc shipyard location firstroom lastroom\n\r", ch );
		send_to_char( "cockpit pilotseat coseat gunseat navseat\n\r", ch );
		send_to_char( "entrance engineroom hanger turret1 turret2\n\r", ch );
		send_to_char( "lasers laserdamage missiles chaff bombs tractorbeam\n\r", ch );
		send_to_char( "shield hull energy comm sensor astroarray alarms\n\r", ch );
		send_to_char( "manuever speed hyperspeed prototype\n\r", ch );
		return;
    }

    ship = get_ship( arg1 );
    if ( !ship )
    {
		send_to_char( "No such ship.\n\r", ch );
		return;
    }

    if ( !str_cmp( arg2, "owner" ) )
    {
		CLAN_DATA *clan;
		if ( !IS_SET(ship->flags,SHIP_MOB) && (clan = get_clan( ship->owner )) != NULL )
			clan->spacecraft--;
		STRFREE( ship->owner );
		ship->owner = STRALLOC( argument );
		send_to_char( "Done.\n\r", ch );
		save_ship( ship );
		if ( !IS_SET(ship->flags,SHIP_MOB) && (clan = get_clan( ship->owner )) != NULL )
			clan->spacecraft++;
		return;
	}

    if ( !str_cmp( arg2, "home" ) )
    {
		STRFREE( ship->home );
		ship->home = STRALLOC( argument );
		send_to_char( "Done.\n\r", ch );
		save_ship( ship );
		return;
    }

    if ( !str_cmp( arg2, "pilot" ) )
    {
		STRFREE( ship->pilot );
		ship->pilot = STRALLOC( argument );
		send_to_char( "Done.\n\r", ch );
		save_ship( ship );
		return;
    }

    if ( !str_cmp( arg2, "copilot" ) )
    {
		STRFREE( ship->copilot );
		ship->copilot = STRALLOC( argument );
		send_to_char( "Done.\n\r", ch );
		save_ship( ship );
		return;
    }

	if ( !str_cmp( arg2, "lastdoc" ) )
    {
		tempnum = atoi(argument);
		roomindex = get_room_index(tempnum);
		if (roomindex == NULL)
		{
			send_to_char("That room doesn't exist.\n\r",ch);
			return;
		}
		ship->lastdoc = tempnum;
		send_to_char( "Done.\n\r", ch );
		save_ship( ship );
		return;
    }

	if ( !str_cmp( arg2, "location" ) )
    {
		tempnum = atoi(argument);
    	roomindex = get_room_index(tempnum);
    	if (roomindex == NULL)
    	{
			send_to_char("That room doesn't exist.\n\r",ch);
			return;
		}
		ship->location = tempnum;
		send_to_char( "Done.\n\r", ch );
		save_ship( ship );
		return;
    }

    if ( !str_cmp( arg2, "firstroom" ) )
    {
		tempnum = atoi(argument);
		roomindex = get_room_index(tempnum);
    	if (roomindex == NULL)
    	{
			send_to_char("That room doesn't exist.\n\r",ch);
			return;
    	}
		ship->firstroom = tempnum;
        ship->lastroom = tempnum;
        ship->cockpit = tempnum;
        ship->coseat = tempnum;
        ship->pilotseat = tempnum;
        ship->gunseat = tempnum;
        ship->navseat = tempnum;
        ship->entrance = tempnum;
        ship->turret1 = 0;
        ship->turret2 = 0;
        ship->hanger = 0;
		send_to_char( "You will now need to set the other rooms in the ship.\n\r", ch );
		save_ship( ship );
		return;
    }

    if ( !str_cmp( arg2, "lastroom" ) )
    {
		tempnum = atoi(argument);
		roomindex = get_room_index(tempnum);
		if (roomindex == NULL)
    	{
			send_to_char("That room doesn't exist.\n\r",ch);
			return;
    	}
    	if ( tempnum < ship->firstroom )
    	{
			send_to_char("The last room on a ship must be greater than or equal to the first room.\n\r",ch);
			return;
    	}
    	if ( ship->class == FIGHTER_SHIP && (tempnum - ship->firstroom) > 5 )
    	{
			send_to_char("Starfighters may have up to 5 rooms only.\n\r",ch);
			return;
    	}
		if ( ship->class == MIDSIZE_SHIP && (tempnum - ship->firstroom) > 25 )
    	{
			send_to_char("Midships may have up to 25 rooms only.\n\r",ch);
			return;
    	}
		if ( ship->class == CAPITAL_SHIP && (tempnum - ship->firstroom) > 100 )
    	{
			send_to_char("Capital Ships may have up to 100 rooms only.\n\r",ch);
			return;
    	}
		ship->lastroom = tempnum;
		send_to_char( "Done.\n\r", ch );
		save_ship( ship );
		return;
	}

    if ( !str_cmp( arg2, "cockpit" ) )
    {
        tempnum = atoi(argument);
    	roomindex = get_room_index(tempnum);
    	if (roomindex == NULL)
    	{
			send_to_char("That room doesn't exist.\n\r",ch);
			return;
    	}
	   	if ( tempnum < ship->firstroom || tempnum > ship->lastroom )
    	{
			send_to_char("That room number is not in that ship .. \n\rIt must be between Firstroom and Lastroom.\n\r",ch);
			return;
    	}
		if ( tempnum == ship->turret1 || tempnum == ship->turret2 || tempnum == ship->hanger )
    	{
			send_to_char("That room is already being used by another part of the ship\n\r",ch);
			return;
    	}
		ship->cockpit = tempnum;
		send_to_char( "Done.\n\r", ch );
		save_ship( ship );
		return;
    }

    if ( !str_cmp( arg2, "pilotseat" ) )
    {
        tempnum = atoi(argument);
    	roomindex = get_room_index(tempnum);
    	if (roomindex == NULL)
    	{
			send_to_char("That room doesn't exist.\n\r",ch);
			return;
    	}
    	if ( tempnum < ship->firstroom || tempnum > ship->lastroom )
    	{
			send_to_char("That room number is not in that ship .. \n\rIt must be between Firstroom and Lastroom.\n\r",ch);
			return;
    	}
		if ( tempnum == ship->turret1 || tempnum == ship->turret2 || tempnum == ship->hanger )
    	{
			send_to_char("That room is already being used by another part of the ship\n\r",ch);
			return;
    	}
		ship->pilotseat = tempnum;
		send_to_char( "Done.\n\r", ch );
		save_ship( ship );
		return;
    }
    if ( !str_cmp( arg2, "coseat" ) )
    {
        tempnum = atoi(argument);
    	roomindex = get_room_index(tempnum);
    	if (roomindex == NULL)
    	{
			send_to_char("That room doesn't exist.\n\r",ch);
			return;
    	}
    	if ( tempnum < ship->firstroom || tempnum > ship->lastroom )
    	{
			send_to_char("That room number is not in that ship .. \n\rIt must be between Firstroom and Lastroom.\n\r",ch);
			return;
    	}
		if ( tempnum == ship->turret1 || tempnum == ship->turret2 || tempnum == ship->hanger )
    	{
			send_to_char("That room is already being used by another part of the ship\n\r",ch);
			return;
    	}
		ship->coseat = tempnum;
		send_to_char( "Done.\n\r", ch );
		save_ship( ship );
		return;
    }
    if ( !str_cmp( arg2, "navseat" ) )
    {
        tempnum = atoi(argument);
    	roomindex = get_room_index(tempnum);
    	if (roomindex == NULL)
    	{
			send_to_char("That room doesn't exist.\n\r",ch);
			return;
    	}
    	if ( tempnum < ship->firstroom || tempnum > ship->lastroom )
    	{
			send_to_char("That room number is not in that ship .. \n\rIt must be between Firstroom and Lastroom.\n\r",ch);
			return;
    	}
		if ( tempnum == ship->turret1 || tempnum == ship->turret2 || tempnum == ship->hanger )
    	{
			send_to_char("That room is already being used by another part of the ship\n\r",ch);
			return;
    	}
		ship->navseat = tempnum;
		send_to_char( "Done.\n\r", ch );
		save_ship( ship );
		return;
    }
    if ( !str_cmp( arg2, "gunseat" ) )
    {
        tempnum = atoi(argument);
		roomindex = get_room_index(tempnum);
		if (roomindex == NULL)
		{
			send_to_char("That room doesn't exist.\n\r",ch);
			return;
		}
    	if ( tempnum < ship->firstroom || tempnum > ship->lastroom )
		{
			send_to_char("That room number is not in that ship .. \n\rIt must be between Firstroom and Lastroom.\n\r",ch);
			return;
    	}
		if ( tempnum == ship->turret1 || tempnum == ship->turret2 || tempnum == ship->hanger )
    	{
			send_to_char("That room is already being used by another part of the ship\n\r",ch);
			return;
    	}
		ship->gunseat = tempnum;
		send_to_char( "Done.\n\r", ch );
		save_ship( ship );
		return;
    }

    if ( !str_cmp( arg2, "entrance" ) )
    {
        tempnum = atoi(argument);
    	roomindex = get_room_index(tempnum);
    	if (roomindex == NULL)
    	{
			send_to_char("That room doesn't exist.\n\r",ch);
			return;
    	}
    	if ( tempnum < ship->firstroom || tempnum > ship->lastroom )
    	{
			send_to_char("That room number is not in that ship .. \n\rIt must be between Firstroom and Lastroom.\n\r",ch);
			return;
    	}
		ship->entrance = tempnum;
		send_to_char( "Done.\n\r", ch );
		save_ship( ship );
		return;
    }

    if ( !str_cmp( arg2, "turret1" ) )
    {
        tempnum = atoi(argument);
    	roomindex = get_room_index(tempnum);
    	if (roomindex == NULL)
    	{
			send_to_char("That room doesn't exist.\n\r",ch);
			return;
    	}
		if ( tempnum < ship->firstroom || tempnum > ship->lastroom )
    	{
			send_to_char("That room number is not in that ship .. \n\rIt must be between Firstroom and Lastroom.\n\r",ch);
			return;
    	}
    	if ( ship->class == FIGHTER_SHIP )
    	{
			send_to_char("Starfighters can't have extra laser turrets.\n\r",ch);
			return;
    	}
		if ( tempnum == ship->cockpit || tempnum == ship->entrance ||
			tempnum == ship->turret2 || tempnum == ship->hanger || tempnum == ship->engineroom )
    	{
			send_to_char("That room is already being used by another part of the ship\n\r",ch);
			return;
    	}
		ship->turret1 = tempnum;
		send_to_char( "Done.\n\r", ch );
		save_ship( ship );
		return;
	}

    if ( !str_cmp( arg2, "turret2" ) )
    {
        tempnum = atoi(argument);
    	roomindex = get_room_index(tempnum);
    	if (roomindex == NULL)
    	{
			send_to_char("That room doesn't exist.\n\r",ch);
			return;
    	}
		if ( tempnum < ship->firstroom || tempnum > ship->lastroom )
    	{
			send_to_char("That room number is not in that ship .. \n\rIt must be between Firstroom and Lastroom.\n\r",ch);
			return;
    	}
		if ( ship->class == FIGHTER_SHIP )
    	{
			send_to_char("Starfighters can't have extra laser turrets.\n\r",ch);
			return;
    	}
		if ( tempnum == ship->cockpit || tempnum == ship->entrance ||
			tempnum == ship->turret1 || tempnum == ship->hanger || tempnum == ship->engineroom )
    	{
			send_to_char("That room is already being used by another part of the ship\n\r",ch);
			return;
    	}
		ship->turret2 = tempnum;
		send_to_char( "Done.\n\r", ch );
		save_ship( ship );
		return;
    }

    if ( !str_cmp( arg2, "hanger" ) )
    {
        tempnum = atoi(argument);
    	roomindex = get_room_index(tempnum);
    	if (roomindex == NULL)
    	{
			send_to_char("That room doesn't exist.\n\r",ch);
			return;
    	}
		if ( tempnum < ship->firstroom || tempnum > ship->lastroom )
    	{
			send_to_char("That room number is not in that ship .. \n\rIt must be between Firstroom and Lastroom.\n\r",ch);
			return;
    	}
    	if ( tempnum == ship->cockpit || tempnum == ship->entrance ||
			tempnum == ship->turret1 || tempnum == ship->turret2 || tempnum == ship->engineroom )
    	{
			send_to_char("That room is already being used by another part of the ship\n\r",ch);
			return;
    	}
		if ( ship->class == FIGHTER_SHIP )
		{
			send_to_char("Starfighters are to small to have hangers for other ships!\n\r",ch);
			return;
		}
		ship->hanger = tempnum;
		send_to_char( "Done.\n\r", ch );
		save_ship( ship );
		return;
    }

	if ( !str_cmp( arg2, "engineroom" ) )
    {
		tempnum = atoi(argument);
    	roomindex = get_room_index(tempnum);
    	if (roomindex == NULL)
    	{
			send_to_char("That room doesn't exist.\n\r",ch);
			return;
    	}
		if ( tempnum < ship->firstroom || tempnum > ship->lastroom )
    	{
			send_to_char("That room number is not in that ship .. \n\rIt must be between Firstroom and Lastroom.\n\r",ch);
			return;
		}
    	if ( tempnum == ship->cockpit || tempnum == ship->entrance ||
			tempnum == ship->turret1 || tempnum == ship->turret2 || tempnum == ship->hanger )
    	{
			send_to_char("That room is already being used by another part of the ship\n\r",ch);
			return;
    	}
		ship->engineroom = tempnum;
		send_to_char( "Done.\n\r", ch );
		save_ship( ship );
		return;
    }

    if ( !str_cmp( arg2, "shipyard" ) )
    {
        tempnum = atoi(argument);
    	roomindex = get_room_index(tempnum);
    	if (roomindex == NULL)
    	{
			send_to_char("That room doesn't exist.",ch);
			return;
    	}
		ship->shipyard = tempnum;
		send_to_char( "Done.\n\r", ch );
		save_ship( ship );
		return;
    }

    if ( !str_cmp( arg2, "type" ) )
    {
		if ( !str_cmp( argument, "mob" ) )
			SET_BIT(ship->flags,SHIP_MOB);
		else if ( !str_cmp( argument, "regular" ) )
			REMOVE_BIT(ship->flags,SHIP_MOB);
		else
		{
			send_to_char( "Ship type must be either: regular or mob.\n\r", ch );
			return;
		}
		send_to_char( "Done.\n\r", ch );
		save_ship( ship );
		return;
	}

    if ( !str_cmp( arg2, "name" ) )
    {
		STRFREE( ship->name );
		ship->name = STRALLOC( argument );
		send_to_char( "Done.\n\r", ch );
		save_ship( ship );
		return;
    }

    if ( !str_cmp( arg2, "filename" ) )
    {  
        char filename[256];
	if ( ship->filename && ship->filename[0] != '\0' )
        {
           sprintf( filename, "%s%s", SPACE_DIR, ship->filename );
	   remove( filename );
           DISPOSE( ship->filename );
        }
	ship->filename = str_dup( argument );
	send_to_char( "Done.\n\r", ch );
	save_ship( ship );
	write_ship_list( );
	return;
    }

    if ( !str_cmp( arg2, "desc" ) )
    {
		STRFREE( ship->description );
		ship->description = STRALLOC( argument );
		send_to_char( "Done.\n\r", ch );
		save_ship( ship );
		return;
    }

    if ( !str_cmp( arg2, "manuever" ) )
    {
		ship->manuever = URANGE( 0, atoi(argument) , 120 );
		send_to_char( "Done.\n\r", ch );
		save_ship( ship );
		return;
    }

    if ( !str_cmp( arg2, "lasers" ) )
    {
		ship->lasers = URANGE( 0, atoi(argument) , 10 );
		ship->lasers = atoi(argument);
		send_to_char( "Done.\n\r", ch );
		save_ship( ship );
		return;
    }

	if ( !str_cmp( arg2, "ions" ) )
    {
		ship->ion = URANGE( 0, atoi(argument) , 10 );
		ship->ion = atoi(argument);
		send_to_char( "Done.\n\r", ch );
		save_ship( ship );
		return;
    }

	if ( !str_cmp( arg2, "alarms" ) )
    {
		ship->alarm = URANGE( 0, atoi(argument) , 10 );
		ship->alarm = atoi(argument);
		send_to_char( "Done.\n\r", ch );
		save_ship( ship );
		return;
    }

	if ( !str_cmp( arg2, "laserdamage" ) )
    {
		if (atoi(argument) > 300 && atoi(argument) > 0 )
		{
			send_to_char("Between 0 and 5",ch);
			return;
		}
		ship->laserdamage = atoi(argument);
		send_to_char( "Done.\n\r", ch );
		save_ship( ship );
		return;
    }

    if ( !str_cmp( arg2, "class" ) )
    {
		ship->class = URANGE( 0, atoi(argument) , 9 );

		send_to_char( "Done.\n\r", ch );
		save_ship( ship );
		return;
    }

    if ( !str_cmp( arg2, "missiles" ) )
    {
		ship->maxmissiles = URANGE( 0, atoi(argument) , 255 );
		ship->missiles = URANGE( 0, atoi(argument) , 255 );
		send_to_char( "Done.\n\r", ch );
		save_ship( ship );
		return;
    }

    if ( !str_cmp( arg2, "speed" ) )
    {
		ship->realspeed = URANGE( 0, atoi(argument) , 150 );
		send_to_char( "Done.\n\r", ch );
		save_ship( ship );
		return;
    }

    if ( !str_cmp( arg2, "tractorbeam" ) )
    {
		ship->tractorbeam = URANGE( 0, atoi(argument) , 255 );
		send_to_char( "Done.\n\r", ch );
		save_ship( ship );
		return;
    }

    if ( !str_cmp( arg2, "hyperspeed" ) )
    {
		ship->hyperspeed = URANGE( 0, atoi(argument) , 255 );
		send_to_char( "Done.\n\r", ch );
		save_ship( ship );
		return;
    }

    if ( !str_cmp( arg2, "shield" ) )
    {
		ship->maxshield = URANGE( 0, atoi(argument) , 1000 );
		send_to_char( "Done.\n\r", ch );
		save_ship( ship );
		return;
    }

    if ( !str_cmp( arg2, "hull" ) )
    {
		ship->hull = URANGE( 1, atoi(argument) , 20000 );
		ship->maxhull = URANGE( 1, atoi(argument) , 20000 );
		send_to_char( "Done.\n\r", ch );
		save_ship( ship );
		return;
    }

    if ( !str_cmp( arg2, "energy" ) )
    {
		ship->energy = URANGE( 1, atoi(argument) , 30000 );
		ship->maxenergy = URANGE( 1, atoi(argument) , 30000 );
		send_to_char( "Done.\n\r", ch );
		save_ship( ship );
		return;
    }

    if ( !str_cmp( arg2, "sensor" ) )
    {
		ship->sensor = URANGE( 0, atoi(argument) , 255 );
		send_to_char( "Done.\n\r", ch );
		save_ship( ship );
		return;
    }

    if ( !str_cmp( arg2, "astroarray" ) )
    {
		ship->astro_array = URANGE( 0, atoi(argument) , 255 );
		send_to_char( "Done.\n\r", ch );
		save_ship( ship );
		return;
    }

    if ( !str_cmp( arg2, "comm" ) )
    {
		ship->comm = URANGE( 0, atoi(argument) , 255 );
		send_to_char( "Done.\n\r", ch );
		save_ship( ship );
		return;
    }

    if ( !str_cmp( arg2, "chaff" ) )
    {
		ship->chaff = URANGE( 0, atoi(argument) , 25 );
		ship->maxchaff = URANGE( 0, atoi(argument) , 25 );
		send_to_char( "Done.\n\r", ch );
		save_ship( ship );
		return;
    }

	if ( !str_cmp( arg2, "origname" ) )
    {
		STRFREE( ship->origname );
		ship->origname = STRALLOC( argument );
		send_to_char( "Done.\n\r", ch );
		save_ship( ship );
		return;
    }

	if ( !str_cmp( arg2, "bombs" ) )
	{
		ship->bombs = URANGE( 0, atoi(argument) , 25 );
		ship->maxbombs = URANGE( 0, atoi(argument) , 25 );
		send_to_char( "Done.\n\r", ch );
		save_ship( ship );
		return;
	}

	if ( !str_cmp( arg2, "flags" ) )
    {
		if ( !argument || argument[0] == '\0' )
		{
			send_to_char( "Usage: setship <ship> flags <flag> [flag]...\n\r", ch );
			send_to_char( "canflyindoors bayopen autopilot\n\r", ch );
			return;
		}
		while ( argument[0] != '\0' )
		{
			argument = one_argument( argument, arg3 );
			value = get_shipflag( arg3 );
			if ( value < 0 || value > 31 )
				ch_printf( ch, "Unknown flag: %s\n\r", arg3 );
			else
			{
				TOGGLE_BIT(ship->flags, 1 << value);
			}
		}
		send_to_char( "Done.\n\r", ch );
		save_ship( ship );
		return;
	}

	if ( !str_cmp(arg2, "prototype" ) )
	{
		SHIP_PROTOTYPE * prototype;
		if (!str_cmp(argument,"none") )
		{
			if ( ship->prototype != NULL )
				ship->prototype->count--;
			ship->prototype = NULL;
			send_to_char( "Done.\n\r",ch);
			save_ship( ship );
			return;
		}
		if ( argument[0] == '\0' )
		{
			send_to_char("You must supply a prototype name.\n\r",ch);
			return;
		}
		if ( ( prototype = get_ship_prototype( argument ) ) == NULL )
		{
			send_to_char("Invalid Prototype Type.\n\r",ch);
			return;
		}
		if ( ship->prototype != NULL )
				ship->prototype->count--;
		ship->prototype = prototype;
		ship->prototype->count++;
		ship->maxenergy = ship->prototype->maxenergy;
		ship->maxshield = ship->prototype->maxshield;
		ship->maxhull = ship->prototype->maxhull;
		ship->comm = ship->prototype->comm;
		ship->sensor = ship->prototype->sensor;
		ship->astro_array = ship->prototype->astro_array;
		ship->hyperspeed = ship->prototype->hyperspeed;
		ship->realspeed = ship->prototype->realspeed;
		ship->maxmissiles = ship->prototype->maxmissiles;
		ship->maxchaff = ship->prototype->maxchaff;
		ship->lasers = ship->prototype->lasers;
		ship->tractorbeam = ship->prototype->tractorbeam;
		ship->manuever = ship->prototype->manuever;
		ship->ion = ship->prototype->ion;
		ship->maxbombs = ship->prototype->maxbombs;

		if ( ship->prototype->description && ship->prototype->description[0] != '\0' )
		{
			STRFREE( ship->description );
			ship->description = STRALLOC( ship->prototype->description );
		}
		ship->class = ship->prototype->class;
		ship->energy = ship->maxenergy;
		send_to_char("Done\n\r",ch);
		save_ship( ship );
		return;
	}

	do_setship( ch, "" );
    return;
}

void do_showship( CHAR_DATA *ch, char *argument )
{
    SHIP_DATA *ship;

    if ( IS_NPC( ch ) )
    {
		send_to_char( "Huh?\n\r", ch );
		return;
    }

    if ( argument[0] == '\0' )
    {
		send_to_char( "Usage: showship <ship>\n\r", ch );
		return;
    }

    ship = get_ship( argument );
    if ( !ship )
    {
		send_to_char( "No such ship.\n\r", ch );
		return;
    }
    set_char_color( AT_YELLOW, ch );
	ch_printf( ch, "&R%s %s &P: &R%s\n\r&G&WFilename&P: &R%s\n\r",
		IS_SET(ship->flags,SHIP_MOB) ? "Mob" : "Player" ,
		ship->class == FIGHTER_SHIP ? "Starfighter" :
	(ship->class == MIDSIZE_SHIP ? "Midship" :
	(ship->class == CAPITAL_SHIP ? "Capital Ship" :
	(ship->class == SHIP_PLATFORM ? "Platform" : "Unknown" ) ) ),
		ship->name, ship->filename);
	ch_printf( ch, "&WHome&P: &R%s   &WDescription&P: &R%s\n\r"
		"&WOwner&P: &R%s   &WPilot&P: &R%s   &WCopilot&P: &R%s&W\n\r",
		ship->home,  ship->description, ship->owner, ship->pilot,  ship->copilot );
	if (ship->origname)
		ch_printf( ch, "Original Name: %s\n\r", ship->origname );
	ch_printf( ch, "Firstroom: %d   Lastroom: %d"
		"Cockpit: %d   Entrance: %d   Hanger: %d  Engineroom: %d\n\r",
		ship->firstroom, ship->lastroom, ship->cockpit, ship->entrance, 
		ship->hanger,ship->engineroom);
	ch_printf( ch, "Pilotseat: %d   Coseat: %d   Navseat: %d  Gunseat: %d\n\r",
		ship->pilotseat, ship->coseat, ship->navseat, ship->gunseat );
	ch_printf( ch, "Location: %d   Lastdoc: %d   Shipyard: %d\n\r",
		ship->location, ship->lastdoc, ship->shipyard );
	ch_printf( ch, "Tractor Beam: %d   Comm: %d   Sensor: %d   Astro Array: %d\n\r",
		ship->tractorbeam, ship->comm, ship->sensor, ship->astro_array );
	ch_printf( ch, "Lasers: %d  Laser Condition: %s\n\r", 
		ship->lasers, ship->statet0 == LASER_DAMAGED ? "Damaged" : "Good" );
	ch_printf( ch, "Turret One: %d  Condition: %s\n\r",	
		ship->turret1, ship->statet1 == LASER_DAMAGED ? "Damaged" : "Good" );
	ch_printf( ch, "Turret Two: %d  Condition: %s\n\r",
		ship->turret2, ship->statet2 == LASER_DAMAGED ? "Damaged" : "Good" );
	ch_printf( ch, "Ion Cannons: %d  Condition: %s\n\r",
		ship->ion, ship->statet3 == LASER_DAMAGED ? "Damaged" : "Good" );
	ch_printf( ch, "Missiles: %d/%d  Condition: %s\n\r",
		ship->missiles, ship->maxmissiles,
		ship->missilestate == MISSILE_DAMAGED ? "Damaged" : "Good" );
	ch_printf( ch, "Hull: %d/%d  Ship Condition: %s\n\r",
		ship->hull, ship->maxhull,
		ship->shipstate == SHIP_DISABLED ? "Disabled" : "Running");
	ch_printf( ch, "Shields: %d/%d   Energy(fuel): %d/%d   Chaff: %d/%d\n\r",
		ship->shield, ship->maxshield, ship->energy,
		ship->maxenergy, ship->chaff, ship->maxchaff);
	ch_printf( ch, "Current Coordinates: %.0f %.0f %.0f\n\r",
		ship->vx, ship->vy, ship->vz );
	ch_printf( ch, "Current Heading: %.0f %.0f %.0f\n\r",
		ship->hx, ship->hy, ship->hz );
	ch_printf( ch, "Speed: %d/%d   Hyperspeed: %d\n\rManueverability: %d\n\r",
		ship->currspeed, ship->realspeed, ship->hyperspeed , ship->manuever );
	ch_printf( ch, "Ship State: %d\n\r", ship->shipstate);
	ch_printf( ch, "Alarms: %d\n\r", ship->alarm);
	ch_printf( ch, "Bombs: %d/%d\n\r", ship->bombs, ship->maxbombs);
	if (get_trust(ch) == MAX_LEVEL)
		ch_printf( ch, "Ship Flags: %s\n\r", flag_string(ship->flags, ship_flags));
	return;
}

void do_makeship( CHAR_DATA *ch, char *argument )
{
    SHIP_DATA *ship;
    char arg[MAX_INPUT_LENGTH];

    argument = one_argument( argument, arg );

    if ( !argument || argument[0] == '\0' )
    {
	send_to_char( "Usage: makeship <filename> <ship name>\n\r", ch );
	return;
    }

    CREATE( ship, SHIP_DATA, 1 );
    LINK( ship, first_ship, last_ship, next, prev );

    ship->name			= STRALLOC( argument );
	ship->origname		= STRALLOC( argument );
    ship->description	= STRALLOC( "" );
    ship->owner 		= STRALLOC( "" );
    ship->copilot       = STRALLOC( "" );
    ship->pilot         = STRALLOC( "" );
    ship->home          = STRALLOC( "" );
    ship->flags         = 0;
	ship->color			= STRALLOC( "Cyan" );
	ship->prototype		= NULL;
    ship->starsystem	= NULL;
    ship->energy		= ship->maxenergy;
    ship->hull			= ship->maxhull;
    ship->in_room		= NULL;
    ship->next_in_room	= NULL;
    ship->prev_in_room	= NULL;
    ship->currjump		= NULL;
    ship->target0		= NULL;
    ship->target1		= NULL;
    ship->target2		= NULL;

    ship->filename = str_dup( arg );
    save_ship( ship );
    write_ship_list( );

}

void do_copyship( CHAR_DATA *ch, char *argument )
{
    SHIP_DATA *ship;
    SHIP_DATA *old;
    char arg[MAX_INPUT_LENGTH];
    char arg2[MAX_INPUT_LENGTH];

    argument = one_argument( argument, arg );
    argument = one_argument( argument, arg2 );

    if ( !argument || argument[0] == '\0' )
    {
	send_to_char( "Usage: copyship <oldshipname> <filename> <newshipname>\n\r", ch );
	return;
    }

    old = get_ship ( arg );

    if (!old)
    {
	send_to_char( "Thats not a ship!\n\r", ch );
	return;
    }

    CREATE( ship, SHIP_DATA, 1 );
    LINK( ship, first_ship, last_ship, next, prev );

    ship->name			= STRALLOC(argument);
	ship->origname		= STRALLOC(argument);
    ship->description	= STRALLOC("");
    ship->owner 		= STRALLOC("");
    ship->copilot       = STRALLOC("");
    ship->pilot         = STRALLOC("");
    ship->home          = STRALLOC("");
	ship->flags			= old->flags;
    ship->class         = old->class;
	ship->prototype		= old->prototype;
    ship->lasers        = old->lasers;
	ship->laserdamage   = old->laserdamage;
    ship->maxmissiles   = old->maxmissiles;
    ship->maxshield     = old->maxshield;
    ship->maxhull       = old->maxhull;
    ship->maxenergy     = old->maxenergy;
    ship->hyperspeed    = old->hyperspeed;
    ship->maxchaff      = old->maxchaff;
    ship->realspeed     = old->realspeed;
    ship->manuever      = old->manuever;
	ship->color			= old->color;
	ship->ion			= old->ion;
	ship->astro_array	= old->astro_array;
	ship->sensor		= old->sensor;
	ship->maxbombs      = old->maxbombs;
    ship->in_room		= NULL;
    ship->next_in_room	= NULL;
    ship->prev_in_room	= NULL;
    ship->currjump		= NULL;
    ship->target0		= NULL;
    ship->target1		= NULL;
    ship->target2		= NULL;

    ship->filename		= str_dup(arg2);
    save_ship( ship );
    write_ship_list();
}

void do_ships( CHAR_DATA *ch, char *argument )
{
    SHIP_DATA *ship;
    int count;

    if ( !IS_NPC(ch) )
    {
		count = 0;
		send_to_char( "&YThe following ships are owned by you or by your organization:\n\r", ch );
		send_to_char( "\n\r&WShip                               Owner\n\r",ch);
		for ( ship = first_ship; ship; ship = ship->next )
		{
			if ( ship->class > SHIP_PLATFORM )
				continue;
			if (IS_SET(ship->flags,SHIP_MOB))
				continue;
			set_char_color( AT_BLUE, ch );

			if ( !str_cmp(ship->owner, ch->name) )
			{
				if  ( ship->in_room )
					ch_printf( ch, "&R[&WOwner&R]&B%-35s     %s.\n\r",ship->name, ship->in_room->name);
				else if (ship->starsystem && ship->starsystem->name)
					ch_printf( ch, "&R[&WOwner&R]&B%-35s     %s.\n\r",ship->name, ship->starsystem->name);
			}
			else if ( !str_cmp(ship->pilot, ch->name) )
			{
				if  ( ship->in_room )
					ch_printf( ch, "&R[&WPilot&R]&B%-35s     %s.\n\r",ship->name, ship->in_room->name);
				else if (ship->starsystem && ship->starsystem->name)
					ch_printf( ch, "&R[&WPilot&R]&B%-35s     %s.\n\r",ship->name, ship->starsystem->name);
			}
			else if ( !str_cmp(ship->copilot, ch->name) )
			{
				if  ( ship->in_room )
					ch_printf( ch, "&R[&WCo-Pilot&R]&B%-35s     %s.\n\r",ship->name, ship->in_room->name);
				else if (ship->starsystem && ship->starsystem->name)
					ch_printf( ch, "&R[&WCo-Pilot&R]&B%-35s     %s.\n\r",ship->name, ship->starsystem->name);
			}
			else if ( ch->pcdata && ch->pcdata->clan && ch->pcdata->clan->name && !str_cmp(ship->owner, ch->pcdata->clan->name) )
			{
				if  ( ship->in_room )
					ch_printf( ch, "&R[&WClan&R]&B%-35s     %s.\n\r",ship->name, ship->in_room->name);
				else if (ship->starsystem && ship->starsystem->name)
					ch_printf( ch, "&R[&WClan&R]&B%-35s     %s.\n\r",ship->name, ship->starsystem->name);
			}
			else
				continue;
			count++;
		}

		if ( !count )
		{
			send_to_char( "There are no ships owned by you.\n\r", ch );
		}
	}

	count =0;
	send_to_char( "&Y\n\rThe following ships are docked here:\n\r", ch );

    send_to_char( "\n\r&WShip                               Owner          Cost/Rent\n\r", ch );
	for ( ship = first_ship; ship; ship = ship->next )
    {
		if ( ship->location != ch->in_room->vnum || ship->class > SHIP_PLATFORM)
			continue;
        if (IS_SET(ship->flags,SHIP_MOB))
			continue;
		set_char_color( AT_BLUE, ch );

        ch_printf( ch, "%-35s %-15s", ship->name, ship->owner );
        if (IS_SET(ship->flags,SHIP_MOB) || ship->class == SHIP_PLATFORM )
		{
			ch_printf( ch, "\n\r");
			continue;
        }
        if ( !str_cmp(ship->owner, "Public") )
        {
			ch_printf( ch, "%ld to rent.\n\r", get_ship_value(ship)/100 );
        }
        else if ( str_cmp(ship->owner, "Unowned") )
			ch_printf( ch, "%s", "\n\r" );
        else
			ch_printf( ch, "%ld to buy.\n\r", get_ship_value(ship) );
        count++;
	}

    if ( !count )
    {
		send_to_char( "There are no ships docked here.\n\r", ch );
    }
}
#define ALL_SHIP -1
#define MOB_SHIP -2
void do_allships( CHAR_DATA *ch, char *argument )
{
	SHIP_DATA *ship;
	int count = 0;
	int ship_class;
	
	if ( !str_cmp(argument,"all" ) || argument[0] == '\0' )
		ship_class = ALL_SHIP;
	else if ( !str_cmp(argument,"fighter") )
		ship_class = FIGHTER_SHIP;
	else if ( !str_cmp(argument,"midsize") )
		ship_class = MIDSIZE_SHIP;
	else if ( !str_cmp(argument,"capital") )
		ship_class = CAPITAL_SHIP;
	else if ( !str_cmp(argument,"platform") )
		ship_class = SHIP_PLATFORM;
	else if ( !str_cmp(argument,"mob" ) )
		ship_class = MOB_SHIP;
	else
		ship_class = ALL_SHIP;

	send_to_char( "&Y\n\rThe following ships are currently formed:\n\r", ch );
	send_to_char( "\n\r&WShip                               Owner\n\r", ch );
	
	if ( IS_IMMORTAL( ch ) && ship_class == MOB_SHIP)
	{
		for ( ship = first_ship; ship; ship = ship->next )
		{
			if (IS_SET(ship->flags,SHIP_MOB) )
			{
				set_char_color( AT_YELLOW, ch );
				ch_printf( ch, "&R(*)&w %-31s %-15s\n\r", ship->name, ship->owner );
			}
		}
		return;
	}
	
	for ( ship = first_ship; ship; ship = ship->next )
	{
		if ( ship_class != ALL_SHIP && ship->class != ship_class )
			continue;
        if (IS_SET(ship->flags,SHIP_MOB))
			continue;
		set_char_color( AT_BLUE, ch );
        
		ch_printf( ch, "%-35s %-15s ", ship->name, ship->owner );
		if (IS_SET(ship->flags,SHIP_MOB) || ship->class == SHIP_PLATFORM )
		{
			ch_printf( ch, "\n\r");
			continue;
		}
		if ( !str_cmp(ship->owner, "Public") )
		{
			ch_printf( ch, "%ld to rent.\n\r", get_ship_value(ship)/100 );
		}
		else if ( str_cmp(ship->owner, "") )
			ch_printf( ch, "%s", "\n\r" );
		else
			ch_printf( ch, "%ld to buy.\n\r", get_ship_value(ship) );
        count++;
	}
	if ( !count )
	{
		send_to_char( "There are no ships currently formed.\n\r", ch );
		return;
	}
}
#undef ALL_SHIP
#undef MOB_SHIP

void ship_to_starsystem( SHIP_DATA *ship , SPACE_DATA *starsystem )
{
     if ( starsystem == NULL )
        return;

     if ( ship == NULL )
        return;

     if ( starsystem->first_ship == NULL )
        starsystem->first_ship = ship;

     if ( starsystem->last_ship )
     {
         starsystem->last_ship->next_in_starsystem = ship;
         ship->prev_in_starsystem = starsystem->last_ship;
     }

     starsystem->last_ship = ship;

     ship->starsystem = starsystem;

}

void new_missile( SHIP_DATA *ship , SHIP_DATA *target , CHAR_DATA *ch , int missiletype )
{
     SPACE_DATA *starsystem;
     MISSILE_DATA *missile;

     if ( ship  == NULL )
        return;

    if ( target  == NULL )
        return;

     if ( ( starsystem = ship->starsystem ) == NULL )
        return;

     CREATE( missile, MISSILE_DATA, 1 );
     LINK( missile, first_missile, last_missile, next, prev );

     missile->target = target;
     missile->fired_from = ship;
     if ( ch )
        missile->fired_by = STRALLOC( ch->name );
     else
        missile->fired_by = STRALLOC( "" );
     missile->missiletype = missiletype;
     missile->age =0;
     if ( missile->missiletype == HEAVY_BOMB )
       missile->speed = 20;
     else if ( missile->missiletype == PROTON_TORPEDO )
       missile->speed = 200;
	 else if ( missile->missiletype == CONCUSSION_MISSILE )
       missile->speed = 300;
     else
       missile->speed = 50;

     missile->mx = ship->vx;
     missile->my = ship->vy;
     missile->mz = ship->vz;

     if ( starsystem->first_missile == NULL )
        starsystem->first_missile = missile;

     if ( starsystem->last_missile )
     {
         starsystem->last_missile->next_in_starsystem = missile;
         missile->prev_in_starsystem = starsystem->last_missile;
     }

     starsystem->last_missile = missile;
     missile->starsystem = starsystem;
}

void ship_from_starsystem( SHIP_DATA *ship , SPACE_DATA *starsystem )
{
     if ( starsystem == NULL )
        return;

     if ( ship == NULL )
        return;

     if ( starsystem->last_ship == ship )
        starsystem->last_ship = ship->prev_in_starsystem;

     if ( starsystem->first_ship == ship )
        starsystem->first_ship = ship->next_in_starsystem;

     if ( ship->prev_in_starsystem )
        ship->prev_in_starsystem->next_in_starsystem = ship->next_in_starsystem;

     if ( ship->next_in_starsystem)
        ship->next_in_starsystem->prev_in_starsystem = ship->prev_in_starsystem;

     ship->starsystem = NULL;
     ship->next_in_starsystem = NULL;
     ship->prev_in_starsystem = NULL;

}

void extract_missile( MISSILE_DATA *missile )
{
    SPACE_DATA *starsystem;

     if ( missile == NULL )
        return;

     if ( ( starsystem = missile->starsystem ) != NULL )
     {

      if ( starsystem->last_missile == missile )
        starsystem->last_missile = missile->prev_in_starsystem;

      if ( starsystem->first_missile == missile )
        starsystem->first_missile = missile->next_in_starsystem;

      if ( missile->prev_in_starsystem )
        missile->prev_in_starsystem->next_in_starsystem = missile->next_in_starsystem;

      if ( missile->next_in_starsystem)
        missile->next_in_starsystem->prev_in_starsystem = missile->prev_in_starsystem;

      missile->starsystem = NULL;
      missile->next_in_starsystem = NULL;
      missile->prev_in_starsystem = NULL;

     }

     UNLINK( missile, first_missile, last_missile, next, prev );

     missile->target = NULL;
     missile->fired_from = NULL;
     if (  missile->fired_by )
        STRFREE( missile->fired_by );

     DISPOSE( missile );
}

bool is_rental( CHAR_DATA *ch , SHIP_DATA *ship )
{
   if ( !str_cmp("Public",ship->owner) )
          return TRUE;

   return FALSE;
}

bool check_pilot( CHAR_DATA *ch , SHIP_DATA *ship )
{
	CLAN_DATA   *clan;

	if ( IS_NPC(ch) && IS_SET(ship->flags,SHIP_MOB) )
		return TRUE;
	if ( !str_cmp(ch->name,ship->owner) || !str_cmp(ch->name,ship->pilot)
		|| !str_cmp(ch->name,ship->copilot) || !str_cmp("Public",ship->owner) )
	return TRUE;

	if ( !IS_NPC(ch) && ch->pcdata && ch->pcdata->clan )
		clan = ch->pcdata->clan;
	else if ( IS_NPC(ch) && ch->mob_clan )
		clan = get_clan(ch->mob_clan->name);
	else { return FALSE; }

	if ( !str_cmp(clan->name,ship->owner) )
	{
		if ( !str_cmp(clan->leader,ch->name) )
			return TRUE;
		if ( !str_cmp(clan->number1,ch->name) )
			return TRUE;
		if ( !str_cmp(clan->number2,ch->name) )
			return TRUE;
		if ( !IS_NPC(ch) && ch->pcdata->bestowments && is_name( "pilot", ch->pcdata->bestowments) )
			return TRUE;
	}

	return FALSE;
}

bool extract_ship( SHIP_DATA *ship )
{
	ROOM_INDEX_DATA *room;

    if ( ( room = ship->in_room ) != NULL )
    {
        UNLINK( ship, room->first_ship, room->last_ship, next_in_room, prev_in_room );
        ship->in_room = NULL;
    }
    return TRUE;
}

void damage_ship_ch( SHIP_DATA *ship , int min , int max , CHAR_DATA *ch )
{
    int damage , shield_dmg;
    long xp;

    damage = number_range( min , max );

    xp = ( exp_level( ch->skill_level[PILOTING_ABILITY]+1) - exp_level( ch->skill_level[PILOTING_ABILITY]) ) / 25 ;
    xp = UMIN( get_ship_value( ship ) /100 , xp ) ;
    gain_exp( ch , xp , PILOTING_ABILITY );

    if ( ship->shield > 0 )
    {
        shield_dmg = UMIN( ship->shield , damage );
    	damage -= shield_dmg;
    	ship->shield -= shield_dmg;
    	if ( ship->shield == 0 )
    	  echo_to_cockpit( AT_BLOOD , ship , "Shields down..." );
    }

    if ( damage > 0 )
    {
			if ( number_range(1, 100) <= 5 && ship->shipstate != SHIP_DISABLED )
			{
				echo_to_cockpit( AT_BLOOD + AT_BLINK , ship , "Ships Drive DAMAGED!" );
				ship->shipstate = SHIP_DISABLED;
				ship->currspeed = 0;
			}

			if ( number_range(1, 100) <= 5 && ship->missilestate != MISSILE_DAMAGED && ship->maxmissiles > 0 )
			{
				echo_to_room( AT_BLOOD + AT_BLINK , get_room_index(ship->gunseat) , "Ships Missile Launcher DAMAGED!" );
				ship->missilestate = MISSILE_DAMAGED;
			}

			if ( number_range(1, 100) <= 2 && ship->statet0 != LASER_DAMAGED )
			{
				echo_to_room( AT_BLOOD + AT_BLINK , get_room_index(ship->gunseat) , "Lasers DAMAGED!" );
				ship->statet1 = LASER_DAMAGED;
			}

			if ( number_range(1, 100) <= 5 && ship->statet1 != LASER_DAMAGED && ship->turret1 )
			{
				echo_to_room( AT_BLOOD + AT_BLINK , get_room_index(ship->turret1) , "Turret DAMAGED!" );
				ship->statet1 = LASER_DAMAGED;
			}

			if ( number_range(1, 100) <= 5 && ship->statet2 != LASER_DAMAGED && ship->turret2 )
			{
				echo_to_room( AT_BLOOD + AT_BLINK , get_room_index(ship->turret2) , "Turret DAMAGED!" );
				ship->statet2 = LASER_DAMAGED;
			}
    }

    ship->hull -= damage*5;

    if ( ship->hull <= 0 )
    {
       destroy_ship( ship , ch );

       xp =  ( exp_level( ch->skill_level[PILOTING_ABILITY]+1) - exp_level( ch->skill_level[PILOTING_ABILITY]) );
       xp = UMIN( get_ship_value( ship ) , xp );
       gain_exp( ch , xp , PILOTING_ABILITY);
       ch_printf( ch, "&WYou gain %ld piloting experience!\n\r", xp );
       return;
    }

    if ( ship->hull <= ship->maxhull/20 )
       echo_to_cockpit( AT_BLOOD+ AT_BLINK , ship , "ABANDON SHIP!" );

}

void damage_ship( SHIP_DATA *ship , int min , int max )
{
    int damage , shield_dmg;
    damage = number_range( min , max );
    if ( ship->shield > 0 )
    {
        shield_dmg = UMIN( ship->shield , damage );
    	damage -= shield_dmg;
    	ship->shield -= shield_dmg;
    	if ( ship->shield == 0 )
    	  echo_to_cockpit( AT_BLOOD , ship , "Shields down..." );
    }

    if ( damage > 0 )
    {

        if ( number_range(1, 100) <= 5 && ship->shipstate != SHIP_DISABLED )
        {
           echo_to_cockpit( AT_BLOOD + AT_BLINK , ship , "Ships Drive DAMAGED!" );
           ship->shipstate = SHIP_DISABLED;
           ship->currspeed = 0;
        }

        if ( number_range(1, 100) <= 5 && ship->missilestate != MISSILE_DAMAGED && ship->maxmissiles > 0 )
        {
           echo_to_room( AT_BLOOD + AT_BLINK , get_room_index(ship->gunseat) , "Ships Missile Launcher DAMAGED!" );
           ship->missilestate = MISSILE_DAMAGED;
        }

        if ( number_range(1, 100) <= 2 && ship->statet1 != LASER_DAMAGED && ship->turret1 )
        {
           echo_to_room( AT_BLOOD + AT_BLINK , get_room_index(ship->turret1) , "Turret DAMAGED!" );
           ship->statet1 = LASER_DAMAGED;
        }

        if ( number_range(1, 100) <= 2 && ship->statet2 != LASER_DAMAGED && ship->turret2 )
        {
           echo_to_room( AT_BLOOD + AT_BLINK , get_room_index(ship->turret2) , "Turret DAMAGED!" );
           ship->statet2 = LASER_DAMAGED;
        }

    }

    ship->hull -= damage*5;

    if ( ship->hull <= 0 )
    {
       destroy_ship( ship , NULL );
       return;
    }

    if ( ship->hull <= ship->maxhull/20 )
       echo_to_cockpit( AT_BLOOD+ AT_BLINK , ship , "ABANDON SHIP!" );

}

void destroy_ship( SHIP_DATA *ship , CHAR_DATA *ch )
{
	char buf[MAX_STRING_LENGTH];
    int  roomnum;
	bool survived;
	ROOM_INDEX_DATA *room;
    OBJ_DATA *robj;
    CHAR_DATA *rch;

    sprintf( buf , "%s explodes in a blinding flash of light!", ship->name );
    echo_to_system( AT_WHITE + AT_BLINK , ship , buf , NULL );

	sprintf( buf , "%s destroyed by %s", ship->name , ch ? ch->name : "(none)" );
    log_string( buf );

    echo_to_ship( AT_WHITE , ship , "The ship is shaken by a FATAL explosion. You realize its escape or perish.");
    echo_to_ship( AT_WHITE , ship , "The last thing you remember is reaching for the escape pod release lever.");
    echo_to_ship( AT_WHITE + AT_BLINK , ship , "A blinding flash of light.");
    echo_to_ship( AT_WHITE, ship , "And then darkness....");

	for ( roomnum = ship->firstroom ; roomnum <= ship->lastroom ;roomnum++ )
	{
		if ( (room = get_room_index( roomnum )) == NULL )
			continue;
		rch = room->first_person;
		while ( rch )
		{
			survived = FALSE;

			if ( !IS_NPC( rch ) && ship->starsystem && ( number_percent( ) > 1 ) )
			{
				ROOM_INDEX_DATA *pRoom;
				PLANET_DATA *planet;
				OBJ_DATA * scraps;
				AREA_DATA   *area;
				int rnum = 0;

				for ( planet = first_planet; planet; planet = planet->next )
				{
					if ( planet->starsystem && planet->starsystem == ship->starsystem )
						break;
				}
				if ( !planet )
				{
					bug( "Escape pods: %s is in a planetless system in %s", rch->name, ship->starsystem->name,0);
					survived = FALSE;
				}
				else
				{
					for ( area = planet->first_area ; area ; area = area->next_on_planet )
					{
						for ( rnum = area->low_r_vnum ; rnum <= area->hi_r_vnum; rnum++ )
						{
							if ( (pRoom = get_room_index( rnum )) == NULL )
								continue;
							if ( xIS_SET(pRoom->room_flags, ROOM_CRASH) && !xIS_SET(pRoom->room_flags, ROOM_INDOORS ) )
							{
								char_from_room(rch);
								char_to_room( rch, pRoom );
								if ( !IS_IMMORTAL( rch ) )
									rch->hit = -1;
								update_pos( rch );
								echo_to_room( AT_WHITE , rch->in_room , "There is loud explosion as an escape pod hits the earth." );

								scraps        = create_object( get_obj_index( OBJ_VNUM_SCRAPS ), 0 );
								scraps->timer = 15;
								STRFREE( scraps->short_descr );
								scraps->short_descr = STRALLOC( "a battered escape pod" );
								STRFREE( scraps->description );
								scraps->description = STRALLOC( "The smoking shell of an escape pod litters the earth.\n\r" );
								obj_to_room( scraps, pRoom);

								survived = TRUE;
								break;
							}
						}
					}
				}/* if ( !planet ) - else */
			}

			if ( !survived && IS_IMMORTAL(rch) )
			{
				char_from_room(rch);
				char_to_room( rch, get_room_index(wherehome(rch)) );
				survived = TRUE;
			}

			if ( !survived )
			{
				if ( ch )
					raw_kill( ch , rch );
				else
					raw_kill( rch , rch );
			}
			rch = room->first_person;
		}

		for ( robj = room->first_content ; robj ; robj = robj->next_content )
		{
			separate_obj( robj );
			extract_obj( robj );
		}
	}

    resetship(ship);

}

bool ship_to_room(SHIP_DATA *ship , int vnum )
{
    ROOM_INDEX_DATA *shipto;

    if ( (shipto=get_room_index(vnum)) == NULL )
            return FALSE;
    LINK( ship, shipto->first_ship, shipto->last_ship, next_in_room, prev_in_room );
    ship->in_room = shipto;
    return TRUE;
}


void do_board( CHAR_DATA *ch, char *argument )
{
	ROOM_INDEX_DATA *fromroom;
	ROOM_INDEX_DATA *toroom;
	SHIP_DATA *ship;

	if ( !argument || argument[0] == '\0')
	{
		send_to_char( "Board what?\n\r", ch );
		return;
	}

	if ( ( ship = ship_in_room( ch->in_room , argument ) ) == NULL )
	{
		act( AT_PLAIN, "I see no $T here.", ch, NULL, argument, TO_CHAR );
		return;
	}

	if ( IS_SET( ch->act, ACT_MOUNTED ) )
	{
		act( AT_PLAIN, "You can't go in there riding THAT.", ch, NULL, argument, TO_CHAR );
		return;
	}

	fromroom = ch->in_room;

	if ( ( toroom = get_room_index( ship->entrance ) ) != NULL )
	{
		if ( ! ship->hatchopen )
		{
			send_to_char( "&RThe hatch is closed!\n\r", ch);
			return;
		}

		if ( toroom->tunnel > 0 )
		{
			CHAR_DATA *ctmp;
			int count = 0;

			for ( ctmp = toroom->first_person; ctmp; ctmp = ctmp->next_in_room )
				if ( ++count >= toroom->tunnel )
				{
					send_to_char( "There is no room for you in there.\n\r", ch );
					return;
				}
		}
		if ( ship->shipstate == SHIP_LAUNCH || ship->shipstate == SHIP_LAUNCH_2 )
		{
			send_to_char("&rThat ship has already started launching!\n\r",ch);
			return;
		}

		act( AT_PLAIN, "$n enters $T.", ch, NULL, ship->name , TO_ROOM );
	    act( AT_PLAIN, "You enter $T.", ch,	NULL, ship->name , TO_CHAR );
		char_from_room( ch );
		char_to_room( ch , toroom );
		act( AT_PLAIN, "$n enters the ship.", ch, NULL, argument , TO_ROOM );
		do_look( ch , "auto" );
	}
	else
		send_to_char("That ship has no entrance!\n\r", ch);
}

bool rent_ship( CHAR_DATA *ch , SHIP_DATA *ship )
{
    long price;
    if ( IS_NPC ( ch ) )
      return FALSE;

   price = get_ship_value( ship )/100;

       if ( ch->gold < price )
       {
         ch_printf(ch, "&RRenting this ship costs %ld. You don't have enough credits!\n\r" , price );
         return FALSE;
       }

       ch->gold -= price;

      ch_printf(ch, "&GYou pay %ld credits to rent the ship.\n\r" , price );
       return TRUE;

}

void do_leaveship( CHAR_DATA *ch, char *argument )
{
    ROOM_INDEX_DATA *fromroom;
    ROOM_INDEX_DATA *toroom;
    SHIP_DATA *ship;
	SHIP_DATA *target;

    fromroom = ch->in_room;

    if  ( (ship = ship_from_entrance(fromroom->vnum)) == NULL )
    {
        send_to_char( "I see no exit here.\n\r" , ch );
        return;
    }

    if  ( ship->class == SHIP_PLATFORM )
    {
        send_to_char( "You can't do that here.\n\r" , ch );
        return;
    }

	if (ship && ship->shipstate == SHIP_SHIP2SHIP) 
	{
		target = ship_from_entrance( ship->docked2 );

		if ( ! ship->hatchopen )
		{
			send_to_char("&RYou need to open the hatch first" , ch );
			return;
		}

		if ( !target ) 
		{
			send_to_char("&RYou're Not Docked!\n\r",ch);
			return;
		}

		if ( ( toroom = get_room_index( ship->docked2 ) ) != NULL )
		{
			act( AT_PLAIN, "$n goes to the docked ship.", ch, NULL, argument , TO_ROOM );
			act( AT_PLAIN, "You arrive from the docked ship.", ch, NULL, argument , TO_CHAR );
			char_from_room( ch );
			char_to_room( ch , toroom );
			act( AT_PLAIN, "$n steps out of the docked ship.", ch, NULL, argument , TO_ROOM );
			do_look( ch , "auto" );
			return;
		}
		else
		{
			send_to_char ( "The exit doesn't seem to be working properly.\n\r", ch );
			return;
		}

	}

    if ( ship->lastdoc != ship->location )
    {
        send_to_char("&rMaybe you should wait until the ship lands.\n\r",ch);
        return;
    }

    if ( ship->shipstate != SHIP_DOCKED && ship->shipstate != SHIP_DISABLED )
    {
        send_to_char("&rPlease wait till the ship is properly docked.\n\r",ch);
        return;
    }

    if ( ! ship->hatchopen )
    {
    	send_to_char("&RYou need to open the hatch first" , ch );
    	return;
    }

    if ( ( toroom = get_room_index( ship->location ) ) != NULL )
    {
            act( AT_PLAIN, "$n exits the ship.", ch,
		NULL, argument , TO_ROOM );
	    act( AT_PLAIN, "You exit the ship.", ch,
		NULL, argument , TO_CHAR );
   	    char_from_room( ch );
   	    char_to_room( ch , toroom );
   	    act( AT_PLAIN, "$n steps out of a ship.", ch,
		NULL, argument , TO_ROOM );
            do_look( ch , "auto" );
     }
     else
        send_to_char ( "The exit doesn't seem to be working properly.\n\r", ch );
}

void do_launch( CHAR_DATA *ch, char *argument )
{
	char arg1[MAX_INPUT_LENGTH];
    int chance,value;
    long price = 0;
    SHIP_DATA *ship;
	SHIP_DATA *onship;
    char buf[MAX_STRING_LENGTH];

	argument = one_argument( argument, arg1 );
	value = atoi(arg1);

	if ( (ship = ship_from_cockpit(ch->in_room->vnum)) == NULL )
	{
		send_to_char("&RYou must be in the cockpit of a ship to do that!\n\r",ch);
		return;
	}

	if ( (onship = ship_from_hanger(ship->lastdoc)) && !IS_SET( onship->flags, SHIP_BAYOPEN ) )
	{
		send_to_char("&RThe hanger is closed!\n\r",ch);
		return;
	}

	{
		ROOM_INDEX_DATA  * room1;
		PLANET_DATA * planet;
		room1 = get_room_index(ship->lastdoc);

		if ( room1->area && room1->area->planet && ( planet = room1->area->planet ) )
		{
			if ( IS_SET(planet->flags, PLANET_PSHIELD) )
			{
				echo_to_room( AT_RED, get_room_index(ship->cockpit) ,
					"&W[&R^zWARNING&W^x] The planetary shield is up. Launching now can be quite dangerous\n\r" );
				return;
			}
		}

	}


	if ( ship->class > SHIP_PLATFORM )
	{
		send_to_char("&RThis isn't a spacecraft!\n\r",ch);
		return;
	}

	if ( (ship = ship_from_pilotseat(ch->in_room->vnum)) == NULL )
	{
		send_to_char("&RYou don't seem to be in the pilot seat!\n\r",ch);
		return;
	}

	if ( autofly(ship) )
	{
		send_to_char("&RThe ship is set on autopilot, you'll have to turn it off first.\n\r",ch);
		return;
	}

	if  ( ship->class == SHIP_PLATFORM )
	{
		send_to_char( "You can't do that here.\n\r" , ch );
		return;
	}

	if ( value ) 
	{
		if ( ( value != ship->code ) && ( !check_pilot( ch, ship ) ) )
		{
			send_to_char("&RHey, thats not your ship! Try renting a public one.\n\r",ch);
			return;
		}
	}
	else if ( !value ) 
	{
		if ( !check_pilot( ch , ship ) )
		{
			send_to_char("&RHey, thats not your ship! Try renting a public one.\n\r",ch);
			return;
		}
	}

	if ( ship->lastdoc != ship->location )
	{
		send_to_char("&rYou don't seem to be docked right now.\n\r",ch);
		return;
	}

	if ( ship->shipstate != SHIP_DOCKED && ship->shipstate != SHIP_DISABLED  )
	{
		send_to_char("The ship is not docked right now.\n\r",ch);
		return;
	}
	if ( ship->class == FIGHTER_SHIP )
		chance = IS_NPC(ch) ? ch->top_level
		: (int)  (ch->pcdata->learned[gsn_starfighters]) ;
	if ( ship->class == MIDSIZE_SHIP )
		chance = IS_NPC(ch) ? ch->top_level
		: (int)  (ch->pcdata->learned[gsn_midships]) ;
	if ( ship->class == CAPITAL_SHIP )
		chance = IS_NPC(ch) ? ch->top_level
		: (int) (ch->pcdata->learned[gsn_capitalships]);
	if ( number_percent( ) < chance )
	{
		if ( is_rental(ch,ship) )
			if( !rent_ship(ch,ship) )
				return;
			if ( !is_rental(ch,ship) )
			{
				if ( ship->class == FIGHTER_SHIP )
					price=20;
				if ( ship->class == MIDSIZE_SHIP )
					price=50;
				if ( ship->class == CAPITAL_SHIP )
					price=500;
				price += ship->maxhull-ship->hull;
				if (ship->missiles )
					price += ( 75 * (ship->maxmissiles-ship->missiles) );
				if (ship->shipstate == SHIP_DISABLED )
					price += 500;
				if ( ship->missilestate == MISSILE_DAMAGED )
					price += 500;
				if ( ship->statet0 == LASER_DAMAGED )
					price += 250;
				if ( ship->statet1 == LASER_DAMAGED )
					price += 250;
				if ( ship->statet2 == LASER_DAMAGED )
					price += 250;
				if ( ship->statet3 == LASER_DAMAGED )
					price += 250;
			}
			if ( ch->pcdata && ch->pcdata->clan )
			{
				if ( !str_cmp(ch->pcdata->clan->name,ship->owner) )
				{
					if ( ch->pcdata->clan->funds < price )
					{
						ch_printf(ch, "&R%s doesn't have enough funds to prepare this ship for launch.\n\r", ch->pcdata->clan->name );
						return;
					}
					
					ch->pcdata->clan->funds -= price;
					ch_printf(ch, "&GIt costs %s %ld credits to ready this ship for launch.\n\r", ch->pcdata->clan->name, price );
				}
			}
			else if ( str_cmp( ship->owner , "Public" ) )
			{
				if ( ch->gold < price )
				{
					ch_printf(ch, "&RYou don't have enough funds to prepare this ship for launch.\n\r");
					return;
				}

				ch->gold -= price;
				ch_printf(ch, "&GYou pay %ld credits to ready the ship for launch.\n\r", price );
			}
			ship->energy = ship->maxenergy;
			ship->chaff = ship->maxchaff;
			ship->missiles = ship->maxmissiles;

			ship->bombs = ship->maxbombs;

			ship->shield = 0;
			ship->autorecharge = FALSE;
			ship->autotrack = FALSE;
			ship->autospeed = FALSE;
			ship->hull = ship->maxhull;
			ship->missilestate = MISSILE_READY;
			ship->statet0 = LASER_READY;
			ship->statet1 = LASER_READY;
			ship->statet2 = LASER_READY;
			ship->statet3 = LASER_READY;
			ship->shipstate = SHIP_DOCKED;
			REMOVE_BIT(ship->flags, SHIP_MASKED);
			if (ship->energy == 0)
			{
				send_to_char("&RThis ship has no fuel.\n\r",ch);
				return;
			}

			if (ship->hatchopen)
			{
				ship->hatchopen = FALSE;
				sprintf( buf , "The hatch on %s closes." , ship->name);
				echo_to_room( AT_YELLOW , get_room_index(ship->location) , buf );
				echo_to_room( AT_YELLOW , get_room_index(ship->entrance) , "The hatch slides shut." );
				sound_to_room( get_room_index(ship->entrance) , "!!SOUND(door  U=http://mercury.spaceports.com/~gavin1/)" );
				sound_to_room( get_room_index(ship->location) , "!!SOUND(door U=http://mercury.spaceports.com/~gavin1/)" );
			}

			set_char_color( AT_GREEN, ch );
			send_to_char( "Launch sequence initiated.\n\r", ch);
			act( AT_PLAIN, "$n starts up the ship and begins the launch sequence.", ch, NULL, argument , TO_ROOM );
			echo_to_ship( AT_YELLOW , ship , "The ship hums as it lifts off the ground.");
			sprintf( buf, "%s begins to launch.", ship->name );
			echo_to_room( AT_YELLOW , get_room_index(ship->location) , buf );
			ship->shipstate = SHIP_LAUNCH;
			ship->currspeed = ship->realspeed;
			if ( ship->class == FIGHTER_SHIP )
				learn_from_success( ch, gsn_starfighters );
			if ( ship->class == MIDSIZE_SHIP )
				learn_from_success( ch, gsn_midships );
			if ( ship->class == CAPITAL_SHIP )
				learn_from_success( ch, gsn_capitalships );
			sound_to_ship(ship , "!!SOUND(xwing U=http://mercury.spaceports.com/~gavin1/)" );
			return;
	}
	set_char_color( AT_RED, ch );
	send_to_char("You fail to work the controls properly!\n\r",ch);
	if ( ship->class == FIGHTER_SHIP )
		learn_from_failure( ch, gsn_starfighters );
	if ( ship->class == MIDSIZE_SHIP )
		learn_from_failure( ch, gsn_midships );
	if ( ship->class == CAPITAL_SHIP )
		learn_from_failure( ch, gsn_capitalships );
	return;
}

void launchship( SHIP_DATA *ship )
{
    char buf[MAX_STRING_LENGTH];
	char *temp;
    SHIP_DATA *target;
	ROOM_INDEX_DATA *room;
    int plusminus;

    ship_to_starsystem( ship, starsystem_from_vnum( ship->location ) );

    if ( ship->starsystem == NULL )
    {
       echo_to_room( AT_YELLOW , get_room_index(ship->pilotseat) , "Launch path blocked .. Launch aborted.");
       echo_to_ship( AT_YELLOW , ship , "The ship slowly sets back back down on the landing pad.");
       sprintf( buf ,  "%s slowly sets back down." ,ship->name );
       echo_to_room( AT_YELLOW , get_room_index(ship->location) , buf );
       ship->shipstate = SHIP_DOCKED;
       return;
    }

    if (ship->class == MIDSIZE_SHIP)
    {
       sound_to_room( get_room_index(ship->location) , "!!SOUND(falcon U=http://mercury.spaceports.com/~gavin1/)" );
       sound_to_ship(ship , "!!SOUND(falcon U=http://mercury.spaceports.com/~gavin1/)" );
    }
    else
    {
       sound_to_ship(ship , "!!SOUND(xwing U=http://mercury.spaceports.com/~gavin1/)" );
       sound_to_room( get_room_index(ship->location) , "!!SOUND(xwing U=http://mercury.spaceports.com/~gavin1/)" );
    }

    extract_ship(ship);

    ship->location = 0;

    if (ship->shipstate != SHIP_DISABLED)
       ship->shipstate = SHIP_READY;

    plusminus = number_range ( -1 , 2 );
    if (plusminus > 0 )
        ship->hx = 1;
    else
        ship->hx = -1;

    plusminus = number_range ( -1 , 2 );
    if (plusminus > 0 )
        ship->hy = 1;
    else
        ship->hy = -1;

    plusminus = number_range ( -1 , 2 );
    if (plusminus > 0 )
        ship->hz = 1;
    else
        ship->hz = -1;

    if (ship->lastdoc == ship->starsystem->doc1a ||
        ship->lastdoc == ship->starsystem->doc1b ||
        ship->lastdoc == ship->starsystem->doc1c )
    {
       ship->vx = ship->starsystem->p1x;
       ship->vy = ship->starsystem->p1y;
       ship->vz = ship->starsystem->p1z;
    }
    else if (ship->lastdoc == ship->starsystem->doc2a ||
             ship->lastdoc == ship->starsystem->doc2b ||
             ship->lastdoc == ship->starsystem->doc2c )
    {
       ship->vx = ship->starsystem->p2x;
       ship->vy = ship->starsystem->p2y;
       ship->vz = ship->starsystem->p2z;
    }
    else if (ship->lastdoc == ship->starsystem->doc3a ||
             ship->lastdoc == ship->starsystem->doc3b ||
             ship->lastdoc == ship->starsystem->doc3c )
    {
       ship->vx = ship->starsystem->p3x;
       ship->vy = ship->starsystem->p3y;
       ship->vz = ship->starsystem->p3z;
    }
    else
    {
       for ( target = ship->starsystem->first_ship; target; target = target->next_in_starsystem )
       {
          if (ship->lastdoc == target->hanger)
          {
             ship->vx = target->vx;
             ship->vy = target->vy;
             ship->vz = target->vz;
			 temp = ship->name;
          }
       }
    }

    ship->energy -= (100+100*ship->class);

    ship->vx += (ship->hx*ship->currspeed*2);
    ship->vy += (ship->hy*ship->currspeed*2);
    ship->vz += (ship->hz*ship->currspeed*2);


	if ( ship->lastdoc )
	{
		room = get_room_index ( ship->lastdoc );
		/*	if (room->area->planet)
			temp = room->area->planet->name;
		else */
		temp = room->name;
	}

    echo_to_room( AT_GREEN , get_room_index(ship->location) , "Launch complete.\n\r");
    echo_to_ship( AT_YELLOW , ship , "The ship leaves the platform far behind as it flies into space." );
/*   sprintf( buf ,"%s enters the starsystem at %.0f %.0f %.0f" , ship->name, ship->vx, ship->vy, ship->vz ); */
	sprintf( buf ,"&W%s &BFlight Controllers report that &W%s&B has just taken off" , temp , ship->name);

    echo_to_system( AT_YELLOW, ship, buf , NULL );
    sprintf( buf, "&W%s &Blifts off into space.", ship->name );
    echo_to_room( AT_YELLOW , get_room_index(ship->lastdoc) , buf );
}

void do_land( CHAR_DATA *ch, char *argument )
{
	char arg[MAX_INPUT_LENGTH];
	int chance,count;
	SHIP_DATA *ship;
	SHIP_DATA *target;
	int vx, vy ,vz;

    strcpy( arg, argument );

	if ( (ship = ship_from_cockpit(ch->in_room->vnum)) == NULL )
	{
		send_to_char("&RYou must be in the cockpit of a ship to do that!\n\r",ch);
		return;
	}
	if ( ship->class > SHIP_PLATFORM )
	{
		send_to_char("&RThis isn't a spacecraft!\n\r",ch);
		return;
	}
	if ( (ship = ship_from_pilotseat(ch->in_room->vnum)) == NULL )
	{
		send_to_char("&RYou need to be in the pilot seat!\n\r",ch);
		return;
	}
	if ( autofly(ship) )
	{
		send_to_char("&RYou'll have to turn off the ships autopilot first.\n\r",ch);
		return;
	}
	if  ( ship->class == SHIP_PLATFORM )
	{
		send_to_char( "&RYou can't land platforms\n\r" , ch );
		return;
	}
	if (ship->class == CAPITAL_SHIP)
	{
		send_to_char("&RCapital ships are to big to land. You'll have to take a shuttle.\n\r",ch);
		return;
	}
	if (ship->shipstate == SHIP_DISABLED)
	{
		send_to_char("&RThe ships drive is disabled. Unable to land.\n\r",ch);
		return;
	}
	if (ship->shipstate == SHIP_DOCKED)
	{
		send_to_char("&RThe ship is already docked!\n\r",ch);
		return;
	}
	if ( ship->shipstate == SHIP_SHIP2SHIP )
	{
		send_to_char("Your Ship Is Docked With Something",ch);
		return;
	}
	if (ship->shipstate == SHIP_HYPERSPACE)
	{
		send_to_char("&RYou can only do that in realspace!\n\r",ch);
		return;
	}
	if (ship->shipstate != SHIP_READY)
	{
		send_to_char("&RPlease wait until the ship has finished its current maneuver.\n\r",ch);
		return;
	}
	if ( ship->starsystem == NULL )
	{
		send_to_char("&RThere's nowhere to land around here!",ch);
		return;
	}
	if ( ship->energy < (25 + 25*ship->class) )
	{
		send_to_char("&RTheres not enough fuel!\n\r",ch);
		return;
	}
	if ( argument[0] == '\0' )
	{
		count = 0;
		set_char_color(  AT_CYAN, ch );
		if ( ship->starsystem->doc1a )
		{
			ch_printf(ch, "&GN&game&G: &W%-20.20s &GP&glanet&G: &W%-20.20s &GC&goords&G: &W%d %d %d\n\r",
				ship->starsystem->location1a, ship->starsystem->planet1,
				ship->starsystem->p1x, ship->starsystem->p1y, ship->starsystem->p1z );
			count++;
		}
		if ( ship->starsystem->doc1b )
		{
			ch_printf(ch, "&GN&game&G: &W%-20.20s &GP&glanet&G: &W%-20.20s &GC&goords&G: &W%d %d %d\n\r",
				ship->starsystem->location1b, ship->starsystem->planet1,
				ship->starsystem->p1x, ship->starsystem->p1y, ship->starsystem->p1z );
			count++;
		}

		if ( ship->starsystem->doc1c )
		{
			ch_printf(ch, "&GN&game&G: &W%-20.20s &GP&glanet&G: &W%-20.20s &GC&goords&G: &W%d %d %d\n\r",
				ship->starsystem->location1c, ship->starsystem->planet1,
				ship->starsystem->p1x, ship->starsystem->p1y, ship->starsystem->p1z );
			count++;
		}
		if ( ship->starsystem->doc2a )
		{
			ch_printf(ch, "&GN&game&G: &W%-20.20s &GP&glanet&G: &W%-20.20s &GC&goords&G: &W%d %d %d\n\r",
				ship->starsystem->location2a, ship->starsystem->planet2,
				ship->starsystem->p2x, ship->starsystem->p2y, ship->starsystem->p2z );
			count++;
		}
		if ( ship->starsystem->doc2b )
		{
			ch_printf(ch, "&GN&game&G: &W%-20.20s &GP&glanet&G: &W%-20.20s &GC&goords&G: &W%d %d %d\n\r",
				ship->starsystem->location2b, ship->starsystem->planet2,
				ship->starsystem->p2x, ship->starsystem->p2y, ship->starsystem->p2z );
			count++;
		}
		if ( ship->starsystem->doc2c )
		{
			ch_printf(ch, "&GN&game&G: &W%-20.20s &GP&glanet&G: &W%-20.20s &GC&goords&G: &W%d %d %d\n\r",
				ship->starsystem->location2c, ship->starsystem->planet2,
				ship->starsystem->p2x, ship->starsystem->p2y, ship->starsystem->p2z );
			count++;
		}
		if ( ship->starsystem->doc3a )
		{
			ch_printf(ch, "&GN&game&G: &W%-20.20s &GP&glanet&G: &W%-20.20s &GC&goords&G: &W%d %d %d\n\r",
				ship->starsystem->location3a, ship->starsystem->planet3,
				ship->starsystem->p3x, ship->starsystem->p3y, ship->starsystem->p3z );
			count++;
		}
		if ( ship->starsystem->doc3b )
		{
			ch_printf(ch, "&GN&game&G: &W%-20.20s &GP&glanet&G: &W%-20.20s &GC&goords&G: &W%d %d %d\n\r",
				ship->starsystem->location3b, ship->starsystem->planet3,
				ship->starsystem->p3x, ship->starsystem->p3y, ship->starsystem->p3z );
			count++;
		}
		if ( ship->starsystem->doc3c )
		{
			ch_printf(ch, "&GN&game&G: &W%-20.20s &GP&glanet&G: &W%-20.20s &GC&goords&G: &W%d %d %d\n\r",
				ship->starsystem->location3c, ship->starsystem->planet3,
				ship->starsystem->p3x, ship->starsystem->p3y, ship->starsystem->p3z );
			count++;
		}
		if ( count <= 0)
			ch_printf(ch, "&B| &GN&go &GL&ganding &GS&gpots &GL&gocated                                                     &B|\n\r");
		count = 0;
		for ( target = ship->starsystem->first_ship; target; target = target->next_in_starsystem )
		{
			if ( target->hanger > 0 && target != ship)
			{
				ch_printf(ch, "&GS&ghip &GN&game&G: &W%-35s &GC&goords&G: &W%.0f %.0f %.0f\n\r",
					target->name,  target->vx, target->vy, target->vz);
				count++;
			}
		}
		ch_printf(ch, "\n\r&GY&gour &GC&goordinates&G: &W%-.0f %-.0f %-.0f\n\r" ,
			ship->vx , ship->vy, ship->vz);
		return;
	}

	if ( str_prefix(argument,ship->starsystem->location1a) &&
		str_prefix(argument,ship->starsystem->location2a) &&
		str_prefix(argument,ship->starsystem->location3a) &&
		str_prefix(argument,ship->starsystem->location1b) &&
		str_prefix(argument,ship->starsystem->location2b) &&
		str_prefix(argument,ship->starsystem->location3b) &&
		str_prefix(argument,ship->starsystem->location1c) &&
		str_prefix(argument,ship->starsystem->location2c) &&
		str_prefix(argument,ship->starsystem->location3c) )
	{
		target = get_ship_here( argument , ship->starsystem );
		if ( target == NULL )
		{
			send_to_char("&RI don't see that here. Type land by itself for a list\n\r",ch);
			return;
		}
		if ( target == ship )
		{
			send_to_char("&RYou can't land your ship inside itself!\n\r",ch);
			return;
		}
		if ( !target->hanger && target->hanger > 0 )
		{
			send_to_char("&RThat ship has no hanger for you to land in!\n\r",ch);
			return;
		}
		if ( ship->class == MIDSIZE_SHIP && target->class == MIDSIZE_SHIP )
		{
			send_to_char("&RThat ship is not big enough for your ship to land in!\n\r",ch);
			return;
		}
		/*if ( ! target->bayopen )*/
		if ( !IS_SET( target->flags, SHIP_BAYOPEN ) )
		{
			send_to_char("&RTheir hanger is closed. You'll have to ask them to open it for you\n\r",ch);
			return;
		}
		if (  (target->vx > ship->vx + 200) || (target->vx < ship->vx - 200) ||
			(target->vy > ship->vy + 200) || (target->vy < ship->vy - 200) ||
			(target->vz > ship->vz + 200) || (target->vz < ship->vz - 200) )
		{
			send_to_char("&R That ship is too far away! You'll have to fly a little closer.\n\r",ch);
			return;
		}
	}
	else
	{
		if ( !str_prefix(argument,ship->starsystem->location3a) ||
			!str_prefix(argument,ship->starsystem->location3b) ||
			!str_prefix(argument,ship->starsystem->location3c) )
		{
			vx = ship->starsystem->p3x;
			vy = ship->starsystem->p3y;
			vz = ship->starsystem->p3z;
		}
		if ( !str_prefix(argument,ship->starsystem->location2a) ||
			!str_prefix(argument,ship->starsystem->location2b) ||
			!str_prefix(argument,ship->starsystem->location2c) )
		{
			vx = ship->starsystem->p2x;
			vy = ship->starsystem->p2y;
			vz = ship->starsystem->p2z;
		}
		if ( !str_prefix(argument,ship->starsystem->location1a) ||
			!str_prefix(argument,ship->starsystem->location1b) ||
			!str_prefix(argument,ship->starsystem->location1c) )
		{
			vx = ship->starsystem->p1x;
			vy = ship->starsystem->p1y;
			vz = ship->starsystem->p1z;
		}
		if (  (vx > ship->vx + 200) || (vx < ship->vx - 200) ||
			(vy > ship->vy + 200) || (vy < ship->vy - 200) ||
			(vz > ship->vz + 200) || (vz < ship->vz - 200) )
		{
			send_to_char("&R That platform is too far away! You'll have to fly a little closer.\n\r",ch);
			return;
		}
	}
	if ( ship->class == FIGHTER_SHIP )
		chance = IS_NPC(ch) ? ch->top_level : (int)  (ch->pcdata->learned[gsn_starfighters]) ;
	if ( ship->class == MIDSIZE_SHIP )
		chance = IS_NPC(ch) ? ch->top_level : (int)  (ch->pcdata->learned[gsn_midships]) ;
	if ( number_percent( ) < chance )
	{
		set_char_color( AT_GREEN, ch );
		send_to_char( "Landing sequence initiated.\n\r", ch);
		act( AT_PLAIN, "$n begins the landing sequence.", ch, NULL, argument , TO_ROOM );
		echo_to_ship( AT_YELLOW , ship , "The ship slowly begins its landing approach.");
		ship->dest = STRALLOC(arg);
		ship->shipstate = SHIP_LAND;
		ship->currspeed = 0;
		if ( ship->class == FIGHTER_SHIP )
			learn_from_success( ch, gsn_starfighters );
		if ( ship->class == MIDSIZE_SHIP )
			learn_from_success( ch, gsn_midships );
		if ( starsystem_from_vnum(ship->lastdoc) != ship->starsystem )
		{
			int xp =  (exp_level( ch->skill_level[PILOTING_ABILITY]+1) - exp_level( ch->skill_level[PILOTING_ABILITY])) ;
			xp = UMIN( get_ship_value( ship ) , xp );
			gain_exp( ch , xp , PILOTING_ABILITY );
			ch_printf( ch, "&WYou gain %ld points of flight experience!\n\r", UMIN( get_ship_value( ship ) , xp ) );
		}
		return;
	}
	send_to_char("You fail to work the controls properly.\n\r",ch);
	if ( ship->class == FIGHTER_SHIP )
		learn_from_failure( ch, gsn_starfighters );
	else
		learn_from_failure( ch, gsn_midships );
	return;
}

void landship( SHIP_DATA *ship, char *arg )
{
    SHIP_DATA *target;
    char buf[MAX_STRING_LENGTH];
    int destination;
	ROOM_INDEX_DATA  * room1;

    if ( !str_prefix(arg,ship->starsystem->location3a) )
       destination = ship->starsystem->doc3a;
    if ( !str_prefix(arg,ship->starsystem->location3b) )
       destination = ship->starsystem->doc3b;
    if ( !str_prefix(arg,ship->starsystem->location3c) )
       destination = ship->starsystem->doc3c;
    if ( !str_prefix(arg,ship->starsystem->location2a) )
       destination = ship->starsystem->doc2a;
    if ( !str_prefix(arg,ship->starsystem->location2b) )
       destination = ship->starsystem->doc2b;
    if ( !str_prefix(arg,ship->starsystem->location2c) )
       destination = ship->starsystem->doc2c;
    if ( !str_prefix(arg,ship->starsystem->location1a) )
       destination = ship->starsystem->doc1a;
    if ( !str_prefix(arg,ship->starsystem->location1b) )
       destination = ship->starsystem->doc1b;
    if ( !str_prefix(arg,ship->starsystem->location1c) )
       destination = ship->starsystem->doc1c;

    target = get_ship_here( arg , ship->starsystem );
/*    if ( target != ship && target != NULL && target->bayopen
            && ( ship->class != MIDSIZE_SHIP || target->class != MIDSIZE_SHIP ) )*/
    if ( target != ship && target != NULL && IS_SET( target->flags, SHIP_BAYOPEN )
            && ( ship->class != MIDSIZE_SHIP || target->class != MIDSIZE_SHIP ) )
    destination = target->hanger;

	room1 = get_room_index(destination);
	if ( room1 )
	{
		PLANET_DATA * planet;

		if ( room1->area && room1->area->planet && ( planet = room1->area->planet ) )
		{
			if ( IS_SET(planet->flags, PLANET_PSHIELD) )
			{
				echo_to_room( AT_RED, get_room_index(ship->cockpit) ,
					"&W[&R^zWARNING&W^x] The planetary shield is up. Landing now can be quite dangerous\n\r" );
				if (ship->shipstate != SHIP_DISABLED)
					ship->shipstate = SHIP_READY;
				ship->lastdoc = destination;
				return;
			}
		}

	}

    if ( !ship_to_room( ship , destination ) )
    {
       echo_to_room( AT_YELLOW , get_room_index(ship->pilotseat), "Could not complete aproach. Landing aborted.");
       echo_to_ship( AT_YELLOW , ship , "The ship pulls back up out of its landing sequence.");
       if (ship->shipstate != SHIP_DISABLED)
           ship->shipstate = SHIP_READY;
	   ship->lastdoc = destination;
       return;
    }

    echo_to_room( AT_YELLOW , get_room_index(ship->pilotseat), "Landing sequence complete.");
    echo_to_ship( AT_YELLOW , ship , "You feel a slight thud as the ship sets down on the ground.");
	sprintf( buf ,"%s cuts sublight engines and engages repulsorlifts." , ship->name  );
    echo_to_system( AT_YELLOW, ship, buf , NULL );

    ship->location = destination;
    ship->lastdoc = ship->location;
    if (ship->shipstate != SHIP_DISABLED)
       ship->shipstate = SHIP_DOCKED;
    ship_from_starsystem(ship, ship->starsystem);

    sprintf( buf, "%s lands on the platform.", ship->name );
    echo_to_room( AT_YELLOW , get_room_index(ship->location) , buf );

    ship->energy = ship->energy - 25 - 25*ship->class;

    if ( !str_cmp("Public",ship->owner) )
    {
       ship->energy = ship->maxenergy;
       ship->chaff = ship->maxchaff;
	   ship->bombs = ship->maxbombs;
       ship->missiles = ship->maxmissiles;
       ship->shield = 0;
       ship->autorecharge = FALSE;
       ship->autotrack = FALSE;
       ship->autospeed = FALSE;
       ship->hull = ship->maxhull;

       ship->missilestate = MISSILE_READY;
       ship->statet0 = LASER_READY;
       ship->statet1 = LASER_READY;
       ship->statet2 = LASER_READY;
       ship->shipstate = SHIP_DOCKED;

       echo_to_cockpit( AT_YELLOW , ship , "Repairing and refueling ship..." );
    }

       save_ship(ship);
}

void do_accelerate( CHAR_DATA *ch, char *argument )
{
    int chance;
    int change;
    SHIP_DATA *ship;
    char buf[MAX_STRING_LENGTH];

	if (  (ship = ship_from_cockpit(ch->in_room->vnum))  == NULL )
	{
		send_to_char("&RYou must be in the cockpit of a ship to do that!\n\r",ch);
		return;
	}
	if ( ship->class > SHIP_PLATFORM )
	{
		send_to_char("&RThis isn't a spacecraft!\n\r",ch);
		return;
	}
	if (  (ship = ship_from_pilotseat(ch->in_room->vnum))  == NULL )
	{
		send_to_char("&RThe controls must be at the pilots chair...\n\r",ch);
		return;
	}
	if ( autofly(ship) )
	{
		send_to_char("&RYou'll have to turn off the ships autopilot first.\n\r",ch);
		return;
	}
	if  ( ship->class == SHIP_PLATFORM )
	{
		send_to_char( "&RPlatforms can't move!\n\r" , ch );
		return;
	}
	if (ship->shipstate == SHIP_HYPERSPACE)
	{
		send_to_char("&RYou can only do that in realspace!\n\r",ch);
		return;
	}
	if (ship->shipstate == SHIP_DISABLED)
	{
		send_to_char("&RThe ship's drive is disabled. Unable to accelerate.\n\r",ch);
		return;
	}
	if (ship->shipstate == SHIP_DOCKED)
	{
		send_to_char("&RYou can't do that until after you've launched!\n\r",ch);
		return;
	}
	if ( ship->shipstate == SHIP_SHIP2SHIP )
	{
		send_to_char("&RYou can't do that until you undock!\n\r",ch);
		return;
	}
	if ( ship->energy < abs((atoi(argument)-abs(ship->currspeed))/10) )
	{
		send_to_char("&RTheres not enough fuel!\n\r",ch);
		return;
	}
	if ( ship->class == FIGHTER_SHIP )
		chance = IS_NPC(ch) ? ch->top_level : (int)  (ch->pcdata->learned[gsn_starfighters]) ;
	if ( ship->class == MIDSIZE_SHIP )
		chance = IS_NPC(ch) ? ch->top_level : (int)  (ch->pcdata->learned[gsn_midships]) ;
	if ( ship->class == CAPITAL_SHIP )
		chance = IS_NPC(ch) ? ch->top_level : (int) (ch->pcdata->learned[gsn_capitalships]);
	if ( number_percent( ) >= chance )
	{
		send_to_char("&RYou fail to work the controls properly.\n\r",ch);
		if ( ship->class == FIGHTER_SHIP )
			learn_from_failure( ch, gsn_starfighters );
		if ( ship->class == MIDSIZE_SHIP )
			learn_from_failure( ch, gsn_midships );
		if ( ship->class == CAPITAL_SHIP )
			learn_from_failure( ch, gsn_capitalships );
		return;
	}
    change = atoi(argument);
	act( AT_PLAIN, "$n manipulates the ships controls.", ch, NULL, argument , TO_ROOM );
	if ( change > ship->currspeed )
	{
		send_to_char( "&GAccelerating\n\r", ch);
		echo_to_cockpit( AT_YELLOW , ship , "The ship begins to accelerate.");
		if ( !IS_SET(ship->flags, SHIP_MASKED) )
		{
			sprintf( buf, "%s begins to speed up." , ship->name );
			echo_to_system( AT_ORANGE , ship , buf , NULL );
		}
	}
    if ( change < ship->currspeed )
	{
		send_to_char( "&GDecelerating\n\r", ch);
		echo_to_cockpit( AT_YELLOW , ship , "The ship begins to slow down.");
		if ( !IS_SET(ship->flags, SHIP_MASKED) )
		{
			sprintf( buf, "%s begins to slow down." , ship->name );
			echo_to_system( AT_ORANGE , ship , buf , NULL );
		}
	}

    ship->energy -= abs((change-abs(ship->currspeed))/10);
    ship->currspeed = URANGE( 0 , change , ship->realspeed );
    if ( ship->class == FIGHTER_SHIP )
		learn_from_success( ch, gsn_starfighters );
	if ( ship->class == MIDSIZE_SHIP )
		learn_from_success( ch, gsn_midships );
	if ( ship->class == CAPITAL_SHIP )
		learn_from_success( ch, gsn_capitalships );
}

void do_trajectory( CHAR_DATA *ch, char *argument )
{
    char  buf[MAX_STRING_LENGTH];
    char  arg2[MAX_INPUT_LENGTH];
    char  arg3[MAX_INPUT_LENGTH];
    int chance;
    float vx,vy,vz;
    SHIP_DATA *ship;


    	        if (  (ship = ship_from_cockpit(ch->in_room->vnum))  == NULL )
    	        {
    	            send_to_char("&RYou must be in the cockpit of a ship to do that!\n\r",ch);
    	            return;
    	        }

                if ( ship->class > SHIP_PLATFORM )
    	        {
    	            send_to_char("&RThis isn't a spacecraft!\n\r",ch);
    	            return;
    	        }

                if (  (ship = ship_from_pilotseat(ch->in_room->vnum))  == NULL )
    	        {
    	            send_to_char("&RYour not in the pilots seat.\n\r",ch);
    	            return;
    	        }

                if ( autofly(ship))
    	        {
    	            send_to_char("&RYou'll have to turn off the ships autopilot first.\n\r",ch);
    	            return;
    	        }

                if (ship->shipstate == SHIP_DISABLED)
    	        {
    	            send_to_char("&RThe ships drive is disabled. Unable to manuever.\n\r",ch);
    	            return;
    	        }
                if  ( ship->class == SHIP_PLATFORM )
                {
                   send_to_char( "&RPlatforms can't turn!\n\r" , ch );
                   return;
                }

    	        if (ship->shipstate == SHIP_HYPERSPACE)
                {
                  send_to_char("&RYou can only do that in realspace!\n\r",ch);
                  return;
                }
    	        if (ship->shipstate == SHIP_DOCKED)
    	        {
    	            send_to_char("&RYou can't do that until after you've launched!\n\r",ch);
    	            return;
    	        }
				if ( ship->shipstate == SHIP_SHIP2SHIP )
				{
					send_to_char("&RYou can't do that until you undock!\n\r",ch);
					return;
				}
    	        if (ship->shipstate != SHIP_READY)
    	        {
    	            send_to_char("&RPlease wait until the ship has finished its current manouver.\n\r",ch);
    	            return;
    	        }
    	        if ( ship->energy < (ship->currspeed/10) )
    	        {
    	           send_to_char("&RTheres not enough fuel!\n\r",ch);
    	           return;
    	        }

                if ( ship->class == FIGHTER_SHIP )
                    chance = IS_NPC(ch) ? ch->top_level
	                 : (int)  (ch->pcdata->learned[gsn_starfighters]) ;
                if ( ship->class == MIDSIZE_SHIP )
                    chance = IS_NPC(ch) ? ch->top_level
	                 : (int)  (ch->pcdata->learned[gsn_midships]) ;
                if ( ship->class == CAPITAL_SHIP )
                    chance = IS_NPC(ch) ? ch->top_level
	                 : (int) (ch->pcdata->learned[gsn_capitalships]);
                if ( number_percent( ) > chance )
    		{
	        send_to_char("&RYou fail to work the controls properly.\n\r",ch);
	        if ( ship->class == FIGHTER_SHIP )
                    learn_from_failure( ch, gsn_starfighters );
                if ( ship->class == MIDSIZE_SHIP )
    	            learn_from_failure( ch, gsn_midships );
                if ( ship->class == CAPITAL_SHIP )
                    learn_from_failure( ch, gsn_capitalships );
    	   	return;
    	        }

    argument = one_argument( argument, arg2 );
    argument = one_argument( argument, arg3 );

    vx = atof( arg2 );
    vy = atof( arg3 );

    vz = atof( argument );

    if ( vx == ship->vx && vy == ship->vy && vz == ship->vz )
    {
       ch_printf( ch , "The ship is already at %.0f %.0f %.0f !" ,vx,vy,vz);
    }

    ship->hx = vx - ship->vx;
    ship->hy = vy - ship->vy;
    ship->hz = vz - ship->vz;

    ship->energy -= (ship->currspeed/10);

    ch_printf( ch ,"&GNew course set, approaching %.0f %.0f %.0f.\n\r" , vx,vy,vz );
    act( AT_PLAIN, "$n manipulates the ships controls.", ch, NULL, argument , TO_ROOM );

    echo_to_cockpit( AT_YELLOW ,ship, "The ship begins to turn.\n\r" );
	if ( !IS_SET(ship->flags, SHIP_MASKED) )
	{
		sprintf( buf, "%s turns altering its present course." , ship->name );
		echo_to_system( AT_ORANGE , ship , buf , NULL );
	}

    if ( ship->class == FIGHTER_SHIP || ( ship->class == MIDSIZE_SHIP && ship->manuever > 50 ) )
        ship->shipstate = SHIP_BUSY_3;
    else if ( ship->class == MIDSIZE_SHIP || ( ship->class == CAPITAL_SHIP && ship->manuever > 50 ) )
        ship->shipstate = SHIP_BUSY_2;
    else
        ship->shipstate = SHIP_BUSY;

    if ( ship->class == FIGHTER_SHIP )
        learn_from_success( ch, gsn_starfighters );
    if ( ship->class == MIDSIZE_SHIP )
        learn_from_success( ch, gsn_midships );
    if ( ship->class == CAPITAL_SHIP )
        learn_from_success( ch, gsn_capitalships );

}

void do_buyship(CHAR_DATA *ch, char *argument )
{
    long         price;
    SHIP_DATA   *ship;

   if ( IS_NPC(ch) || !ch->pcdata )
   {
   	send_to_char( "&ROnly players can do that!\n\r" ,ch );
   	return;
   }

   ship = ship_in_room( ch->in_room , argument );
   if ( !ship )
   {
      ship = ship_from_cockpit( ch->in_room->vnum );

      if ( !ship )
      {
           act( AT_PLAIN, "I see no $T here.", ch, NULL, argument, TO_CHAR );
           return;
      }
   }

   if ( str_cmp( ship->owner , "Unowned" ) || IS_SET(ship->flags,SHIP_MOB) )
   {
   	send_to_char( "&RThat ship isn't for sale!" ,ch );
   	return;
   }

	price = get_ship_value( ship );

    if ( (ch->gold+ch->pcdata->bank) < price )
    {
       ch_printf(ch, "&RThis ship costs %ld. You don't have enough credits!\n\r" , price );
       return;
    }

	ch_printf(ch, "&GYou pay %ld credits to purchace the ship.\n\r" , price );
	if ( ch->gold < price )
	{
		price -= ch->gold;
		ch->gold = 0;
		ch->pcdata->bank -= price;
	}
	else
		ch->gold -= price;


    act( AT_PLAIN, "$n walks over to a terminal and makes a credit transaction.",ch,
       NULL, argument , TO_ROOM );

    	STRFREE( ship->owner );
	ship->owner = STRALLOC( ch->name );
	save_ship( ship );
}

void do_clanbuyship(CHAR_DATA *ch, char *argument )
{
	long         price;
	SHIP_DATA   *ship;
	CLAN_DATA   *clan;
	
	if ( IS_NPC(ch) || !ch->pcdata )
	{
		send_to_char( "&ROnly players can do that!\n\r" ,ch );
		return;
	}
	if ( !ch->pcdata->clan )
	{
		send_to_char( "&RYou aren't a member of an organization!\n\r" ,ch );
		return;
	}
	
	clan = ch->pcdata->clan;
	
	if ( ( ch->pcdata->bestowments
		&& is_name("clanbuyship", ch->pcdata->bestowments))
		|| !str_cmp( ch->name, clan->leader  )) {}
	else
	{
		send_to_char( "&RYour organization hasn't seen fit to bestow you with that ability.\n\r" ,ch );
		return;
	}
	
	ship = ship_in_room( ch->in_room , argument );
	if ( !ship )
   {
      ship = ship_from_cockpit( ch->in_room->vnum );

      if ( !ship )
      {
           act( AT_PLAIN, "I see no $T here.", ch, NULL, argument, TO_CHAR );
           return;
      }
   }

   if ( str_cmp( ship->owner , "Unowned" ) || IS_SET(ship->flags,SHIP_MOB) )
   {
   	send_to_char( "&RThat ship isn't for sale!\n\r" ,ch );
   	return;
  }

	price = get_ship_value( ship );

    if ( clan->funds < price )
    {
       ch_printf(ch, "&RThis ship costs %ld. You don't have enough credits!\n\r" , price );
       return;
    }

    clan->funds -= price;
    ch_printf(ch, "&G%s pays %ld credits to purchace the ship.\n\r", clan->name , price );

    act( AT_PLAIN, "$n walks over to a terminal and makes a credit transaction.",ch, NULL, argument , TO_ROOM );

   	STRFREE( ship->owner );
	ship->owner = STRALLOC( clan->name );
	save_ship( ship );
	
	clan->spacecraft++;
}

void do_clansellship(CHAR_DATA *ch, char *argument )
{
	long         price;
    SHIP_DATA   *ship;
	CLAN_DATA   *clan;
	
	if ( IS_NPC(ch) || !ch->pcdata )
	{
		send_to_char( "&ROnly players can do that!\n\r" ,ch );
		return;
	}
	if ( !ch->pcdata->clan )
	{
		send_to_char( "&RYou aren't a member of an organization!\n\r" ,ch );
		return;
	}
	
	clan = ch->pcdata->clan;
	
	if ( ( ch->pcdata->bestowments
		&& is_name("clansellship", ch->pcdata->bestowments))
		|| !str_cmp( ch->name, clan->leader  ))
		;
	else
	{
		send_to_char( "&RYour organization hasn't seen fit to bestow you with that ability.\n\r" ,ch );
		return;
	}
	
	ship = ship_in_room( ch->in_room , argument );
	if ( !ship )
	{
		ship = ship_from_cockpit( ch->in_room->vnum );
		if ( !ship )
		{
			act( AT_PLAIN, "I see no $T here.", ch, NULL, argument, TO_CHAR );
			return;
		}
	}
	
	if ( !check_pilot( ch , ship ) || !str_cmp( ship->owner , "Public" ) )
	{
		send_to_char("&RHey, thats not your ship!\n\r",ch);
		return;
	}
	
	price = get_ship_value( ship );
	clan->funds += ( price - price/10 );
	ch_printf(ch, "&G%s receive %ld credits from selling %s's ship.\n\r" , clan->name, price - price/10, clan->name );
    act( AT_PLAIN, "$n walks over to a terminal and makes a credit transaction.",ch, NULL, argument , TO_ROOM );
	STRFREE( ship->owner );
	ship->owner = STRALLOC( "Unowned" );
	save_ship( ship );
	clan->spacecraft--;
}

void do_sellship(CHAR_DATA *ch, char *argument )
{
    long         price;
    SHIP_DATA   *ship;

   ship = ship_in_room( ch->in_room , argument );
   if ( !ship )
   {
            act( AT_PLAIN, "I see no $T here.", ch, NULL, argument, TO_CHAR );
           return;
   }

   if ( str_cmp( ship->owner , ch->name ) )
   {
   	send_to_char( "&RThat isn't your ship!" ,ch );
   	return;
   }

   price = get_ship_value( ship );

    ch->gold += ( price - price/10 );
    ch_printf(ch, "&GYou receive %ld credits from selling your ship.\n\r" , price - price/10 );

    act( AT_PLAIN, "$n walks over to a terminal and makes a credit transaction.",ch,
       NULL, argument , TO_ROOM );

	STRFREE( ship->owner );
	ship->owner = STRALLOC( "Unowned" );
	save_ship( ship );

}

void do_info(CHAR_DATA *ch, char *argument )
{
    SHIP_DATA *ship;
    SHIP_DATA *target;
	char buf[MAX_STRING_LENGTH];

    if (  (ship = ship_from_cockpit(ch->in_room->vnum))  == NULL )
    {
		if ( argument[0] == '\0' )
		{
			act( AT_PLAIN, "Which ship do you want info on?.", ch, NULL, NULL, TO_CHAR );
			return;
		}

		ship = ship_in_room( ch->in_room , argument );
		if ( !ship )
		{
			act( AT_PLAIN, "I see no $T here.", ch, NULL, argument, TO_CHAR );
			return;
		}

		target = ship;
    }
    else if (argument[0] == '\0')
		target = ship;
    else
		target = get_ship_here( argument , ship->starsystem );

    if ( target == NULL )
    {
		send_to_char("&RI don't see that here.\n\rTry the radar, or type info by itself for info on this ship.\n\r",ch);
		return;
    }

    if ( abs(target->vx - ship->vx) > 500+ship->sensor*2 ||
		abs(target->vy - ship->vy) > 500+ship->sensor*2 ||
		abs(target->vz - ship->vz) > 500+ship->sensor*2 )
    {
        send_to_char("&RThat ship is to far away to scan.\n\r",ch);
		return;
    }
	ch_printf( ch, "&B%s %s : ",
		IS_SET(target->flags,SHIP_MOB) ? "Mob" : "Player",
		target->class == FIGHTER_SHIP ? "Starfighter" :
	(target->class == MIDSIZE_SHIP ? "Midtarget" : 
	(target->class == CAPITAL_SHIP ? "Capital Ship" : 
	(target->class == SHIP_PLATFORM ? "Platform" : "Unknown" ))));
	ch_printf( ch,"%s\n\r", target->name);
	ch_printf( ch, "&WDescription: &B%s\n\r"
		"&WOwner: &B%s   &WPilot: &B%s   &WCopilot: &B%s\n\r",
		target->description, target->owner, target->pilot,  target->copilot );
	ch_printf( ch, "&WLaser cannons : &B%d\n\r", target->lasers);
	ch_printf( ch, "&WMaximum Missiles: &B%d  &WMax Chaff: &B%d\n\r",
		target->maxmissiles, target->maxchaff );
	ch_printf( ch, "&WMax Hull: &B%d  ", target->maxhull);
	ch_printf( ch, "&WMax Shields: &B%d   &WMax Energy&R(fuel&R): &B%d\n\r",
		target->maxshield, target->maxenergy);
	ch_printf( ch, "&WIon Cannons: &B%d\n\r",target->ion);
	ch_printf( ch, "&BB&Wombs&B: &W%d&B/&W%d\n\r",target->bombs,target->maxbombs);
	if ( check_pilot( ch, target ) )
		ch_printf( ch, "&BA&Wlarm &BL&Wevel&B: &W%d\n\r",target->alarm);
	ch_printf( ch, "&WMaximum Speed: &B%d   &WHyperspeed: &B%s\n\r",
		target->realspeed, get_hyperspeed(target->hyperspeed));
	
	sprintf( buf , "%s scopes out %s, carefully examining it, including the drive system and fuel pods.", ch->name, target->name);
	act( AT_PLAIN, buf, ch, NULL, argument , TO_ROOM );
}

void do_autorecharge(CHAR_DATA *ch, char *argument )
{
	int chance;
	SHIP_DATA *ship;
	int recharge;

	if (  (ship = ship_from_cockpit(ch->in_room->vnum))  == NULL )
	{
		send_to_char("&RYou must be in the cockpit of a ship to do that!\n\r",ch);
		return;
	}

	if (  (ship = ship_from_coseat(ch->in_room->vnum))  == NULL )
	{
		send_to_char("&RYou must be in the co-pilots seat!\n\r",ch);
		return;
	}

	if ( autofly(ship)  )
	{
		send_to_char("&RYou'll have to turn off the ships autopilot first.\n\r",ch);
		return;
	}

	chance = IS_NPC(ch) ? ch->top_level : (int)  (ch->pcdata->learned[gsn_shipsystems]) ;
	if ( number_percent( ) > chance )
	{
		send_to_char("&RYou fail to work the controls properly.\n\r",ch);
		learn_from_failure( ch, gsn_shipsystems );
		return;
	}

    act( AT_PLAIN, "$n flips a switch on the control panel.", ch,  NULL, argument , TO_ROOM );
    if ( !str_cmp(argument,"on" ) )
    {
        ship->autorecharge=TRUE;
        send_to_char( "&GYou power up the shields.\n\r", ch);
        echo_to_cockpit( AT_YELLOW , ship , "Shields ON. Autorecharge ON.");
    }
    else if ( !str_cmp(argument,"off" ) )
    {
        ship->autorecharge=FALSE;
        send_to_char( "&GYou shut down the shields.\n\r", ch);
        echo_to_cockpit( AT_YELLOW , ship , "Shields OFF. Shield strength set to 0. Autorecharge OFF.");
        ship->shield = 0;
    }
    else if ( !str_cmp(argument,"idle" ) )
    {
        ship->autorecharge=FALSE;
        send_to_char( "&GYou let the shields idle.\n\r", ch);
        echo_to_cockpit( AT_YELLOW , ship , "Autorecharge OFF. Shields IDLEING.");
    }
    else
    {
		if (ship->autorecharge == TRUE)
		{
			ship->autorecharge=FALSE;
			send_to_char( "&GYou toggle the shields.\n\r", ch);
			echo_to_cockpit( AT_YELLOW , ship , "Autorecharge OFF. Shields IDLEING.");
		}
		else
		{
			ship->autorecharge=TRUE;
			send_to_char( "&GYou toggle the shields.\n\r", ch);
			echo_to_cockpit( AT_YELLOW , ship , "Shields ON. Autorecharge ON");
		}
	}

    if (ship->autorecharge && ship->energy > 20 )
    {
       recharge  = URANGE( 1, ship->maxshield-ship->shield, 25+ship->class*25 );
       recharge  = UMIN( recharge, ship->energy*5 + 100 );
       ship->shield += recharge;
       ship->energy -= ( recharge*2 + recharge * ship->class );
    }

    learn_from_success( ch, gsn_shipsystems );
}

void do_autopilot(CHAR_DATA *ch, char *argument )
{
	SHIP_DATA *ship;
	if (  (ship = ship_from_cockpit(ch->in_room->vnum))  == NULL )
	{
		send_to_char("&RYou must be in the cockpit of a ship to do that!\n\r",ch);
		return;
	}

	if (  (ship = ship_from_pilotseat(ch->in_room->vnum))  == NULL )
	{
		send_to_char("&RYou must be in the pilots seat!\n\r",ch);
		return;
	}

	if ( !check_pilot(ch,ship) )
	{
		send_to_char("&RHey! Thats not your ship!\n\r",ch);
		return;
	}

	if ( ship->target0 || ship->target1 || ship->target2 )
	{
		send_to_char("&RNot while the ship is enganged with an enemy!\n\r",ch);
		return;
	}


    act( AT_PLAIN, "$n flips a switch on the control panel.", ch, NULL, argument , TO_ROOM );

	/*if (ship->autopilot == TRUE)*/
	if ( IS_SET( ship->flags, SHIP_AUTOPILOT ) )
	{
		ship->autopilot=FALSE;
		TOGGLE_BIT( ship->flags, SHIP_AUTOPILOT );
		send_to_char( "&GYou toggle the autopilot.\n\r", ch);
		echo_to_cockpit( AT_YELLOW , ship , "Autopilot OFF.");
	}
	else
	{
		ship->autopilot=TRUE;
		TOGGLE_BIT( ship->flags, SHIP_AUTOPILOT );
		ship->autorecharge = TRUE;
		send_to_char( "&GYou toggle the autopilot.\n\r", ch);
		echo_to_cockpit( AT_YELLOW , ship , "Autopilot ON.");
	}
}

void do_openhatch(CHAR_DATA *ch, char *argument )
{
	SHIP_DATA *ship;
	SHIP_DATA *target;
	char buf[MAX_STRING_LENGTH];
	
	if ( !argument || argument[0] == '\0' || !str_cmp(argument,"hatch") )
	{
		ship = ship_from_entrance( ch->in_room->vnum );
		if (ship && ship->shipstate == SHIP_SHIP2SHIP) 
		{
			target = ship_from_entrance( ship->docked2 );

			if ( !target ) 
			{
				send_to_char("&RYou're Not Docked!\n\r",ch);
				return;
			}

			if ( !ship->hatchopen)
			{
				if ( ship->docked2 != target->entrance ||
					( ship->shipstate != SHIP_SHIP2SHIP && ship->shipstate != SHIP_DISABLED ) )
				{
					send_to_char("&RPlease wait till the ship docks!\n\r",ch);
					return;
				}
				ship->hatchopen = TRUE;
				send_to_char("&GYou open the hatch.\n\r",ch);
				act( AT_PLAIN, "$n opens the hatch.", ch, NULL, argument, TO_ROOM );
				sprintf( buf , "The hatch on %s opens." , ship->name);
				echo_to_room( AT_YELLOW , get_room_index(ship->docked2) , buf );
				sound_to_room( get_room_index(ship->entrance) , "!!SOUND(door)" );
				sound_to_room( get_room_index(ship->docked2) , "!!SOUND(door)" );
				return;
			}
			else
			{
				send_to_char("&RIt's already open.\n\r",ch);
				return;
			}
		}
		if( ship == NULL)
		{
			send_to_char( "&ROpen what?\n\r", ch );
			return;
		}
		else
		{
			if ( !ship->hatchopen)
			{
				if  ( ship->class == SHIP_PLATFORM )
				{
					send_to_char( "&RTry one of the docking bays!\n\r" , ch );
					return;
				}
				if ( ship->location != ship->lastdoc ||
					( ship->shipstate != SHIP_DOCKED && ship->shipstate != SHIP_DISABLED ) )
				{
					send_to_char("&RPlease wait till the ship lands!\n\r",ch);
					return;
				}
				ship->hatchopen = TRUE;
				send_to_char("&GYou open the hatch.\n\r",ch);
				act( AT_PLAIN, "$n opens the hatch.", ch, NULL, argument, TO_ROOM );
				sprintf( buf , "The hatch on %s opens." , ship->name);
				echo_to_room( AT_YELLOW , get_room_index(ship->location) , buf );
				sound_to_room( get_room_index(ship->entrance) , "!!SOUND(door)" );
				sound_to_room( get_room_index(ship->location) , "!!SOUND(door)" );
				return;
			}
			else
			{
				send_to_char("&RIt's already open.\n\r",ch);
				return;
			}
		}
	}

	ship = ship_in_room( ch->in_room , argument );
	if ( !ship )
	{
		act( AT_PLAIN, "I see no $T here.", ch, NULL, argument, TO_CHAR );
		return;
	}

	if ( ship->shipstate != SHIP_DOCKED && ship->shipstate != SHIP_DISABLED )
	{
        send_to_char( "&RThat ship has already started to launch",ch);
        return;
	}

	if ( !check_pilot(ch,ship) )
	{
		send_to_char("&RHey! Thats not your ship!\n\r",ch);
		return;
	}
	
	if ( !ship->hatchopen)
	{
		ship->hatchopen = TRUE;
		act( AT_PLAIN, "You open the hatch on $T.", ch, NULL, ship->name, TO_CHAR );
		act( AT_PLAIN, "$n opens the hatch on $T.", ch, NULL, ship->name, TO_ROOM );
		echo_to_room( AT_YELLOW , get_room_index(ship->entrance) , "The hatch opens from the outside." );
		sound_to_room( get_room_index(ship->entrance) , "!!SOUND(door U=http://mercury.spaceports.com/~gavin1/)" );
		sound_to_room( get_room_index(ship->location) , "!!SOUND(door U=http://mercury.spaceports.com/~gavin1/)" );
		return;
	}

	send_to_char("&GIts already open!\n\r",ch);
}

void do_closehatch(CHAR_DATA *ch, char *argument )
{
   SHIP_DATA *ship;
   SHIP_DATA *target;
   char buf[MAX_STRING_LENGTH];

   if ( !argument || argument[0] == '\0' || !str_cmp(argument,"hatch") )
   {
       ship = ship_from_entrance( ch->in_room->vnum );
	   if (ship && ship->shipstate == SHIP_SHIP2SHIP) {
		   target = ship_from_entrance( ship->docked2 );

		   if ( !target ) {
			   send_to_char("&RYour Not Docked!\n\r",ch);
			   return;
		   }

		   if ( ship->hatchopen)
		   {
			   ship->hatchopen = FALSE;
			   send_to_char("&GYou close the hatch.\n\r",ch);
			   act( AT_PLAIN, "$n closes the hatch.", ch, NULL, argument, TO_ROOM );
			   sprintf( buf , "The hatch on %s closes." , ship->name);
			   echo_to_room( AT_YELLOW , get_room_index(ship->docked2) , buf );
			   sound_to_room( get_room_index(ship->entrance) , "!!SOUND(door)" );
			   sound_to_room( get_room_index(ship->docked2) , "!!SOUND(door)" );
			   return;
		   }
		   else
		   {
			   send_to_char("&RIt's already closed.\n\r",ch);
			   return;
		   }
	   }
       if( ship == NULL)
       {
          send_to_char( "&RClose what?\n\r", ch );
          return;
       }
       else
       {
		   if  ( ship->class == SHIP_PLATFORM )
		   {
			   send_to_char( "&RTry one of the docking bays!\n\r" , ch );
			   return;
		   }
		   if ( ship->hatchopen)
		   {
			   ship->hatchopen = FALSE;
			   send_to_char("&GYou close the hatch.\n\r",ch);
			   act( AT_PLAIN, "$n closes the hatch.", ch, NULL, argument, TO_ROOM );
			   sprintf( buf , "The hatch on %s closes." , ship->name);
			   echo_to_room( AT_YELLOW , get_room_index(ship->location) , buf );
			   sound_to_room( get_room_index(ship->entrance) , "!!SOUND(door U=http://mercury.spaceports.com/~gavin1/)" );
			   sound_to_room( get_room_index(ship->location) , "!!SOUND(door U=http://mercury.spaceports.com/~gavin1/)" );
			   return;
		   }
		   else
		   {
			   send_to_char("&RIt's already closed.\n\r",ch);
			   return;
		   }
       }
   }

   ship = ship_in_room( ch->in_room , argument );
   if ( !ship )
   {
            act( AT_PLAIN, "I see no $T here.", ch, NULL, argument, TO_CHAR );
           return;
   }

   if ( ship->shipstate != SHIP_DOCKED && ship->shipstate != SHIP_DISABLED )
   {
        send_to_char( "&RThat ship has already started to launch",ch);
        return;
   }
   else
   {
      if(ship->hatchopen)
      {
   	ship->hatchopen = FALSE;
   	act( AT_PLAIN, "You close the hatch on $T.", ch, NULL, ship->name, TO_CHAR );
   	act( AT_PLAIN, "$n closes the hatch on $T.", ch, NULL, ship->name, TO_ROOM );
        echo_to_room( AT_YELLOW , get_room_index(ship->entrance) , "The hatch is closed from outside.");
     sound_to_room( get_room_index(ship->entrance) , "!!SOUND(door U=http://mercury.spaceports.com/~gavin1/)" );
      		     sound_to_room( get_room_index(ship->location) , "!!SOUND(door U=http://mercury.spaceports.com/~gavin1/)" );

   	return;
      }
      else
      {
      	send_to_char("&RIts already closed.\n\r",ch);
      	return;
      }
   }
}

void do_status(CHAR_DATA *ch, char *argument )
{
    int chance;
    SHIP_DATA *ship;
    SHIP_DATA *target;

    if (  (ship = ship_from_cockpit(ch->in_room->vnum))  == NULL )
    {
         send_to_char("&RYou must be in the cockpit, turret or engineroom of a ship to do that!\n\r",ch);
         return;
    }

    if (argument[0] == '\0')
       target = ship;
    else
       target = get_ship_here( argument , ship->starsystem );

    if ( target == NULL )
    {
         send_to_char("&RI don't see that here.\n\rTry the radar, or type status by itself for your ships status.\n\r",ch);
         return;
    }

    if ( abs(target->vx - ship->vx) > 500+ship->sensor*2 ||
         abs(target->vy - ship->vy) > 500+ship->sensor*2 ||
         abs(target->vz - ship->vz) > 500+ship->sensor*2 )
    {
         send_to_char("&RThat ship is to far away to scan.\n\r",ch);
         return;
    }

    chance = IS_NPC(ch) ? ch->top_level
        : (int)  (ch->pcdata->learned[gsn_shipsystems]) ;
    if ( number_percent( ) > chance )
    {
        send_to_char("&RYou cant figure out what the readout means.\n\r",ch);
        learn_from_failure( ch, gsn_shipsystems );
        return;
    }

    act( AT_PLAIN, "$n checks various gages and displays on the control panel.", ch,
         NULL, argument , TO_ROOM );

	ch_printf( ch, "&W%s:\n\r", target->name);
	ch_printf( ch, "&OCurrent Coordinates:&Y %.0f %.0f %.0f\n\r",
		target->vx, target->vy, target->vz );
	ch_printf( ch, "&OCurrent Heading:&Y %.0f %.0f %.0f\n\r",
		target->hx, target->hy, target->hz );
	ch_printf( ch, "&OCurrent Speed:&Y %d&O/%d\n\r",
		target->currspeed , target->realspeed );
	ch_printf( ch, "&OHull:&Y %d&O/%d (%-3.0f\%)  Ship Condition:&Y %s\n\r",
		target->hull, target->maxhull,	percent(target->hull,target->maxhull),
		target->shipstate == SHIP_DISABLED ? "Disabled" : "Running");
	ch_printf( ch, "&OShields:&Y %d&O/%d (%-3.0f\%)  ",
		target->shield,	target->maxshield,percent(target->shield,target->maxshield));
	ch_printf( ch, "Energy(fuel):&Y %d&O/%d (%-3.0f\%)\n\r",
		target->energy, target->maxenergy, percent(target->energy,target->maxenergy));
	ch_printf( ch, "&OLaser Condition:&Y %s  &OCurrent Target:&Y %s\n\r",
		target->statet0 == LASER_DAMAGED ? "Damaged" : "Good" , target->target0 ? target->target0->name : "none");
	ch_printf( ch, "&OIon Condition:&Y %s &OCurrent Target:&Y %s\n\r",
		target->statet3 == LASER_DAMAGED ? "Damaged" : "Good" , target->target0 ? target->target0->name : "none");
	if (target->turret1)
	{
		ch_printf( ch, "&OTurret One:&Y %s  &OCurrent Target:&Y %s\n\r",
			target->statet1 == LASER_DAMAGED ? "Damaged" : "Good" , target->target1 ? target->target1->name : "none");
	}
	if (target->turret2)
	{
		ch_printf( ch, "&OTurret Two:&Y %s  &OCurrent Target:&Y %s\n\r",
			target->statet2 == LASER_DAMAGED ? "Damaged" : "Good" , target->target2 ? target->target2->name : "none\n\r");
	}
	ch_printf( ch, "&CM&cissiles&C: &W%d&C/&W%d  &CC&chaff    &C:&@ %d      &CC&condition&C:&W %s&W\n\r",
		target->missiles, target->maxmissiles, target->chaff,
		target->missilestate == MISSILE_DAMAGED ? "Damaged" : "Good");
	ch_printf( ch, "&CT&cractor &CB&ceam&C: &W%d&B  &CS&censors&C: &W%d&C\n\r",
		target->tractorbeam, target->sensor);
	ch_printf( ch, "&CC&comm&C. &CR&cating&C: &W%d&B  &CA&cstroarray&C: &W%d&B\n\r",
		target->comm, target->astro_array);
	ch_printf( ch, "&CB&combs&C: &W%d&C/&W%d &C(&W%-3.0f&C\%&C)&W\n\r",
		target->bombs,target->maxbombs,percent(target->bombs,target->maxbombs));
	if (target->hanger != 0)
		ch_printf(ch, "&OThe hanger is &Y%s\n\r", IS_SET( target->flags, SHIP_BAYOPEN ) ? "Open" : "Closed");
	if (target->allowdock)
	{
		set_char_color(AT_ORANGE,ch);
		ch_printf(ch, "Ships You have allowed to dock with you:\n\r");
		set_char_color(AT_YELLOW,ch);
		ch_printf(ch, "%s\n\r", target->allowdock);
	}
	learn_from_success( ch, gsn_shipsystems );
}
void do_hyperspace(CHAR_DATA *ch, char *argument )
{
	int chance;
    SHIP_DATA *ship;
    SHIP_DATA *eShip;
    SPACE_DATA * starsystem;
    char buf[MAX_STRING_LENGTH];

	if (  (ship = ship_from_cockpit(ch->in_room->vnum))  == NULL )
	{
		send_to_char("&RYou must be in the cockpit of a ship to do that!\n\r",ch);
		return;
	}

	if ( ship->class > SHIP_PLATFORM )
	{
		send_to_char("&RThis isn't a spacecraft!\n\r",ch);
		return;
	}

	if (  (ship = ship_from_pilotseat(ch->in_room->vnum))  == NULL )
	{
		send_to_char("&RYou aren't in the pilots seat.\n\r",ch);
		return;
	}

	if ( autofly(ship)  )
	{
		send_to_char("&RYou'll have to turn off the ships autopilot first.\n\r",ch);
		return;
	}

	if  ( ship->class == SHIP_PLATFORM )
	{
		send_to_char( "&RPlatforms can't move!\n\r" , ch );
		return;
	}

	if (ship->hyperspeed == 0)
	{
		send_to_char("&RThis ship is not equipped with a hyperdrive!\n\r",ch);
		return;
	}

	if (ship->shipstate == SHIP_HYPERSPACE)
	{
		send_to_char("&RYou are already travelling lightspeed!\n\r",ch);
		return;
	}

	if (ship->shipstate == SHIP_DISABLED)
	{
		send_to_char("&RThe ships drive is disabled. Unable to manuever.\n\r",ch);
		return;
	}

	if (ship->shipstate == SHIP_DOCKED)
	{
		send_to_char("&RYou can't do that until after you've launched!\n\r",ch);
		return;
	}

	if (ship->shipstate != SHIP_READY)
	{
		send_to_char("&G&W[&R^zWARNING&W^x]&R Ship is currently busy doing a manuever.\n\r",ch);
		return;
	}

	if (!ship->currjump)
	{
		send_to_char("&G&W[&R^zWARNING&W^x]&R You need to calculate your jump first!\n\r",ch);
		return;
	}

	if ( ship->energy < (200+ship->hyperdistance*(1+ship->class)/3))
	{
		send_to_char("&G&W[&R^zWARNING&W^x]&R Theres not enough fuel!\n\r",ch);
		return;
	}

	if ( ship->currspeed <= 0 )
	{
		send_to_char("&RYou need to speed up a little first!\n\r",ch);
		return;
	}

    	for ( eShip = ship->starsystem->first_ship; eShip; eShip = eShip->next_in_starsystem )
    	{
    	   if ( eShip == ship )
    	      continue;

    	   if ( abs( eShip->vx - ship->vx ) < 500
    	   &&  abs( eShip->vy - ship->vy ) < 500
    	   &&  abs( eShip->vz - ship->vz ) < 500 )
           {
              ch_printf(ch, "&G&W[&R^zWARNING&W^x]&R &RYou are too close to %s to make the jump to lightspeed.\n\r", eShip->name );
              return;
           }
    	}

        starsystem = ship->starsystem;
          if ( starsystem->star1 && strcmp(starsystem->star1,"") &&
                     abs(ship->vx - starsystem->s1x) < 300 &&
                     abs(ship->vy - starsystem->s1y) < 300 &&
                     abs(ship->vz - starsystem->s1z) < 300 )
                {
                    echo_to_cockpit( AT_RED, ship, "CAUTION - You are too close to a stellar object.");
                    echo_to_cockpit( AT_RED, ship, "CAUTION - Hyperjump cancelled.");
                    return;
                }
          else if ( starsystem->star2 && strcmp(starsystem->star2,"") &&
               		 abs(ship->vx - starsystem->s2x) < 300 &&
                     abs(ship->vy - starsystem->s2y) < 300 &&
                     abs(ship->vz - starsystem->s2z) < 300 )
                {
                    echo_to_cockpit( AT_RED, ship, "CAUTION - You are too close to a stellar object.");
                    echo_to_cockpit( AT_RED, ship, "CAUTION - Hyperjump cancelled.");
                    return;
                }
          else if ( starsystem->planet1 && strcmp(starsystem->planet1,"") &&
               abs(ship->vx - starsystem->p1x) < 300 &&
                     abs(ship->vy - starsystem->p1y) < 300 &&
                     abs(ship->vz - starsystem->p1z) < 300 )
                {
                    echo_to_cockpit( AT_RED, ship, "CAUTION - You are too close to a stellar object.");
                    echo_to_cockpit( AT_RED, ship, "CAUTION - Hyperjump cancelled.");
                    return;
                }
          else if ( starsystem->planet2 && strcmp(starsystem->planet2,"") &&
               abs(ship->vx - starsystem->p2x) < 300 &&
                     abs(ship->vy - starsystem->p2y) < 300 &&
                     abs(ship->vz - starsystem->p2z) < 300 )
                {
                    echo_to_cockpit( AT_RED, ship, "CAUTION - You are too close to a stellar object.");
                    echo_to_cockpit( AT_RED, ship, "CAUTION - Hyperjump cancelled.");
                    return;
                }
          else if ( starsystem->planet3 && strcmp(starsystem->planet3,"") &&
               abs(ship->vx - starsystem->p3x) < 300 &&
                     abs(ship->vy - starsystem->p3y) < 300 &&
                     abs(ship->vz - starsystem->p3z) < 300 )
                {
                    echo_to_cockpit( AT_RED, ship, "CAUTION - You are too close to a stellar object.");
                    echo_to_cockpit( AT_RED, ship, "CAUTION - Hyperjump cancelled.");
                    return;
                }
		  else if ( !hyper_allowed_FCZ(ship->vx, ship->vy, ship->vz, ship, starsystem) )
		  {
			  echo_to_cockpit( AT_RED, ship, "WARNING.. Cannot jump while within a FCZ.");
              echo_to_cockpit( AT_RED, ship, "WARNING.. Hyperjump NOT set.");
              return;
		  }

        if ( ship->class == FIGHTER_SHIP )
             chance = IS_NPC(ch) ? ch->top_level
             : (int)  (ch->pcdata->learned[gsn_starfighters]) ;
        if ( ship->class == MIDSIZE_SHIP )
             chance = IS_NPC(ch) ? ch->top_level
                 : (int)  (ch->pcdata->learned[gsn_midships]) ;
        if ( ship->class == CAPITAL_SHIP )
              chance = IS_NPC(ch) ? ch->top_level
                 : (int) (ch->pcdata->learned[gsn_capitalships]);
        if ( number_percent( ) > chance )
        {
            send_to_char("&RYou can't figure out which lever to use.\n\r",ch);
            if ( ship->class == FIGHTER_SHIP )
               learn_from_failure( ch, gsn_starfighters );
            if ( ship->class == MIDSIZE_SHIP )
               learn_from_failure( ch, gsn_midships );
            if ( ship->class == CAPITAL_SHIP )
                learn_from_failure( ch, gsn_capitalships );
    	   return;
        }
/*    sprintf( buf ,"%s disappears from your scanner." , ship->name );*/
	if ( !IS_SET(ship->flags, SHIP_MASKED) )
	{
		sprintf( buf ,"%s lurches as is streaks off at the stars and into hyperspace.", ship->name );
		echo_to_system( AT_YELLOW, ship, buf , NULL );
	}

    ship_from_starsystem( ship , ship->starsystem );
    ship->shipstate = SHIP_HYPERSPACE;

    send_to_char( "&GYou push forward the hyperspeed lever.\n\r", ch);
    act( AT_PLAIN, "$n pushes a lever forward on the control panel.", ch,
         NULL, argument , TO_ROOM );
    echo_to_ship( AT_YELLOW , ship , "The ship lurches slightly as it makes the jump to lightspeed." );
    echo_to_cockpit( AT_YELLOW , ship , "The stars become streaks of light as you enter hyperspace.");

    ship->energy -= (100+ship->hyperdistance*(1+ship->class)/3);

    ship->vx = ship->jx;
    ship->vy = ship->jy;
    ship->vz = ship->jz;

    if ( ship->class == FIGHTER_SHIP )
        learn_from_success( ch, gsn_starfighters );
    if ( ship->class == MIDSIZE_SHIP )
        learn_from_success( ch, gsn_midships );
    if ( ship->class == CAPITAL_SHIP )
        learn_from_success( ch, gsn_capitalships );
}

void do_target(CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    int chance;
    SHIP_DATA *ship;
    SHIP_DATA *target;
    char buf[MAX_STRING_LENGTH];

    strcpy( arg, argument );

    switch( ch->substate )
    {
    	default:
    	        if (  (ship = ship_from_turret(ch->in_room->vnum))  == NULL )
    	        {
    	            send_to_char("&RYou must be in the gunners seat or turret of a ship to do that!\n\r",ch);
    	            return;
    	        }

                if ( ship->class > SHIP_PLATFORM )
    	        {
    	            send_to_char("&RThis isn't a spacecraft!\n\r",ch);
    	            return;
    	        }

                if (ship->shipstate == SHIP_HYPERSPACE)
                {
                  send_to_char("&RYou can only do that in realspace!\n\r",ch);
                  return;
                }
    	        if ( !ship->starsystem )
    	        {
    	            send_to_char("&RYou can't do that until you've finished launching!\n\r",ch);
    	            return;
    	        }

                if ( autofly(ship) )
    	        {
    	            send_to_char("&RYou'll have to turn off the ships autopilot first....\n\r",ch);
    	            return;
    	        }
				if ( IS_SET(ship->flags, SHIP_MASKED) )
				{
					echo_to_cockpit( AT_RED, ship, "&R[&WShip Weapons&R] &WCannot target while masked.");
					return;
				}
                if (arg[0] == '\0')
    	        {
    	            send_to_char("&RYou need to specify a target!\n\r",ch);
    	            return;
    	        }

                if ( !str_cmp( arg, "none") )
    	        {
    	            send_to_char("&GTarget set to none.\n\r",ch);
    	            if ( ch->in_room->vnum == ship->gunseat )
    	                   ship->target0 = NULL;
    	            if ( ch->in_room->vnum == ship->turret1 )
    	                   ship->target1 = NULL;
    	            if ( ch->in_room->vnum == ship->turret2 )
    	                   ship->target2 = NULL;
    	            return;
    	        }

                target = get_ship_here( arg, ship->starsystem );
                if (  target == NULL )
                {
                    send_to_char("&RThat ship isn't here!\n\r",ch);
                    return;
                }

                if (  target == ship )
                {
                    send_to_char("&RYou can't target your own ship!\n\r",ch);
                    return;
                }

                if ( !str_cmp(target->owner, ship->owner) && str_cmp( target->owner , "" ) )
                {
                    send_to_char("&RThat ship has the same owner... try targetting an enemy ship instead!\n\r",ch);
                    return;
                }

                if ( abs(ship->vx-target->vx) > 5000 ||
                     abs(ship->vy-target->vy) > 5000 ||
                     abs(ship->vz-target->vz) > 5000 )
                {
                    send_to_char("&RThat ship is too far away to target.\n\r",ch);
                    return;
                }


                chance = IS_NPC(ch) ? ch->top_level
	                 : (int)  (ch->pcdata->learned[gsn_weaponsystems]) ;
                if ( number_percent( ) < chance )
    		{
    		   send_to_char( "&GTracking target.\n\r", ch);
    		   act( AT_PLAIN, "$n makes some adjustments on the targeting computer.", ch,
		        NULL, argument , TO_ROOM );
    		   add_timer ( ch , TIMER_DO_FUN , 1 , do_target , 1 );
    		   ch->dest_buf = str_dup(arg);
    		   return;
	        }
	        send_to_char("&RYou fail to work the controls properly.\n\r",ch);
	        learn_from_failure( ch, gsn_weaponsystems );
    	   	return;

    	case 1:
    		if ( !ch->dest_buf )
    		   return;
    		strcpy(arg, ch->dest_buf);
    		DISPOSE( ch->dest_buf);
    		break;

    	case SUB_TIMER_DO_ABORT:
    		DISPOSE( ch->dest_buf );
    		ch->substate = SUB_NONE;
    		if ( (ship = ship_from_cockpit(ch->in_room->vnum)) == NULL )
    		      return;
    	        send_to_char("&RYour concentration is broken. You fail to lock onto your target.\n\r", ch);
    		return;
    }

    ch->substate = SUB_NONE;

    if ( (ship = ship_from_turret(ch->in_room->vnum)) == NULL )
    {
       return;
    }

    target = get_ship_here( arg, ship->starsystem );
    if (  target == NULL || target == ship)
    {
           send_to_char("&RThe ship has left the starsystem. Targeting aborted.\n\r",ch);
           return;
    }

    if ( ch->in_room->vnum == ship->gunseat )
       ship->target0 = target;

    if ( ch->in_room->vnum == ship->turret1 )
       ship->target1 = target;

   if ( ch->in_room->vnum == ship->turret2 )
        ship->target2 = target;

    send_to_char( "&GTarget Locked.\n\r", ch);
/*    sprintf( buf , "You are being targetted by %s." , ship->name);
    echo_to_cockpit( AT_BLOOD , target , buf );*/
	sprintf( buf , "&G&W[&R^zBattle Stations!&R^x&W]&R The ship is being targetted by %s!" , ship->name);
	echo_to_ship( AT_BLOOD , target , buf );

    sound_to_room( ch->in_room , "!!SOUND(targetlock U=http://mercury.spaceports.com/~gavin1/)" );
    learn_from_success( ch, gsn_weaponsystems );

    if ( autofly(target) && !target->target0)
    {
		sprintf( buf , "&G&W[&R^zBattle Stations!&R^x&W]&R The ship is being targetted by %s!" , target->name);
		echo_to_ship( AT_BLOOD , ship , buf );
       target->target0 = ship;
    }
}

void do_fire(CHAR_DATA *ch, char *argument )
{
    int chance;
	int damage;
    SHIP_DATA *ship;
    SHIP_DATA *target;
    bool found;
    CHAR_DATA *tch;
    ROOM_INDEX_DATA *room;
    char buf[MAX_STRING_LENGTH];
	char temp[MAX_STRING_LENGTH];


        if (  (ship = ship_from_turret(ch->in_room->vnum))  == NULL )
        {
            send_to_char("&RYou must be in the gunners chair or turret of a ship to do that!\n\r",ch);
            return;
        }

        if ( ship->class > SHIP_PLATFORM )
    	        {
    	            send_to_char("&RThis isn't a spacecraft!\n\r",ch);
    	            return;
    	        }

        if (ship->shipstate == SHIP_HYPERSPACE)
        {
             send_to_char("&RYou can only do that in realspace!\n\r",ch);
             return;
        }
    	if (ship->starsystem == NULL)

		{
    	     send_to_char("&RYou can't do that until after you've finished launching!\n\r",ch);
    	     return;
    	}
    	if ( ship->energy <5 )
        {
             send_to_char("&RTheres not enough energy left to fire!\n\r",ch);
             return;

		}
		if ( IS_SET(ship->flags, SHIP_MASKED) )
		{
			echo_to_cockpit( AT_RED, ship, "&R[&WShip Weapons&R] &WCannot target while masked.");
			return;
		}
        if ( autofly(ship) )
		{
			send_to_char("&RYou'll have to turn off the ships autopilot first.\n\r",ch);
			return;
		}


        chance = IS_NPC(ch) ? ch->top_level
                 : (int) ( ch->perm_dex*2 + ch->pcdata->learned[gsn_spacecombat]/3
                           + ch->pcdata->learned[gsn_spacecombat2]/3 + ch->pcdata->learned[gsn_spacecombat3]/3 );

    	if ( ch->in_room->vnum == ship->gunseat && !str_prefix( argument , "lasers") )
    	{
			 switch ( number_range(1,5) )
				 {
				 default:
					 sprintf( temp, "port quarter" );
					 break;
				 case 1:
					 sprintf( temp, "starboard quarter");
					 break;
				 case 2:
					 sprintf( temp, "dorsal side of the ship");
					 break;
				 case 3:
					 sprintf( temp, "ventral side of the ship");
					 break;
				 case 4:
					 sprintf( temp, "engines");
					 break;
				 case 5:
					 sprintf( temp, "command center");
					 break;
				 }


    	     if (ship->statet0 == LASER_DAMAGED)
    	     {
    	        send_to_char("&RLasers have taken a direct hit and aren't responding!\n\r",ch);
    	      	return;
    	     }
             if (ship->statet0 >= ship->lasers )
    	     {
    	     	send_to_char("&RLasers have not fully powered up yet.\n\r",ch);
    	     	return;
    	     }
    	     if (ship->target0 == NULL )
    	     {
    	     	send_to_char("&RLasers have not been targetted at a ship.\n\r",ch);
    	     	return;
    	     }
    	     target = ship->target0;
    	     if (ship->target0->starsystem != ship->starsystem)
    	     {
    	     	send_to_char("&RThe target ship has disappeared from sensors.\n\r",ch);
    	        ship->target0 = NULL;
    	     	return;
    	     }
             if ( abs(target->vx - ship->vx) >1000 ||
                  abs(target->vy - ship->vy) >1000 ||
                  abs(target->vz - ship->vz) >1000 )
             {
                send_to_char("&RThe targetted ship is beyond the range of the main lasers.\n\r",ch);
    	     	return;
             }
             if ( ship->class < 2 && !is_facing( ship, target ) )
             {
                send_to_char("&RThe main lasers are mounted on the forward section! You need to turn the ship to face the target to fire!\n\r",ch);
    	     	return;
             }
             ship->statet0++;
             chance += target->class*25;
			 chance += ship->lasers*5;
             chance -= target->manuever/10;
             chance -= target->currspeed/20;
             chance -= ( abs(target->vx - ship->vx)/70 );
             chance -= ( abs(target->vy - ship->vy)/70 );
             chance -= ( abs(target->vz - ship->vz)/70 );
             chance = URANGE( 10 , chance , 90 );
             act( AT_PLAIN, "$n presses the fire button marked \"Main Lasers\".", ch,
                  NULL, argument , TO_ROOM );
             if ( number_percent( ) > chance )
             {
                sprintf( buf , "A blast of laserfire from %s just misses the %s." , target->name,temp);
                echo_to_cockpit( AT_ORANGE , target , buf );
                sprintf( buf , "The ship's lasers fire at %s, just missing the %s." , target->name,temp);
                echo_to_cockpit( AT_ORANGE , ship , buf );
                learn_from_failure( ch, gsn_spacecombat );
    	        learn_from_failure( ch, gsn_spacecombat2 );
    	        learn_from_failure( ch, gsn_spacecombat3 );
    	        sprintf( buf, "Laserfire from %s just misses the %s of %s." , ship->name , temp, target->name );
                echo_to_system( AT_ORANGE , ship , buf , target );
    	        return;
             }
            room = get_room_index(target->pilotseat);
            if (room != NULL && room->first_person)
			{
				for (tch=room->first_person;tch;tch=tch->next_in_room) 
				{
					found = FALSE;
					if (tch == NULL)
						break;
					if (check_pilot(tch,target) && !IS_NPC(tch)) 
					{
						found = TRUE;
						break;
					}
				}
			}
			if (found == TRUE && tch != NULL && !IS_NPC(tch))
              chance = (int)(tch->pcdata->learned[gsn_evasive]);
            else
              chance = -1;
            if (number_percent() < chance)
            {
              sprintf(buf,"You evade %s laser fire!",ship->name);
              echo_to_cockpit(AT_ORANGE, target, buf);
              sprintf(buf,"%s evades %s's laser fire!",target->name,ship->name);
              echo_to_system(AT_ORANGE, ship, buf, target);
              sprintf(buf,"%s evades your fire!",target->name);
              echo_to_cockpit(AT_ORANGE, ship, buf);
              learn_from_success(tch, gsn_evasive);
            }
            else
            {
             sprintf( buf, "%s shudders slightly as a blast of laserfire from %s hits it's %s" , ship->name, target->name , temp);
             echo_to_system( AT_ORANGE , ship , buf , target );
             sprintf( buf , "A blast of laserfire from %s hits the %s!" , ship->name,temp);
             echo_to_cockpit( AT_BLOOD , target , buf );
             sprintf( buf , "A blast of laserfire from your ship hits %s's %s!." , target->name,temp);
             echo_to_cockpit( AT_YELLOW , ship , buf );
             learn_from_success( ch, gsn_spacecombat );
             learn_from_success( ch, gsn_spacecombat2 );
             learn_from_success( ch, gsn_spacecombat3 );
             /* echo_to_ship( AT_RED , target , "A small explosion vibrates through the ship." );
             damage_ship_ch( target , 5 , 10 , ch );			Changed By Gavin 08/03/99*/
			 damage = 5;
			 damage += ship->laserdamage*5;
			 if ( damage == 5 )
				 echo_to_ship( AT_RED , target , "A small explosion vibrates through the ship." );
			 if (damage > 5 && damage <= 10 )
				 echo_to_ship( AT_RED , target , "A normal explosion vibrates through the ship." );
			if (damage > 10 && damage <= 15 )
				 echo_to_ship( AT_RED , target , "A slightly large explosion vibrates through the ship." );
			if (damage > 15 && damage <= 20 )
				 echo_to_ship( AT_RED , target , "A large explosion vibrates through the ship." );
			if (damage > 20 && damage <= 25 )
				 echo_to_ship( AT_RED , target , "A Extremly Large explosion vibrates through the ship." );
			if (damage > 25 && damage <= 30 )
				 echo_to_ship( AT_RED , target , "A Giant explosion vibrates through the ship." );
			else
				echo_to_ship( AT_RED , target , "A Giant explosion vibrates through the ship." );

			 damage_ship_ch( target , damage , damage + 5 , ch );
			 }
             if ( autofly(target) && target->target0 != ship )
             {
                target->target0 = ship;
                sprintf( buf , "Sensors indicate that %s has locked onto your ship as a target." , target->name);
                echo_to_cockpit( AT_RED , ship , buf );
             }
             return;
    	}

		if ( ch->in_room->vnum == ship->gunseat && !str_prefix( argument , "ion") )
    	{
			 switch ( number_range(1,5) )
				 {
				 default:
					 sprintf( temp, "starboard quarter" );
					 break;
				 case 1:
					 sprintf( temp, "starboard quarter");
					 break;
				 case 2:
					 sprintf( temp, "dorsal side of the ship");
					 break;
				 case 3:
					 sprintf( temp, "ventral side of the ship");
					 break;
				 case 4:
					 sprintf( temp, "engines");
					 break;
				 case 5:
					 sprintf( temp, "command center");
					 break;
				 }

    		 if (ship->ion < 1 )
    		 {
    		 	send_to_char("&RNo ion cannon system on weapons manifest.\n\r",ch);
				return;
    		 }

    	     if (ship->statet3 == LASER_DAMAGED)
    	     {
    	        send_to_char("&RThe ion cannon is damaged, unable to fire.\n\r",ch);
    	      	return;
    	     }
             if (ship->statet3 == 1 )
    	     {
    	     	send_to_char("&RIon cannons have not yet reached full power.\n\r",ch);
    	     	return;
    	     }
    	     if (ship->target0 == NULL )
    	     {
    	     	send_to_char("&RIon cannons must first be targetted.\n\r",ch);
    	     	return;
    	     }
    	     target = ship->target0;
    	     if (ship->target0->starsystem != ship->starsystem)
    	     {
    	     	send_to_char("&RSensors cannot find that ship.\n\r",ch);
    	        ship->target0 = NULL;
    	     	return;
    	     }
             if ((abs(target->vx - ship->vx) > 250 ) ||
                 (abs(target->vy - ship->vy) > 250 ) ||
                 (abs(target->vz - ship->vz) > 250 ) )
             {
                send_to_char("&RIon cannons cannot shoot that far.\n\r",ch);
    	     	return;
             }
             if ( ship->class < 2 && !is_facing( ship, target ) )
             {
                send_to_char("&RIon cannons are mounted forward, you must face the target before firing!\n\r",ch);
    	     	return;
             }
			 ship->statet3++;
			 ship->energy -= ship->ion*50;
			 if ( ship->energy < 100 )
			 {
				 ship->energy=100;
				 ship->statet3 = LASER_DAMAGED;
				 send_to_char("&RYour Ion cannons are dammaged because they ran out of energy\n\r",ch);
			 }

			 chance += target->class*25;
             chance += ship->ion;
             chance -= target->shield;
             chance -= target->manuever/10;
             chance -= target->currspeed/20;
             chance += number_range(-25, 25);
             chance -= ( abs(target->vx - ship->vx)/5 );
             chance -= ( abs(target->vy - ship->vy)/5 );
             chance -= ( abs(target->vz - ship->vz)/5 );
             chance = URANGE( 0 , chance , 100 );
             act( AT_PLAIN, "$n presses the fire button marked \"Ion Cannons\".", ch, NULL, argument , TO_ROOM );
			 act( AT_PLAIN, "You press the fire button marked \"Ion Cannons\"", ch, NULL, NULL , TO_CHAR );
             if ( number_percent( ) > chance )
			 {
				 sprintf( buf , "&BBlue bursts from the ion cannon of %s barely miss the %s." , ship->name,temp);
				 echo_to_cockpit( AT_ORANGE , target , buf );
				 sprintf( buf , "&BIon blasts from the ion cannon barely miss the %s of %s." ,temp,target->name);
				 echo_to_cockpit( AT_ORANGE , ship , buf );
				 learn_from_failure( ch, gsn_spacecombat );
				 learn_from_failure( ch, gsn_spacecombat2 );
				 learn_from_failure( ch, gsn_spacecombat3 );
				 sprintf( buf, "&BBlue ions bursts from %s barely miss the %s of %s." , ship->name , temp , target->name );
				 echo_to_system( AT_ORANGE , ship , buf , target );
				 return;
			 }
            room = get_room_index(target->pilotseat);
            if (room != NULL && room->first_person)
			{
				for (tch=room->first_person;tch;tch=tch->next_in_room) 
				{
					found = FALSE;
					if (tch == NULL)
						break;
					if (check_pilot(tch,target) && !IS_NPC(tch)) 
					{
						found = TRUE;
						break;
					}
				}
			}
			if (found == TRUE && tch != NULL && !IS_NPC(tch))
              chance = (int)(tch->pcdata->learned[gsn_evasive]);
            else
              chance = -1;
            if (number_percent() < chance)
            {
              sprintf(buf,"You evade %s laser fire!",ship->name);
              echo_to_cockpit(AT_ORANGE, target, buf);
              sprintf(buf,"%s evades %s's laser fire!",target->name,ship->name);
              echo_to_system(AT_ORANGE, ship, buf, target);
              sprintf(buf,"%s evades your fire!",target->name);
              echo_to_cockpit(AT_ORANGE, ship, buf);
              learn_from_success(tch, gsn_evasive);
            }
            else
            {
				sprintf( buf, "&BBlue ions bursts from %s explode as they hit the %s of %s." , ship->name, temp, target->name );
				echo_to_system( AT_ORANGE , ship , buf , target );
				sprintf( buf , "&BThe lights flicker slightly as the %s is hit by ion bursts from %s!" , temp, ship->name);
				echo_to_cockpit( AT_BLOOD , target , buf );
				sprintf( buf , "&BYour ion blasts explode as they score a direct hit on the %s of %s!", temp , target->name);
				echo_to_cockpit( AT_YELLOW , ship , buf );
				learn_from_success( ch, gsn_spacecombat );
				learn_from_success( ch, gsn_spacecombat2 );
				learn_from_success( ch, gsn_spacecombat3 );
			}
			chance -= target->shield;
			chance += number_range( 1, 100);
			chance -= number_range( 1, 100);
			chance = URANGE( 0 , chance , 100 );
			if ( ( chance > 90 ) && target->shipstate != SHIP_DISABLED )
			{
				echo_to_cockpit( AT_RED , target , "&G&W[&R^zDamage Report&W^x]:&R The main drive has sustained a direct hit and has stopped responding!" );
				sprintf( buf , "G&W[&R^zSensor Report&W^x]:&R Our ion cannons have scored a direct hit on %s's drive! Target disabled!", target->name);
				echo_to_room( AT_BLOOD , get_room_index(ship->gunseat) , buf );
				target->shipstate = SHIP_DISABLED;
				return;
			}
			 chance -= target->shield;
			 chance += number_range( 1, 100);
			 chance -= number_range( 1, 100);
			 chance = URANGE( 0 , chance , 100 );
			 if ( ( number_range(1, 100) <= 90 ) && target->missilestate != MISSILE_DAMAGED && target->maxmissiles > 0 )
			 {
				 echo_to_room( AT_BLOOD , get_room_index(target->gunseat) , "&G&W[&R^zDamage Report&W^x]:&R The warhead launchers have sustained a direct hit and have stopped responding!" );
				 sprintf( buf , "&G&W[&R^zOperations Report&W^x]:&R %s's warhead launchers have been hit and are no longer functioning!'", target->name);
				 echo_to_room( AT_BLOOD , get_room_index(ship->gunseat) , buf);
				 target->missilestate = MISSILE_DAMAGED;
				 return;
			 }
			 chance -= target->shield;
			 chance += number_range( 1, 100);
			 chance -= number_range( 1, 100);
			 chance = URANGE( 0 , chance , 100 );
        if ( ( number_range(1, 100) <= 93 ) && target->statet1 != LASER_DAMAGED && target->turret1 )
        {
           echo_to_room( AT_BLOOD + AT_BLINK , get_room_index(target->turret1) , "Turret DISABLED!" );
           echo_to_room( AT_BLOOD + AT_BLINK , get_room_index(ship->gunseat) , "Targets turret 1 disabled." );
           target->statet1 = LASER_DAMAGED;
           return;
        }
			 chance -= target->shield;
			 chance += number_range( 1, 100);
			 chance -= number_range( 1, 100);
			 chance = URANGE( 0 , chance , 100 );
        if ( ( number_range(1, 100) <= 93 ) && target->statet2 != LASER_DAMAGED && target->turret2 )
        {
           echo_to_room( AT_BLOOD + AT_BLINK , get_room_index(target->turret2) , "Turret DISABLED!" );
           echo_to_room( AT_BLOOD + AT_BLINK , get_room_index(ship->gunseat) , "Targets turret 2 disabled." );
           target->statet2 = LASER_DAMAGED;
           return;
        }

			 chance -= target->shield;
			 chance += number_range( 1, 100);
			 chance -= number_range( 1, 100);
			 chance = URANGE( 0 , chance , 100 );
        if ( ( number_range(1, 100) <= 93 ) && target->statet0 != LASER_DAMAGED && target->lasers > 0 )
        {
		   echo_to_room( AT_BLOOD + AT_BLINK , get_room_index(target->gunseat) , "Lasers DISABLED!" );
		   echo_to_room( AT_BLOOD + AT_BLINK , get_room_index(ship->gunseat) , "Targets lasers disabled." );
		   target->statet0 = LASER_DAMAGED;
		   return;
		}

			 chance -= target->shield;
			 chance += number_range( 1, 100);
			 chance -= number_range( 1, 100);
			 chance = URANGE( 0 , chance , 100 );
        if ( ( number_range(1, 100) <= 90 ) && target->statet3 != LASER_DAMAGED && target->ion > 0 )
        {
		   echo_to_room( AT_BLOOD + AT_BLINK , get_room_index(target->gunseat) , "Ion cannon DISABLED!" );
		   echo_to_room( AT_BLOOD + AT_BLINK , get_room_index(ship->gunseat) , "Targets ion cannons disabled." );
		   target->statet3 = LASER_DAMAGED;
		   return;
		}

		else
		{
		   sprintf( buf , "Ion blast from %s has no affect." , ship->name);
       	   echo_to_room( AT_ORANGE , get_room_index(target->gunseat) , buf );
		   echo_to_room( AT_BLOOD + AT_BLINK , get_room_index(ship->gunseat) , "It had no affect" );
		   return;
    }

	if ( autofly(target) && target->target0 != ship )
             {
                target->target0 = ship;
                sprintf( buf , "You are being targetted by %s." , target->name);
                echo_to_cockpit( AT_BLOOD , ship , buf );
             }

             return;
    }

        if ( ch->in_room->vnum == ship->gunseat && !str_prefix( argument , "missile") )
    	{
    	     if (ship->missilestate == MISSILE_DAMAGED)
    	     {
    	        send_to_char("&RThe ship's warhead launchers are damaged.\n\r",ch);
    	      	return;
	   	     }
             if (ship->missiles <= 0)
    	     {
    	     	send_to_char("&RReadouts indicate that all missiles have been launched.\n\r",ch);
    	        return;
    	     }
    	     if (ship->missilestate != MISSILE_READY )
    	     {
    	     	send_to_char("&RWarhead launchers have not completed reload cycle - for all 3\n\r",ch);
    	     	return;
    	     }
    	     if (ship->target0 == NULL )
    	     {
    	     	send_to_char("&RNo target selected - Unable to lock on warhead.\n\r",ch);
    	     	return;
    	     }
    	     target = ship->target0;
             if (ship->target0->starsystem != ship->starsystem)
    	     {
    	     	send_to_char("&RTarget does not appear on sensors - unable to fire.\n\r",ch);
    	        ship->target0 = NULL;
    	     	return;
    	     }
             if ( abs(target->vx - ship->vx) >1000 ||
                  abs(target->vy - ship->vy) >1000 ||
                  abs(target->vz - ship->vz) >1000 )
             {
                send_to_char("&RMissiles would run out of fuel before reaching target...firing order cancelled.\n\r",ch);
    	     	return;
             }
             if ( ship->class < 2 && !is_facing( ship, target ) )
             {
                send_to_char("&RWarhead launchers are locked forward...ship must face target before firing\n\r",ch);
    	     	return;
             }
             chance -= target->manuever/5;
             chance -= target->currspeed/20;
             chance += target->class*target->class*25;
             chance -= ( abs(target->vx - ship->vx)/100 );
             chance -= ( abs(target->vy - ship->vy)/100 );
             chance -= ( abs(target->vz - ship->vz)/100 );
             chance += ( 30 );
             chance = URANGE( 20 , chance , 80 );
             act( AT_PLAIN, "$n presses the missile fire control button.", ch,
                  NULL, argument , TO_ROOM );
             if ( number_percent( ) > chance )
             {
                send_to_char( "&RTarget has evaded missile lock!", ch );
                ship->missilestate = MISSILE_RELOAD_2;
    	        return;
             }
			 act( AT_PLAIN, "You press the missile fire control button.", ch,
                  NULL, argument , TO_ROOM );
             new_missile( ship , target , ch , CONCUSSION_MISSILE );
             ship->missiles--;
			 sprintf( buf , "You watch as a missile streaks off towards %s.",target->name);
             echo_to_cockpit( AT_YELLOW , ship , "Missiles launched.");
             sprintf( buf , "&G&W[&R^zALERT!&R^x&W]&R Sensors report missile approaching from %s!" , ship->name);
             echo_to_cockpit( AT_BLOOD , target , buf );
             sprintf( buf, "&RSensors report that %s has fired a missile at %s." , ship->name, target->name );
             echo_to_system( AT_ORANGE , ship , buf , target );
             learn_from_success( ch, gsn_weaponsystems );
             if ( ship->class == CAPITAL_SHIP || ship->class == SHIP_PLATFORM )
                   ship->missilestate = MISSILE_RELOAD;
             else
                   ship->missilestate = MISSILE_FIRED;

             if ( autofly(target) && target->target0 != ship )
             {
                target->target0 = ship;
                sprintf( buf , "Sensors indicate that %s has locked onto your ship as a target." , target->name);
                echo_to_cockpit( AT_RED , ship , buf );
             }
             return;
    	}
        if ( ch->in_room->vnum == ship->turret1 && !str_prefix( argument , "lasers") )
    	{
    	     if (ship->statet1 == LASER_DAMAGED)
    	     {
    	        send_to_char("&RTurret #1 Damaged - Unable to fire!\n\r",ch);
    	      	return;
    	     }
             if (ship->statet1 > ship->class )
    	     {
    	     	send_to_char("&RThe turbolaser has not fully recharged.\n\r",ch);
    	     	return;
    	     }
    	     if (ship->target1 == NULL )
    	     {
    	     	send_to_char("&RNo target selected - unable to fire.\n\r",ch);
    	     	return;
    	     }
    	     target = ship->target1;
             if (ship->target1->starsystem != ship->starsystem)
    	     {
    	     	send_to_char("&RNo such ship targetted.\n\r",ch);
    	        ship->target1 = NULL;
    	     	return;
    	     }
             if ( abs(target->vx - ship->vx) >1000 ||
                  abs(target->vy - ship->vy) >1000 ||
                  abs(target->vz - ship->vz) >1000 )
             {
                send_to_char("&RThat ship is beyond the range of the ship's main lasers.\n\r",ch);
    	     	return;
            }
             ship->statet1++;
             chance -= target->manuever/10;
             chance += target->class*25;
             chance -= target->currspeed/20;
             chance -= ( abs(target->vx - ship->vx)/70 );
             chance -= ( abs(target->vy - ship->vy)/70 );
             chance -= ( abs(target->vz - ship->vz)/70 );
             chance = URANGE( 10 , chance , 90 );
             act( AT_PLAIN, "$n presses the button marked \"Fire\"", ch,
                  NULL, argument , TO_ROOM );
			 act( AT_PLAIN, "You press the button marked \"Fire\"", ch,
                  NULL, argument , TO_ROOM );
			 				 switch ( number_range(1,5) )
				 {
				 default:
					 sprintf( temp, "starboard quarter" );
					 break;
				 case 1:
					 sprintf( temp, "starboard quarter");
					 break;
				 case 2:
					 sprintf( temp, "dorsal side of the side");
					 break;
				 case 3:
					 sprintf( temp, "ventral side of the side");
					 break;
				 case 4:
					 sprintf( temp, "engines");
					 break;
				 case 5:
					 sprintf( temp, "command center");
					 break;
				 }

             if ( number_percent( ) > chance )
             {
                sprintf( buf , "A huge volley of turbolaser fire from %s's #1 turret just misses your %s." , ship->name, temp);
                echo_to_cockpit( AT_ORANGE , target , buf );
                sprintf( buf , "A blast of turbolaser fire from Turret #1 just misses %s's %s" , target->name, temp);
                echo_to_cockpit( AT_ORANGE , ship , buf );
                sprintf( buf, "A blast of turbolaser fire from %s's #1 turret just misses the %s on %s" , ship->name, temp, target->name );
                echo_to_system( AT_ORANGE , ship , buf , target );
                learn_from_failure( ch, gsn_spacecombat );
    	        learn_from_failure( ch, gsn_spacecombat2 );
    	        learn_from_failure( ch, gsn_spacecombat3 );
    	        return;
             }
            room = get_room_index(target->pilotseat);
            if (room != NULL && room->first_person)
			{
				for (tch=room->first_person;tch;tch=tch->next_in_room) 
				{
					found = FALSE;
					if (tch == NULL)
						break;
					if (check_pilot(tch,target) && !IS_NPC(tch)) 
					{
						found = TRUE;
						break;
					}
				}
			}
			if (found == TRUE && tch != NULL && !IS_NPC(tch))
              chance = (int)(tch->pcdata->learned[gsn_evasive]);
            else
              chance = -1;
            if (number_percent() < chance)
            {
              sprintf(buf,"You evade %s laser fire!",ship->name);
              echo_to_cockpit(AT_ORANGE, target, buf);
              sprintf(buf,"%s evades %s's laser fire!",target->name,ship->name);
              echo_to_system(AT_ORANGE, ship, buf, target);
              sprintf(buf,"%s evades your fire!",target->name);
              echo_to_cockpit(AT_ORANGE, ship, buf);
              learn_from_success(tch, gsn_evasive);
            }
            else
            {
             sprintf( buf, "A blast of turbolaser fire from %s's #1 turret scores a direct hit on %s's %s!" , ship->name, target->name , temp);
             echo_to_system( AT_ORANGE , ship , buf , target );
             sprintf( buf , "You are nearly knocked off your feet as the ship shudders under a direct hit on the %s from %s's #1 turret" , temp, ship->name);
             echo_to_cockpit( AT_BLOOD , target , buf );
             sprintf( buf , "A blast of turbolaser fire from turret #1 scores a direct hit on %s's %s" , target->name,temp);
             echo_to_cockpit( AT_YELLOW , ship , buf );
             learn_from_success( ch, gsn_spacecombat );
             learn_from_success( ch, gsn_spacecombat2 );
             learn_from_success( ch, gsn_spacecombat3 );
             /* echo_to_ship( AT_RED , target , "A small explosion vibrates through the ship." );
             damage_ship_ch( target , 10 , 25 , ch ); GAVIN */
	 		 damage = 5;
			 damage += ship->lasers*5;
			 if ( damage == 5 )
				 echo_to_ship( AT_RED , target , "A small explosion vibrates through the ship." );
			 if (damage > 5 && damage <= 10 )
				 echo_to_ship( AT_RED , target , "A normal explosion vibrates through the ship." );
			if (damage > 10 && damage <= 15 )
			 echo_to_ship( AT_RED , target , "A slightly large explosion vibrates through the ship." );
			if (damage > 15 && damage <= 20 )
				 echo_to_ship( AT_RED , target , "A large explosion vibrates through the ship." );
			if (damage > 20 && damage <= 25 )
				 echo_to_ship( AT_RED , target , "A Extremly Large explosion vibrates through the ship." );
			if (damage > 25 && damage <= 30 )
				 echo_to_ship( AT_RED , target , "A Giant explosion vibrates through the ship." );
			else
				echo_to_ship( AT_RED , target , "A Giant explosion vibrates through the ship." );

			 damage_ship_ch( target , damage , damage + 5 , ch );
				}

             if ( autofly(target) && target->target0 != ship )
             {
                target->target0 = ship;
				sprintf( buf , "&G&W[&R^zBattle Stations!&R^x&W]&R The ship is being targetted by %s!" , target->name);
                echo_to_ship( AT_BLOOD , ship , buf );             }

             return;
    	}
        if ( ch->in_room->vnum == ship->turret2 && !str_prefix( argument , "lasers") )
    	{
    	     if (ship->statet2 == LASER_DAMAGED)
    	     {
    	        send_to_char("&RTurret #2 Damaged - Unable to fire!\n\r",ch);
    	      	return;
    	     }
             if (ship->statet2 > ship->class )
    	     {
    	     	send_to_char("&RThe turbolaser has not fully recharged.\n\r",ch);
    	     	return;
    	     }
    	     if (ship->target2 == NULL )
    	     {
    	     	send_to_char("&RNo target selected - unable to fire.\n\r",ch);
    	     	return;
    	     }
    	     target = ship->target2;
             if (ship->target2->starsystem != ship->starsystem)
    	     {
    	     	send_to_char("&RYour target seems to have left.\n\r",ch);
    	        ship->target2 = NULL;
    	     	return;
    	     }
    	     if ( abs(target->vx - ship->vx) >1000 ||
                  abs(target->vy - ship->vy) >1000 ||
                  abs(target->vz - ship->vz) >1000 )
             {
                send_to_char("&RNo such ship targetted.\n\r",ch);
    	     	return;
             }
             ship->statet2++;
             chance -= target->manuever/10;
             chance += target->class*25;
             chance -= target->currspeed/20;
             chance -= ( abs(target->vx - ship->vx)/70 );
             chance -= ( abs(target->vy - ship->vy)/70 );
             chance -= ( abs(target->vz - ship->vz)/70 );
             chance = URANGE( 10 , chance , 90 );
             act( AT_RED, "$n presses the button marked \"Fire\"", ch,
                  NULL, argument , TO_ROOM );
			 act( AT_RED, "You press the button marked \"Fire\"", ch,
                  NULL, argument , TO_ROOM );
			 				 switch ( number_range(1,5) )
				 {
				 default:
					 sprintf( temp, "starboard quarter" );
					 break;
				 case 1:
					 sprintf( temp, "starboard quarter");
					 break;
				 case 2:
					 sprintf( temp, "dorsal side of the side");
					 break;
				 case 3:
					 sprintf( temp, "ventral side of the side");
					 break;
				 case 4:
					 sprintf( temp, "engines");
					 break;
				 case 5:
					 sprintf( temp, "command center");
					 break;
				 }

             if ( number_percent( ) > chance )
             {
                sprintf( buf , "A huge volley of turbolaser fire from %s's #2 turret just misses your %s." , ship->name, temp);
                echo_to_cockpit( AT_ORANGE , target , buf );
                sprintf( buf , "A blast of turbolaser fire from Turret #2 just misses %s's %s" , target->name, temp);
                echo_to_cockpit( AT_ORANGE , ship , buf );
                sprintf( buf, "A blast of turbolaser fire from %s's #2 turret just misses the %s on %s" , ship->name, temp, target->name );
                echo_to_system( AT_ORANGE , ship , buf , target );
                learn_from_failure( ch, gsn_spacecombat );
    	        learn_from_failure( ch, gsn_spacecombat2 );
    	        learn_from_failure( ch, gsn_spacecombat3 );
    	        return;
             }
            room = get_room_index(target->pilotseat);
            if (room != NULL && room->first_person)
			{
				for (tch=room->first_person;tch;tch=tch->next_in_room) 
				{
					found = FALSE;
					if (tch == NULL)
						break;
					if (check_pilot(tch,target) && !IS_NPC(tch)) 
					{
						found = TRUE;
						break;
					}
				}
			}
			if (found == TRUE && tch != NULL && !IS_NPC(tch))
              chance = (int)(tch->pcdata->learned[gsn_evasive]);
            else
              chance = -1;
			if (number_percent() < chance)
            {
              sprintf(buf,"You evade %s laser fire!",ship->name);
              echo_to_cockpit(AT_ORANGE, target, buf);
              sprintf(buf,"%s evades %s's laser fire!",target->name,ship->name);
              echo_to_system(AT_ORANGE, ship, buf, target);
              sprintf(buf,"%s evades your fire!",target->name);
              echo_to_cockpit(AT_ORANGE, ship, buf);
              learn_from_success(tch, gsn_evasive);
            }
            else
            {
             sprintf( buf, "A blast of turbolaser fire from %s's #2 turret scores a direct hit on %s's %s!" , ship->name, target->name , temp);
             echo_to_system( AT_ORANGE , ship , buf , target );
             sprintf( buf , "You are nearly knocked off your feet as the ship shudders under a direct hit on the %s from %s's #2 turret" , temp, ship->name);
             echo_to_cockpit( AT_BLOOD , target , buf );
             sprintf( buf , "A blast of turbolaser fire from turret #2 scores a direct hit on %s's %s" , target->name,temp);
             echo_to_cockpit( AT_YELLOW , ship , buf );
             learn_from_success( ch, gsn_spacecombat );
             learn_from_success( ch, gsn_spacecombat2 );
             learn_from_success( ch, gsn_spacecombat3 );
/*             echo_to_ship( AT_RED , target , "A small explosion vibrates through the ship." );
             damage_ship_ch( target , 10 , 25 , ch); GAVIN */
			 		 damage = 5;
			 damage += ship->lasers*5;
			 if ( damage == 5 )
				 echo_to_ship( AT_RED , target , "A small explosion vibrates through the ship." );
			 if (damage > 5 && damage <= 10 )
				 echo_to_ship( AT_RED , target , "A normal explosion vibrates through the ship." );
			if (damage > 10 && damage <= 15 )
				 echo_to_ship( AT_RED , target , "A slightly large explosion vibrates through the ship." );
			if (damage > 15 && damage <= 20 )
				 echo_to_ship( AT_RED , target , "A large explosion vibrates through the ship." );
			if (damage > 20 && damage <= 25 )
				 echo_to_ship( AT_RED , target , "A Extremly Large explosion vibrates through the ship." );
			if (damage > 25 && damage <= 30 )
				 echo_to_ship( AT_RED , target , "A Giant explosion vibrates through the ship." );

			damage_ship_ch( target , damage , damage + 5 , ch );
			}
            if ( autofly(target) && target->target0 != ship )
             {
                target->target0 = ship;
                sprintf( buf , "&G&W[&R^zBattle Stations!&R^x&W]&R The ship is being targetted by %s!" , target->name);
                echo_to_ship( AT_BLOOD , ship , buf );
             }
             return;
    	}

        send_to_char( "&RYou can't fire that!\n\r" , ch);

}

void do_calculate(CHAR_DATA *ch, char *argument )
{
    char arg1[MAX_INPUT_LENGTH];
    char arg2[MAX_INPUT_LENGTH];
    char arg3[MAX_INPUT_LENGTH];
    int chance , count;
    SHIP_DATA *ship;
    SPACE_DATA *starsystem;

    argument = one_argument( argument , arg1);
    argument = one_argument( argument , arg2);
    argument = one_argument( argument , arg3);

	if (  (ship = ship_from_cockpit(ch->in_room->vnum))  == NULL )
	{
		send_to_char("&RYou must be in the cockpit of a ship to do that!\n\r",ch);
		return;
	}
	
	if ( ship->class > SHIP_PLATFORM )
	{
		send_to_char("&RThis isn't a spacecraft!\n\r",ch);
		return;
	}
	if (  (ship = ship_from_navseat(ch->in_room->vnum))  == NULL )
	{
		send_to_char("&RYou must be at a nav computer to calculate jumps.\n\r",ch);
		return;
	}
	
	if ( autofly(ship)  )
	{
		send_to_char("&RYou'll have to turn off the ships autopilot first....\n\r",ch);
		return;
	}
	
	if  ( ship->class == SHIP_PLATFORM )
	{
		send_to_char( "&RAnd what exactly are you going to calculate...?\n\r" , ch );
		return;
	}
	
	if (ship->hyperspeed == 0)
	{
		send_to_char("&RThis ship is not equipped with a hyperdrive!\n\r",ch);
		return;
	}
	
	if (ship->shipstate == SHIP_DOCKED)
	{
		send_to_char("&RYou can't do that until after you've launched!\n\r",ch);
		return;
	}
	
	if (ship->starsystem == NULL)
	{
		send_to_char("&RYou can only do that in realspace.\n\r",ch);
		return;
	}
	
	if (argument[0] == '\0')
	{
		send_to_char("&WFormat: Calculate <starsystem> <entry x> <entry y> <entry z>\n\r&wPossible destinations:\n\r",ch);
		for ( starsystem = first_starsystem; starsystem; starsystem = starsystem->next )
		{
			if ( !IS_SET(starsystem->flags,SYSTEM_SECRET) )
			{
				set_char_color( AT_NOTE, ch );
				ch_printf(ch,"%-30s %d\n\r",starsystem->name,
					(abs(starsystem->xpos - ship->starsystem->xpos)+
					abs(starsystem->ypos - ship->starsystem->ypos))/2);
				count++;
			}
		}
		if ( !count )
		{
			send_to_char( "No Starsystems found.\n\r", ch );
		}
		return;
	}
	chance = IS_NPC(ch) ? ch->top_level
		: (int)  (ch->pcdata->learned[gsn_navigation]) ;
	if ( number_percent( ) > chance )
	{
		send_to_char("&RYou cant seem to figure the charts out today.\n\r",ch);
		learn_from_failure( ch, gsn_navigation );
		return;
	}
	
	ship->currjump = starsystem_from_name( arg1 );
	ship->jx = atoi(arg2);
	ship->jy = atoi(arg3);
    ship->jz = atoi(argument);

    if ( ship->currjump == NULL )
    {
        send_to_char( "&RYou can't seem to find that starsytem on your charts.\n\r", ch);
        return;
    }
    else
    {
        SPACE_DATA * starsystem;
        starsystem = ship->currjump;
          if ( starsystem->star1 && strcmp(starsystem->star1,"") &&
                     abs(ship->jx - starsystem->s1x) < 300 &&
                     abs(ship->jy - starsystem->s1y) < 300 &&
                     abs(ship->jz - starsystem->s1z) < 300 )
                {
                    echo_to_cockpit( AT_RED, ship, "WARNING.. Jump coordinates too close to stellar object.");
                    echo_to_cockpit( AT_RED, ship, "WARNING.. Hyperjump NOT set.");
                    ship->currjump = NULL;
                    return;
                }
          else if ( starsystem->star2 && strcmp(starsystem->star2,"") &&
               abs(ship->jx - starsystem->s2x) < 300 &&
                     abs(ship->jy - starsystem->s2y) < 300 &&
                     abs(ship->jz - starsystem->s2z) < 300 )
                {
                    echo_to_cockpit( AT_RED, ship, "WARNING.. Jump coordinates too close to stellar object.");
                    echo_to_cockpit( AT_RED, ship, "WARNING.. Hyperjump NOT set.");
                    ship->currjump = NULL;
                    return;
                }
          else if ( starsystem->planet1 && strcmp(starsystem->planet1,"") &&
               abs(ship->jx - starsystem->p1x) < 300 &&
                     abs(ship->jy - starsystem->p1y) < 300 &&
                     abs(ship->jz - starsystem->p1z) < 300 )
                {
                    echo_to_cockpit( AT_RED, ship, "WARNING.. Jump coordinates too close to stellar object.");
                    echo_to_cockpit( AT_RED, ship, "WARNING.. Hyperjump NOT set.");
                    ship->currjump = NULL;
                    return;
                }
          else if ( starsystem->planet2 && strcmp(starsystem->planet2,"") &&
               abs(ship->jx - starsystem->p2x) < 300 &&
                     abs(ship->jy - starsystem->p2y) < 300 &&
                     abs(ship->jz - starsystem->p2z) < 300 )
                {
                    echo_to_cockpit( AT_RED, ship, "WARNING.. Jump coordinates too close to stellar object.");
                    echo_to_cockpit( AT_RED, ship, "WARNING.. Hyperjump NOT set.");
                    ship->currjump = NULL;
                    return;
                }
          else if ( starsystem->planet3 && strcmp(starsystem->planet3,"") &&
               abs(ship->jx - starsystem->p3x) < 300 &&
                     abs(ship->jy - starsystem->p3y) < 300 &&
                     abs(ship->jz - starsystem->p3z) < 300 )
                {
                    echo_to_cockpit( AT_RED, ship, "WARNING.. Jump coordinates too close to stellar object.");
                    echo_to_cockpit( AT_RED, ship, "WARNING.. Hyperjump NOT set.");
                    ship->currjump = NULL;
                    return;
                }
		  else if ( !hyper_allowed_FCZ(ship->jx, ship->jy, ship->jz, ship, starsystem) )
		  {
			  echo_to_cockpit( AT_RED, ship, "WARNING.. Cannot jump into a FCZ.");
              echo_to_cockpit( AT_RED, ship, "WARNING.. Hyperjump NOT set.");
              ship->currjump = NULL;
              return;
		  }
          else
          {
           chance += number_range ( -255 , 255 );
           	if ( chance > 0 )
           	 chance -= ship->astro_array;
           	if (chance < 0 )
           	 chance += ship->astro_array;
           ship->jx += chance;
           ship->jx += number_range ( -100 , 100 );
           ship->jy += chance;
           ship->jy += number_range ( -100 , 100 );
           ship->jz += chance;
           ship->jz += number_range ( -100 , 100 );
          }
    }

    ship->hyperdistance  = abs(ship->starsystem->xpos - ship->currjump->xpos) ;
    ship->hyperdistance += abs(ship->starsystem->ypos - ship->currjump->ypos) ;
    ship->hyperdistance /= 5;

    if (ship->hyperdistance<100)
      ship->hyperdistance = 100;

    ship->hyperdistance += number_range(0, 200);
    sound_to_room( ch->in_room , "!!SOUND(computer U=http://mercury.spaceports.com/~gavin1/)" );
    send_to_char( "&GHyperspace course set. Ready for the jump to lightspeed.\n\r", ch);
    act( AT_PLAIN, "$n does some calculations using the ships computer.", ch,
		        NULL, argument , TO_ROOM );
    learn_from_success( ch, gsn_navigation );

    WAIT_STATE( ch , 2*PULSE_VIOLENCE );
}

void do_recharge(CHAR_DATA *ch, char *argument )
{
    int recharge;
    int chance;
    SHIP_DATA *ship;


        if (  (ship = ship_from_cockpit(ch->in_room->vnum))  == NULL )
        {
            send_to_char("&RYou must be in the cockpit of a ship to do that!\n\r",ch);
            return;
        }
        if (  (ship = ship_from_coseat(ch->in_room->vnum))  == NULL )
        {
            send_to_char("&RThe controls must be at the co-pilot station.\n\r",ch);
            return;
        }
                if ( autofly(ship)  )
    	        {
    	            send_to_char("&R...\n\r",ch);
    	            return;
    	        }

                if (ship->shipstate == SHIP_DISABLED)
    	        {
    	            send_to_char("&RThe ships drive is disabled. Unable to manuever.\n\r",ch);
    	            return;
    	        }

        if ( ship->energy < 100 )
        {
              send_to_char("&RTheres not enough energy!\n\r",ch);
              return;
        }

        chance = IS_NPC(ch) ? ch->top_level
                 : (int) (ch->pcdata->learned[gsn_shipsystems]);
        if ( number_percent( ) > chance )
        {
            send_to_char("&RYou fail to work the controls properly.\n\r",ch);
            learn_from_failure( ch, gsn_shipsystems );
    	   return;
        }

    send_to_char( "&GRecharging shields..\n\r", ch);
    act( AT_PLAIN, "$n pulls back a lever on the control panel.", ch,
         NULL, argument , TO_ROOM );

    learn_from_success( ch, gsn_shipsystems );

    recharge  = UMIN(  ship->maxshield-ship->shield , ship->energy*5 + 100 );
    recharge  = URANGE( 1, recharge , 25+ship->class*25 );
    ship->shield += recharge;
    ship->energy -= ( recharge*2 + recharge * ship->class );
}

#if 0
void do_repairship(CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    int chance, change;
    SHIP_DATA *ship;

    strcpy( arg, argument );

    switch( ch->substate )
    {
    	default:
    	        if (  (ship = ship_from_engine(ch->in_room->vnum))  == NULL )
    	        {
    	            send_to_char("&RYou must be in the engine room of a ship to do that!\n\r",ch);
    	            return;
    	        }

                if ( str_cmp( argument , "hull" ) && str_cmp( argument , "drive" ) &&
                     str_cmp( argument , "launcher" ) && str_cmp( argument , "laser" ) &&
                     str_cmp( argument , "turret 1" ) && str_cmp( argument , "turret 2") &&
                     str_cmp( argument , "ions") )
                {
                   send_to_char("&RYou need to spceify something to repair:\n\r",ch);
                   send_to_char("&rTry: hull, drive, launcher, laser, turret 1, ions, or turret 2\n\r",ch);
                   return;
                }

                chance = IS_NPC(ch) ? ch->top_level
	                 : (int) (ch->pcdata->learned[gsn_shipmaintenance]);
                if ( number_percent( ) < chance )
    		{
    		   send_to_char( "&GYou begin your repairs\n\r", ch);
    		   act( AT_PLAIN, "$n begins repairing the ships $T.", ch,
		        NULL, argument , TO_ROOM );
    		   if ( !str_cmp(arg,"hull") )
    		     add_timer ( ch , TIMER_DO_FUN , 15 , do_repairship , 1 );
    		   else
    		     add_timer ( ch , TIMER_DO_FUN , 5 , do_repairship , 1 );
    		   ch->dest_buf = str_dup(arg);
    		   return;
	        }
	        send_to_char("&RYou fail to locate the source of the problem.\n\r",ch);
	        learn_from_failure( ch, gsn_shipmaintenance );
    	   	return;

    	case 1:
    		if ( !ch->dest_buf )
    		   return;
    		strcpy(arg, ch->dest_buf);
    		DISPOSE( ch->dest_buf);
    		break;

    	case SUB_TIMER_DO_ABORT:
    		DISPOSE( ch->dest_buf );
    		ch->substate = SUB_NONE;
    		if ( (ship = ship_from_cockpit(ch->in_room->vnum)) == NULL )
    		      return;
    	        send_to_char("&RYou are distracted and fail to finish your repairs.\n\r", ch);
    		return;
    }

    ch->substate = SUB_NONE;

    if ( (ship = ship_from_engine(ch->in_room->vnum)) == NULL )
    {
      return;
    }

    if ( !str_cmp(arg,"hull") )
    {
        change = URANGE( 0 ,
                         number_range( (int) ( ch->pcdata->learned[gsn_shipmaintenance] / 2 ) , (int) (ch->pcdata->learned[gsn_shipmaintenance]) ),
                         ( ship->maxhull - ship->hull ) );
        ship->hull += change;
/*        ch_printf( ch, "&GRepair complete.. Hull strength inreased by %d points.\n\r", change );*/
		ch_printf( ch, "&GRepair complete.  Hull integrity is now %-3d\%.\n\r", percent(ship->hull,ship->maxhull) );
    }

    if ( !str_cmp(arg,"drive") )
    {
       if (ship->location == ship->lastdoc)
          ship->shipstate = SHIP_DOCKED;
       else
          ship->shipstate = SHIP_READY;
       send_to_char("&GShips drive repaired.\n\r", ch);
    }

    if ( !str_cmp(arg,"launcher") )
    {
       ship->missilestate = MISSILE_READY;
       send_to_char("&GMissile launcher repaired.\n\r", ch);
    }

    if ( !str_cmp(arg,"laser") )
    {
       ship->statet0 = LASER_READY;
       send_to_char("&GMain laser repaired.\n\r", ch);
    }

    if ( !str_cmp(arg,"ions") )
    {
       ship->statet3 = LASER_READY;
       send_to_char("&GIon Cannon repaired.\n\r", ch);
    }

    if ( !str_cmp(arg,"turret 1") )
    {
       ship->statet1 = LASER_READY;
       send_to_char("&GLaser Turret 1 repaired.\n\r", ch);
    }

    if ( !str_cmp(arg,"turret 2") )
    {
       ship->statet2 = LASER_READY;
       send_to_char("&Laser Turret 2 repaired.\n\r", ch);
    }

    act( AT_PLAIN, "$n finishes the repairs.", ch,
         NULL, argument , TO_ROOM );

    learn_from_success( ch, gsn_shipmaintenance );
}
#endif

void do_repairship(CHAR_DATA *ch, char *argument ) 
{ 
    char arg[MAX_INPUT_LENGTH]; 
    int chance, change; 
    SHIP_DATA *ship; 

    strcpy( arg, argument );     

    switch( ch->substate ) 
    {
    default: 
    	/*if (  (ship = ship_from_engine(ch->in_room->vnum))  == NULL ) 
    	{
            send_to_char("&RYou must be in the engine room of a ship to do that!\n\r",ch); 
            return; 
        }*/ 
        if ( str_cmp( argument, "hull" ) && str_cmp( argument, "drive" ) && 
            str_cmp( argument, "launcher" ) && str_cmp( argument, "laser" ) &&  
            str_cmp( argument, "turret 1" ) && str_cmp( argument, "turret 2") &&
            str_cmp( argument, "ions" ) ) 
        { 
            send_to_char("&RYou need to spceify something to repair:\n\r",ch); 
            send_to_char("&rTry: hull, drive, launcher, laser, ions,  turret 1, or turret 2\n\r",ch); 
            return; 
        }
        /*Nix:  Requires char to be in corresponding room*/ 
        if(  !(str_cmp( argument, "hull" ) && str_cmp( argument, "drive" ))  ) 
        {
            if((ship = ship_from_engine(ch->in_room->vnum)) == NULL) 
            { 
                send_to_char("&RYou must be in the engine room of a ship to do that!\n\r", ch); 
                return; 
            } 
        }
        else if( !(str_cmp( argument, "laser") && str_cmp( argument , "launcher" ) && str_cmp(argument, "ions") ) ) 
        { 
            if((ship = ship_from_gunseat(ch->in_room->vnum)) == NULL) 
            { 
                send_to_char("&RYou must be in the gunner's seat of a ship to do that!\n\r", ch);
                return;
            } 
        }
        else if(!str_cmp( argument , "turret 1" )) 
        { 
            if((ship = ship_from_turret(ch->in_room->vnum)) == NULL || (ship->turret1 != ch->in_room->vnum)) 
            { 
                send_to_char("&RYou must be in turret 1 of a ship to do that!\n\r", ch); 
                return; 
            } 
        }
        else if(!str_cmp( argument, "turret 2" )) 
        {
            if((ship = ship_from_turret(ch->in_room->vnum)) == NULL || (ship->turret2 != ch->in_room->vnum)) 
            { 
               send_to_char("&RYou must be in turret 2 of a ship to do that!\n\r", ch); 
               return;
            } 
        }
        chance = IS_NPC(ch) ? ch->top_level : (int) (ch->pcdata->learned[gsn_shipmaintenance]); 
	if ( number_percent( ) < chance ) 
        { 
            send_to_char( "&GYou begin your repairs\n\r", ch); 
            act( AT_PLAIN, "$n begins repairing the ships $T.", ch, NULL, argument , TO_ROOM ); 
            if ( !str_cmp(arg,"hull") ) 
                add_timer ( ch , TIMER_DO_FUN , 15 , do_repairship , 1 ); 
            else 
                add_timer ( ch , TIMER_DO_FUN , 5 , do_repairship , 1 );
            ch->dest_buf = str_dup(arg); 
            return; 
        } 
        send_to_char("&RYou fail to locate the source of the problem.\n\r",ch); 
        learn_from_failure( ch, gsn_shipmaintenance ); 
        return;	 
		
    case 1: 
        if ( !ch->dest_buf ) 
            return; 
        strcpy(arg, ch->dest_buf); 
        DISPOSE( ch->dest_buf); 
        break; 

    case SUB_TIMER_DO_ABORT: 
        DISPOSE( ch->dest_buf ); 
        ch->substate = SUB_NONE; 
        if ( (ship = ship_from_cockpit(ch->in_room->vnum)) == NULL ) 
            return;    		                                    
        send_to_char("&RYou are distracted and fail to finish your repairs.\n\r", ch); 
        return; 
    } 

    ch->substate = SUB_NONE; 
    
    if ( (ship = ship_from_engine(ch->in_room->vnum)) == NULL ) 
    {   
        if( (ship = ship_from_turret(ch->in_room->vnum)) == NULL ) /*Nix: Accomidate turrets and gunseat*/ 
        { 
            return; 
        } 
    }

    if ( !str_cmp(arg,"hull") ) 
    {
        change = URANGE( 0 , 
            number_range( (int) ( ch->pcdata->learned[gsn_shipmaintenance] / 2 ) , (int) (ch->pcdata->learned[gsn_shipmaintenance]) ), 
            ( ship->maxhull - ship->hull ) ); 
        ship->hull += change; 
        ch_printf( ch, "&GRepair complete.. Hull strength inreased by %d points.\n\r", change ); 
    } 
     
    if ( !str_cmp(arg,"drive") ) 
    {   
       if (ship->location == ship->lastdoc) 
          ship->shipstate = SHIP_DOCKED; 
       else if(ship->shipstate == SHIP_DISABLED) /*if added by Nix, bugfix resulting for ships*/ 
          ship->shipstate = SHIP_READY;          /*being taken out of hyperspace without a system.*/ 
       send_to_char("&GShips drive repaired.\n\r", ch);/*Attepting to hyp again results in crash.*/ 
    } 
     
    if ( !str_cmp(arg,"launcher") ) 
    {   
        if(ship->missilestate == MISSILE_DAMAGED)/*Nix: Prevent bypassing reload time*/
             ship->missilestate = MISSILE_READY;
        send_to_char("&GMissile launcher repaired.\n\r", ch); 
    } 
     
    if ( !str_cmp(arg,"laser") ) 
    {   
       ship->statet0 = LASER_READY; 
       send_to_char("&GMain laser repaired.\n\r", ch); 
    } 
     
    if ( !str_cmp(arg,"turret 1") ) 
    {   
       ship->statet1 = LASER_READY; 
       send_to_char("&GLaser Turret 1 repaired.\n\r", ch); 
    } 
     
    if ( !str_cmp(arg,"turret 2") ) 
    {   
       ship->statet2 = LASER_READY; 
       send_to_char("&GLaser Turret 2 repaired.\n\r", ch); /*Nix: Typo, G missing*/
    }

    if ( !str_cmp(arg, "ions") )
    {
       ship->statet3 = LASER_READY;
       send_to_char("&GIon Cannon repaired.\n\r", ch);
    }
         
    act( AT_PLAIN, "$n finishes the repairs.", ch, 
         NULL, argument , TO_ROOM ); 
 
    learn_from_success( ch, gsn_shipmaintenance ); 
    	 
} 


void do_refuel( CHAR_DATA *ch, char *argument )
{
	char arg1[MAX_INPUT_LENGTH];
	int value,price;
	SHIP_DATA *ship;

	argument = one_argument( argument, arg1 );
	value = atoi(arg1);
	value = abs(value);

	if ( (ship = ship_from_cockpit(ch->in_room->vnum)) == NULL )
	{
		send_to_char("&RYou must be in the cockpit of a ship to do that!\n\r",ch);
		return;
	}

	if ( ship->class > SHIP_PLATFORM )
	{
		send_to_char("&RThis isn't a spacecraft!\n\r",ch);
		return;
	}

	if ( ship->energy == ship->maxenergy )
	{
		send_to_char("&RYou are already at max capacity.\n\r",ch);
		return;
	}

	if ( ( value + ship->energy ) > ship->maxenergy )
	{
		send_to_char("&RYou don't have that much fuel capacity.\n\r",ch);
		return;
	}

	if ( (ship = ship_from_pilotseat(ch->in_room->vnum)) == NULL )
	{
		send_to_char("&RYou don't seem to be in the pilot seat!\n\r",ch);
		return;
	}

	if  ( ship->class == SHIP_PLATFORM )
	{
		send_to_char( "You can't do that here.\n\r" , ch );
		return;
	}

	if ( ship->lastdoc != ship->location )
	{
		send_to_char("&rYou don't seem to be docked right now.\n\r",ch);
		return;
	}

	if ( ship->shipstate != SHIP_DOCKED && ship->shipstate != SHIP_DISABLED  )
	{
		send_to_char("The ship is not docked right now.\n\r",ch);
		return;
	}

	if ( arg1[0] == '\0' )
	{
		send_to_char( "Syntax: refuel <amount/full>\n\r", ch );
		send_to_char( "Price: 1 credit for 2 fuel units\n\r", ch);
		return;
	}

        if ( !str_cmp("1",arg1) )
        {
                price = value;
                ch_printf( ch, "You pay %d credits for %d units of fuel.\n\r", price, value );
                ship->energy += value;
				ch->gold -= price;
                return;
        }

	if ( !str_cmp("full",arg1) )
	{
		value = ship->maxenergy-ship->energy;
		price = value/2;
		ch_printf( ch, "You pay %d credits for %d units of fuel.\n\r", price, value );
		ship->energy += value;
		ch->gold -= price;
		return;
	}
	value = atoi(arg1);
	price = value/2;
	ch_printf( ch, "You pay %d credits for %d units of fuel.\n\r", price, value );
	ship->energy += value;
	ch->gold -= price;
}

void do_addpilot(CHAR_DATA *ch, char *argument )
{
    SHIP_DATA *ship;
	
	if (  (ship = ship_from_cockpit(ch->in_room->vnum))  == NULL )
	{
		send_to_char("&RYou must be in the cockpit of a ship to do that!\n\r",ch);
		return;
	}
	
	if  ( ship->class == SHIP_PLATFORM )
	{
		send_to_char( "&RYou can't do that here.\n\r" , ch );
		return;
	}
	
	if ( str_cmp( ship->owner , ch->name ) )
	{
		if ( !IS_NPC(ch) && ch->pcdata && ch->pcdata->clan
			&& !str_cmp(ch->pcdata->clan->name,ship->owner) )
		{
			if ( !str_cmp(ch->pcdata->clan->leader,ch->name) )
			;
			else if ( !str_cmp(ch->pcdata->clan->number1,ch->name) )
			;
			else if ( !str_cmp(ch->pcdata->clan->number2,ch->name) )
			;
			else
			{
				send_to_char( "&RThat isn't your ship!" ,ch );
				return;
			}
		}
		else
		{
			send_to_char( "&RThat isn't your ship!" ,ch );
			return;
		}
	}

   if (argument[0] == '\0')
   {
       send_to_char( "&RAdd which pilot?\n\r" ,ch );
       return;
  }

   if ( str_cmp( ship->pilot , "" ) )
   {
        if ( str_cmp( ship->copilot , "" ) )
        {
             send_to_char( "&RYou are ready have a pilot and copilot..\n\r" ,ch );
             send_to_char( "&RTry rempilot first.\n\r" ,ch );
             return;
        }

        STRFREE( ship->copilot );
	ship->copilot = STRALLOC( argument );
	send_to_char( "Copilot Added.\n\r", ch );
	save_ship( ship );
	return;

        return;
   }

   STRFREE( ship->pilot );
   ship->pilot = STRALLOC( argument );
   send_to_char( "Pilot Added.\n\r", ch );
   save_ship( ship );

}

void do_rempilot(CHAR_DATA *ch, char *argument )
{
    SHIP_DATA *ship;
	
	if (  (ship = ship_from_cockpit(ch->in_room->vnum))  == NULL )
	{
		send_to_char("&RYou must be in the cockpit of a ship to do that!\n\r",ch);
		return;
	}
	
	if  ( ship->class == SHIP_PLATFORM )
	{
		send_to_char( "&RYou can't do that here.\n\r" , ch );
		return;
	}
	
	if ( str_cmp( ship->owner , ch->name ) )
	{
		if ( !IS_NPC(ch) && ch->pcdata && ch->pcdata->clan 
			&& !str_cmp(ch->pcdata->clan->name,ship->owner) )
		{
			if ( !str_cmp(ch->pcdata->clan->leader,ch->name) )
			;
			else if ( !str_cmp(ch->pcdata->clan->number1,ch->name) )
			;
			else if ( !str_cmp(ch->pcdata->clan->number2,ch->name) )
			;
			else
			{
				send_to_char( "&RThat isn't your ship!" ,ch );
				return;
			}
		}
		else
		{
			send_to_char( "&RThat isn't your ship!" ,ch );
			return;
		}
	}
	
	if (argument[0] == '\0')
	{
		send_to_char( "&RRemove which pilot?\n\r" ,ch );
		return;
	}

   if ( !str_cmp( ship->pilot , argument ) )
   {
        STRFREE( ship->pilot );
	ship->pilot = STRALLOC( "" );
	send_to_char( "Pilot Removed.\n\r", ch );
	save_ship( ship );
	return;
   }

   if ( !str_cmp( ship->copilot , argument ) )
   {
        STRFREE( ship->copilot );
	ship->copilot = STRALLOC( "" );
	send_to_char( "Copilot Removed.\n\r", ch );
	save_ship( ship );
	return;
    }

    send_to_char( "&RThat person isn't listed as one of the ships pilots.\n\r" ,ch );

}

void do_radar( CHAR_DATA *ch, char *argument )
{
    SHIP_DATA *target;
    int chance;
    SHIP_DATA *ship;
    MISSILE_DATA *missile;

        if (   (ship = ship_from_cockpit(ch->in_room->vnum))  == NULL )
        {
            send_to_char("&RYou must be in the cockpit or turret of a ship to do that!\n\r",ch);
            return;
        }

        if ( ship->class > SHIP_PLATFORM )
    	        {
    	            send_to_char("&RThis isn't a spacecraft!\n\r",ch);
    	            return;
    	        }

        if (ship->shipstate == SHIP_DOCKED)
       {
            send_to_char("&RWait until after you launch!\n\r",ch);
            return;
        }

        if (ship->shipstate == SHIP_HYPERSPACE)
        {
            send_to_char("&RYou can only do that in realspace!\n\r",ch);
            return;
        }

    	if (ship->starsystem == NULL)
    	{
    	       send_to_char("&RYou can't do that unless the ship is flying in realspace!\n\r",ch);
    	       return;
    	}

        chance = IS_NPC(ch) ? ch->top_level
             : (int)  (ch->pcdata->learned[gsn_navigation]) ;
        if ( number_percent( ) > chance )
        {
           send_to_char("&RYou fail to work the controls properly.\n\r",ch);
           learn_from_failure( ch, gsn_navigation );
    	   return;
        }


    act( AT_PLAIN, "$n checks the radar.", ch,
         NULL, argument , TO_ROOM );

    	           set_char_color(  AT_WHITE, ch );
    	           ch_printf(ch, "%s\n\r\n\r" , ship->starsystem->name );
    	           set_char_color(  AT_LBLUE, ch );
    	           if ( ship->starsystem->star1 && str_cmp(ship->starsystem->star1,"") )
    	                 ch_printf(ch, "%s   %d %d %d\n\r" ,
    	                        ship->starsystem->star1,
    	                        ship->starsystem->s1x,
   	                        ship->starsystem->s1y,
    	                        ship->starsystem->s1z );
    	           if ( ship->starsystem->star2 && str_cmp(ship->starsystem->star2,"")  )
    	                 ch_printf(ch, "%s   %d %d %d\n\r" ,
   	                        ship->starsystem->star2,
    	                        ship->starsystem->s2x,
    	                        ship->starsystem->s2y,
    	                        ship->starsystem->s2z );
    	           if ( ship->starsystem->planet1 && str_cmp(ship->starsystem->planet1,"") )
    	                 ch_printf(ch, "%s   %d %d %d\n\r" ,
    	                        ship->starsystem->planet1,
    	                        ship->starsystem->p1x,
    	                        ship->starsystem->p1y,
    	                        ship->starsystem->p1z );
    	           if ( ship->starsystem->planet2 && str_cmp(ship->starsystem->planet2,"")  )
    	                 ch_printf(ch, "%s   %d %d %d\n\r" ,
    	                        ship->starsystem->planet2,
    	                        ship->starsystem->p2x,
    	                        ship->starsystem->p2y,
    	                        ship->starsystem->p2z );
    	           if ( ship->starsystem->planet3 && str_cmp(ship->starsystem->planet3,"")  )
    	                 ch_printf(ch, "%s   %d %d %d\n\r" ,
    	                        ship->starsystem->planet3,
    	                        ship->starsystem->p3x,
    	                        ship->starsystem->p3y,
    	                        ship->starsystem->p3z );
    	           ch_printf(ch,"\n\r");
    	           for ( target = ship->starsystem->first_ship; target; target = target->next_in_starsystem )
                   {
                        if ( target != ship && !IS_SET(target->flags, SHIP_MASKED) )
                           ch_printf(ch, "%s    %.0f %.0f %.0f\n\r",
                           	target->name,
                           	target->vx,
                           	target->vy,
                           	target->vz);
                   }
                   ch_printf(ch,"\n\r");
    	           for ( missile = ship->starsystem->first_missile; missile; missile = missile->next_in_starsystem )
                   {
                           ch_printf(ch, "%s    %d %d %d\n\r",
                           	missile->missiletype == CONCUSSION_MISSILE ? "A Concusion missile" :
    			        ( missile->missiletype ==  PROTON_TORPEDO ? "A Torpedo" :
    			        ( missile->missiletype ==  HEAVY_ROCKET ? "A Heavy Rocket" : "A Heavy Bomb" ) ),
                           	missile->mx,
                           	missile->my,
                                missile->mz );
                   }

                   ch_printf(ch, "\n\r&WYour Coordinates: %.0f %.0f %.0f\n\r" ,
                             ship->vx , ship->vy, ship->vz);

        learn_from_success( ch, gsn_navigation );
}

void do_autotrack( CHAR_DATA *ch, char *argument )
{
   SHIP_DATA *ship;
   int chance;

   if (  (ship = ship_from_cockpit(ch->in_room->vnum))  == NULL )
   {
        send_to_char("&RYou must be in the cockpit of a ship to do that!\n\r",ch);
        return;
   }

        if ( ship->class > SHIP_PLATFORM )
    	        {
    	            send_to_char("&RThis isn't a spacecraft!\n\r",ch);
    	            return;
    	        }
        if ( ship->class == SHIP_PLATFORM )
    	        {
    	            send_to_char("&RPlatforms don't have autotracking systems!\n\r",ch);
    	            return;
    	        }
        if ( ship->class == CAPITAL_SHIP )
    	        {
    	            send_to_char("&RThis ship is too big for autotracking!\n\r",ch);
    	            return;
    	        }

   if (  (ship = ship_from_pilotseat(ch->in_room->vnum))  == NULL )
   {
        send_to_char("&RYou aren't in the pilots chair!\n\r",ch);
        return;
   }
                if ( autofly(ship)  )
    	        {
    	            send_to_char("&RYou'll have to turn off the ships autopilot first....\n\r",ch);
    	            return;
    	        }

   chance = IS_NPC(ch) ? ch->top_level
             : (int)  (ch->pcdata->learned[gsn_shipsystems]) ;
        if ( number_percent( ) > chance )
        {
           send_to_char("&RYour notsure which switch to flip.\n\r",ch);
           learn_from_failure( ch, gsn_shipsystems );
    	   return;
        }

   act( AT_PLAIN, "$n flips a switch on the control panel.", ch,
         NULL, argument , TO_ROOM );
   if (ship->autotrack)
   {
     ship->autotrack = FALSE;
     echo_to_cockpit( AT_YELLOW , ship, "Autotracking off.");
   }
   else
   {
      ship->autotrack = TRUE;
      echo_to_cockpit( AT_YELLOW , ship, "Autotracking on.");
   }

   learn_from_success( ch, gsn_shipsystems );

}

void do_pluogus( CHAR_DATA *ch, char *argument )
{
    int next_planet, itt;

	if ( !has_comlink(ch) )
	{
		send_to_char( "You need a comlink to do that!\n\r", ch);
		return;
	}

    send_to_char( "&G&WSerin Pluogus Schedule Information:&G&W\n\r", ch );
	send_to_char( "&R-----------------------------------&G&W\n\r", ch );

     /* current port */

     if ( bus_pos < 7 && bus_pos > 1 )
        ch_printf( ch, "&G&WThe Pluogus is Currently docked at &R%s&G&W.\n\r", bus1_stop[bus1_planet] );

     /* destinations */

     next_planet = bus1_planet;
     send_to_char( "&G&WNext stops: ", ch);

     if ( bus_pos <= 1 )
        ch_printf( ch, "&R%s  &G&W", bus1_stop[next_planet] );

     for ( itt = 0 ; itt < 3 ; itt++ )
     {
         next_planet++;
         if ( next_planet >= MAX_BUS1_STOP )
            next_planet = 0;
         ch_printf( ch, " &B%s &G&W", bus1_stop[next_planet] );
     }

     ch_printf( ch, "\n\r\n\r" );

     send_to_char( "&RSerin Tocca Schedule Information:&G&W\n\r", ch );
	 send_to_char( "&R---------------------------------&G&W\n\r", ch );

     /* current port */

     if ( bus_pos < 7 && bus_pos > 1 )
        ch_printf( ch, "&G&WThe Tocca is Currently docked at &R%s&G&W.\n\r", bus2_stop[bus2_planet] );

     /* destinations */

     next_planet = bus2_planet;
     send_to_char( "&G&WNext stops: &B", ch);

     if ( bus_pos <= 1 )
        ch_printf( ch, "&R%s  &G&W", bus2_stop[next_planet] );

     for ( itt = 0 ; itt < 3 ; itt++ )
     {
         next_planet++;
         if ( next_planet >= MAX_BUS2_STOP )
            next_planet = 0;
         ch_printf( ch, " &B%s &G&W", bus2_stop[next_planet] );
     }

     ch_printf( ch, "\n\r" );
	 ch_printf( ch, "\n\r" );
}


void do_drive( CHAR_DATA *ch, char *argument )
{
    int dir;
    SHIP_DATA *ship;

	if (  (ship = ship_from_cockpit(ch->in_room->vnum))  == NULL )
	{
		send_to_char("&RYou must be in the drivers seat of a land vehicle to do that!\n\r",ch);
		return;
	}

	if ( !ship->repulsor && ship->class <= MIDSIZE_SHIP )
	{
		send_to_char("&RYou don't have the repulsor engines on!\n\r",ch);
		return;
	}
	else
	{
		send_to_char("Your Ship can't drive. Its too big.\n\r",ch);
		return;
	}

	if (ship->shipstate == SHIP_DISABLED)
	{
		send_to_char("&RThe drive is disabled.\n\r",ch);
		return;
	}

	if ( ship->energy < 1 )
	{
		send_to_char("&RTheres not enough fuel!\n\r",ch);
		return;
	}

	if ( ( dir = get_door( argument ) ) == -1 )
	{
		send_to_char( "Usage: drive <direction>\n\r", ch );
		return;
	}

	if ( ( ship->class >= MIDSIZE_SHIP ) || ship->repulsor )
		drive_ship( ch, ship, get_exit(get_room_index(ship->location), dir), 0 );
	else
	{
		send_to_char( "&RYou must turn on the repulsorfield./n/r", ch);
		return;
	}
}

ch_ret drive_ship( CHAR_DATA *ch, SHIP_DATA *ship, EXIT_DATA  *pexit , int fall )
{
	ROOM_INDEX_DATA *in_room;
	ROOM_INDEX_DATA *to_room;
	ROOM_INDEX_DATA *from_room;
	ROOM_INDEX_DATA *original;
	char buf[MAX_STRING_LENGTH];
	char *txt;
	char *dtxt;
	ch_ret retcode;
	sh_int door, distance;
	bool drunk = FALSE;
	CHAR_DATA * rch;
	CHAR_DATA * next_rch;

	if ( !IS_NPC( ch ) )
		if ( IS_DRUNK( ch, 2 ) && ( ch->position != POS_SHOVE )
			&& ( ch->position != POS_DRAG ) )
		drunk = TRUE;

    if ( drunk && !fall )
    {
		door = number_door();
		pexit = get_exit( get_room_index(ship->location), door );
	}

#ifdef DEBUG
    if ( pexit )
    {
		sprintf( buf, "drive_ship: %s to door %d", ch->name, pexit->vdir );
		log_string( buf );
    }
#endif

    retcode = rNONE;
    txt = NULL;

    in_room = get_room_index(ship->location);
    from_room = in_room;
    if ( !pexit || (to_room = pexit->to_room) == NULL )
    {
		if ( drunk )
		{
			send_to_char( "You drive into a wall in your drunken state.\n\r", ch );
			damage_ship( ship , 5 , 10 );
		}
		else
			send_to_char( "Alas, you cannot go that way.\n\r", ch );
		return rNONE;
	}

    door = pexit->vdir;
    distance = pexit->distance;

    if ( IS_SET( pexit->exit_info, EX_WINDOW )
		&&  !IS_SET( pexit->exit_info, EX_ISDOOR ) )
    {
		send_to_char( "Alas, you cannot go that way.\n\r", ch );
		return rNONE;
    }

	if (  IS_SET(pexit->exit_info, EX_PORTAL)
		&& IS_NPC(ch) )
	{
		act( AT_PLAIN, "Mobs can't use portals.", ch, NULL, NULL, TO_CHAR );
		return rNONE;
	}

    if ( IS_SET(pexit->exit_info, EX_NOMOB)
		&& IS_NPC(ch) )
	{
		act( AT_PLAIN, "Mobs can't enter there.", ch, NULL, NULL, TO_CHAR );
		return rNONE;
    }

    if ( IS_SET(pexit->exit_info, EX_CLOSED)
    && (IS_SET(pexit->exit_info, EX_NOPASSDOOR)) )
    {
	if ( !IS_SET( pexit->exit_info, EX_SECRET )
	&&   !IS_SET( pexit->exit_info, EX_DIG ) )
	{
		if ( drunk )
		{
			act( AT_PLAIN, "$n flies into the $d in $s drunken state.", ch,
				NULL, pexit->keyword, TO_ROOM );
			act( AT_PLAIN, "You flies into the $d in your drunken state.", ch,
				NULL, pexit->keyword, TO_CHAR );
			damage_ship( ship , 5 , 10 );
		}
		else
			act( AT_PLAIN, "The $d is closed.", ch, NULL, pexit->keyword, TO_CHAR );
	}
	else
	{
		if ( drunk )
		{
			send_to_char( "You hit a wall in your drunken state.\n\r", ch );
			damage_ship( ship , 5 , 10 );
		}
		else
			send_to_char( "Alas, you cannot go that way.\n\r", ch );
	}

	return rNONE;
    }
	if ( room_is_private( ch, to_room )  && get_trust(ch) < sysdata.level_override_private )
    {
		send_to_char( "That room is private right now.\n\r", ch );
		return rNONE;
    }
	else if ( room_is_private( ch, to_room ) && get_trust(ch) > sysdata.level_override_private && !IS_NPC(ch) )
	{
		send_to_char( "Overriding private flag!\n\r", ch );
	}

    /*if ( !IS_IMMORTAL(ch)
		&&  !IS_NPC(ch)
		&&  ch->in_room->area != to_room->area )
    {
		if ( ch->top_level < to_room->area->low_hard_range )
		{
			set_char_color( AT_TELL, ch );
			switch( to_room->area->low_hard_range - ch->top_level )
			{
			case 1:
				send_to_char( "A voice in your mind says, 'You are nearly ready to go that way...'", ch );
				break;
			case 2:
				send_to_char( "A voice in your mind says, 'Soon you shall be ready to travel down this path... soon.'", ch );
				break;
			case 3:
				send_to_char( "A voice in your mind says, 'You are not ready to go down that path... yet.'.\n\r", ch);
				break;
			default:
				send_to_char( "A voice in your mind says, 'You are not ready to go down that path.'.\n\r", ch);
			}
			return rNONE;
		}
		else
			if ( ch->top_level > to_room->area->hi_hard_range )
			{
				set_char_color( AT_TELL, ch );
				send_to_char( "A voice in your mind says, 'There is nothing more for you down that path.'", ch );
				return rNONE;
			}
    }*/
    
	if ( !fall )
    {
        if ( ( xIS_SET( to_room->room_flags, ROOM_INDOORS )
			|| xIS_SET( to_room->room_flags, ROOM_SPACECRAFT )
			|| to_room->sector_type == SECT_INSIDE )
			&& !IS_SET(ship->flags,SHIP_CANFLYINDOORS) )
		{
			send_to_char( "You can't drive indoors!\n\r", ch );
			return rNONE;
		}

        if ( xIS_SET( to_room->room_flags, ROOM_NO_DRIVING ) )
		{
			send_to_char( "You can't take a vehicle through there!\n\r", ch );
			return rNONE;
		}
		if ( in_room->sector_type == SECT_AIR
			||   to_room->sector_type == SECT_AIR
			||   IS_SET( pexit->exit_info, EX_FLY ) )
		{
			if ( ship->class > MIDSIZE_SHIP  )
			{
				send_to_char( "You'd need to fly to go there.\n\r", ch );
				return rNONE;
			}
		}

		if ( in_room->sector_type == SECT_WATER_NOSWIM
			||   to_room->sector_type == SECT_WATER_NOSWIM
			||   to_room->sector_type == SECT_WATER_SWIM
			||   to_room->sector_type == SECT_UNDERWATER
			||   to_room->sector_type == SECT_OCEANFLOOR )
		{
			send_to_char( "You'd need a boat to go there.\n\r", ch );
			return rNONE;
		}

		if ( IS_SET( pexit->exit_info, EX_CLIMB ) )
		{

			if ( ship->class > MIDSIZE_SHIP )
			{
				send_to_char( "You need to fly or climb to get up there.\n\r", ch );
				return rNONE;
			}
		}
	}

    if ( to_room->tunnel > 0 )
    {
		CHAR_DATA *ctmp;
		int count = 0;

		for ( ctmp = to_room->first_person; ctmp; ctmp = ctmp->next_in_room )
			if ( ++count >= to_room->tunnel )
			{
				send_to_char( "There is no room for you in there.\n\r", ch );
				return rNONE;
			}
    }

	if ( fall )
        txt = "falls";
	else if ( !txt )
		txt = "fly";
	sprintf( buf, "$n %ss the vehicle $T.", txt ); 
	act( AT_ACTION, buf, ch, NULL, dir_name[door], TO_ROOM );
	sprintf( buf, "You %s the vehicle $T.", txt );
	act( AT_ACTION, buf, ch, NULL, dir_name[door], TO_CHAR );
	sprintf( buf, "%s %ss %s.", ship->name, txt, dir_name[door] );
	echo_to_room( AT_ACTION , get_room_index(ship->location) , buf );

	extract_ship( ship );
	ship_to_room(ship, to_room->vnum );

	ship->location = to_room->vnum;
	ship->lastdoc = ship->location;

	if ( fall )
        txt = "falls";
	else
		txt = "flys in";

	switch( door )
	{
	default: dtxt = "somewhere";	break;
	case 0:  dtxt = "the south";	break;
	case 1:  dtxt = "the west";	break;
	case 2:  dtxt = "the north";	break;
	case 3:  dtxt = "the east";	break;
	case 4:  dtxt = "below";		break;
	case 5:  dtxt = "above";		break;
	case 6:  dtxt = "the south-west";	break;
	case 7:  dtxt = "the south-east";	break;
	case 8:  dtxt = "the north-west";	break;
	case 9:  dtxt = "the north-east";	break;
	}

    sprintf( buf, "%s %s from %s.", ship->name, txt, dtxt );
    echo_to_room( AT_ACTION , get_room_index(ship->location) , buf );

	for ( rch = ch->in_room->last_person ; rch ; rch = next_rch )
    {
        next_rch = rch->prev_in_room;
        original = rch->in_room;
        char_from_room( rch );
        char_to_room( rch, to_room );
        do_look( rch, "auto" );
        char_from_room( rch );
        char_to_room( rch, original );
    }
	return retcode;
}

void do_chaff( CHAR_DATA *ch, char *argument )
{
	int chance;
    SHIP_DATA *ship;
	
	if (  (ship = ship_from_cockpit(ch->in_room->vnum))  == NULL )
	{
		send_to_char("&RYou must be in the cockpit of a ship to do that!\n\r",ch);
		return;
	}
	
	if ( ship->class > SHIP_PLATFORM )
	{
		send_to_char("&RThis isn't a spacecraft!\n\r",ch);
		return;
	}
	
	if (  (ship = ship_from_coseat(ch->in_room->vnum))  == NULL )
	{
		send_to_char("&RThe controls are at the copilots seat!\n\r",ch);
		return;
	}
	if ( autofly(ship) )
	{
		send_to_char("&RYou'll have to turn the autopilot off first...\n\r",ch);
		return;
	}
	if (ship->shipstate == SHIP_HYPERSPACE)
	{
		send_to_char("&RYou can only do that in realspace!\n\r",ch);
		return;
	}
	if (ship->shipstate == SHIP_DOCKED)
	{
		send_to_char("&RYou can't do that until after you've launched!\n\r",ch);
		return;
	}
	if (ship->chaff <= 0 )
	{
		send_to_char("&RYou don't have any chaff to release!\n\r",ch);
		return;
	}
	chance = IS_NPC(ch) ? ch->top_level
		: (int)  (ch->pcdata->learned[gsn_weaponsystems]) ;
	if ( number_percent( ) > chance )
	{
		send_to_char("&RYou can't figure out which switch it is.\n\r",ch);
		learn_from_failure( ch, gsn_weaponsystems );
		return;
	}
    ship->chaff--;
    ship->chaff_released++;
    send_to_char( "You flip the chaff release switch.\n\r", ch);
	act( AT_PLAIN, "$n flips a switch on the control pannel", ch,
        NULL, argument , TO_ROOM );
	echo_to_cockpit( AT_YELLOW , ship , "A burst of chaff is released from the ship.");
    learn_from_success( ch, gsn_weaponsystems );
}

bool autofly( SHIP_DATA *ship )
{
	if ( !ship )
		return FALSE;

	if ( IS_SET(ship->flags,SHIP_MOB) )
		return TRUE;

	if ( ship->autopilot )
		return TRUE;

	if ( IS_SET( ship->flags, SHIP_AUTOPILOT ) )
		return TRUE;

	return FALSE;
}

void do_repulsor( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    int chance;
    SHIP_DATA *ship;

	argument = one_argument( argument, arg );

	if (  (ship = ship_from_cockpit(ch->in_room->vnum))  == NULL )
	{
		send_to_char("&RYou must be in the cockpit of a ship to do that!\n\r",ch);
		return;
	}

	if (ship->shipstate == SHIP_HYPERSPACE)
	{
		send_to_char("&RYou can only do that on land!\n\r",ch);
		return;
	}
	if (ship->shipstate == SHIP_DISABLED)
	{
		send_to_char("&RThe ships drive is disabled. Unable to manuever.\n\r",ch);
		return;
	}
	if (ship->shipstate < SHIP_DOCKED)
	{
		send_to_char("&RYou can't do that till you've landed\n\r",ch);
		return;
	}

	if ( ship->energy <1 )
	{
		send_to_char("&RTheres not enough fuel!\n\r",ch);
		return;
	}

	if ( ship->class == FIGHTER_SHIP )
		chance = IS_NPC(ch) ? ch->top_level : (int)  (ch->pcdata->learned[gsn_starfighters]) ;
	else if ( ship->class == MIDSIZE_SHIP )
		chance = IS_NPC(ch) ? ch->top_level : (int)  (ch->pcdata->learned[gsn_midships]) ;
	else if ( ship->class == CAPITAL_SHIP )
		chance = IS_NPC(ch) ? ch->top_level : (int) (ch->pcdata->learned[gsn_capitalships]);
	else
		chance = 1000;

	if ( number_percent( ) > chance )
	{
		send_to_char("&RYou fail to work the controls properly.\n\r",ch);
		if ( ship->class == FIGHTER_SHIP )
			learn_from_failure( ch, gsn_starfighters );
		if ( ship->class == MIDSIZE_SHIP )
			learn_from_failure( ch, gsn_midships );
		if ( ship->class == CAPITAL_SHIP )
			learn_from_failure( ch, gsn_capitalships );
    	   return;
	}
    if ( (arg[0] == 'o' && arg[1] == 'n') || ship->repulsor == 0 )
    {
		send_to_char( "&GYou activate the repulsor field\n\r", ch);
		act( AT_PLAIN, "$n activates the repulsor field", ch,
			NULL, argument , TO_ROOM );
		echo_to_room( AT_YELLOW , get_room_index(ship->cockpit) , "");
		ship->repulsor += 1;
    }

    else if ( (arg[0] == 'o' && arg[1] == 'f' && arg[2] == 'f' ) || ship->repulsor == 1 )
    {
        send_to_char( "&GYou deactivate the repulsor field\n\r", ch);
		act( AT_PLAIN, "$n deactivates the repulsor field", ch,
			NULL, argument , TO_ROOM );
		echo_to_room( AT_YELLOW , get_room_index(ship->cockpit) , "");
		ship->repulsor -= 1;
    }

    if ( ship->class == FIGHTER_SHIP )
        learn_from_success( ch, gsn_starfighters );
    if ( ship->class == MIDSIZE_SHIP )
        learn_from_success( ch, gsn_midships );
    if ( ship->class == CAPITAL_SHIP )
        learn_from_success( ch, gsn_capitalships );
}



void do_transship( CHAR_DATA *ch ,char *argument )
{
    char arg1[MAX_INPUT_LENGTH];
	char arg2[MAX_INPUT_LENGTH];
	int arg3;
    SHIP_DATA *ship;

    if ( IS_NPC( ch ) )
    {
	send_to_char( "Huh?\n\r", ch );
	return;
    }

    argument = one_argument( argument, arg1 );
    argument = one_argument( argument, arg2 );

    ship = get_ship( arg1 );
	if ( !ship )
    {
	send_to_char( "No such ship.\n\r", ch );
	return;
    }

	arg3 = atoi( arg2 );

	 if ( arg1[0] == '\0' || arg2[0] == '\0' || arg1[0] == '\0' )
    {
	send_to_char( "Usage: transship <ship> <vnum>\n\r", ch );
	return;
    }

	 ship->shipyard = arg3;
     ship->shipstate = SHIP_READY;

     if ( ship->class != SHIP_PLATFORM && !IS_SET(ship->flags,SHIP_MOB) )
     {
           extract_ship( ship );
           ship_to_room( ship , ship->shipyard );

           ship->location = ship->shipyard;
           ship->lastdoc = ship->shipyard;
           ship->shipstate = SHIP_DOCKED;
     }

     if (ship->starsystem)
        ship_from_starsystem( ship, ship->starsystem );

     save_ship(ship);
	 send_to_char( "Ship Transfered.\n\r", ch );
}

void do_openbay( CHAR_DATA *ch, char *argument )
{
	char buf[MAX_STRING_LENGTH];
	SHIP_DATA *ship;
	SHIP_DATA *target;
	int chance;

    if ( IS_NPC( ch ) )
    {
	send_to_char( "Huh?\n\r", ch );
	return;
    }

    ship = get_ship( argument );
	if ( !ship )
    {
	send_to_char( "No such ship.\n\r", ch );
	return;
    }

	if ( ship->class < MIDSIZE_SHIP || ship->hanger == 0 )
	{
		send_to_char ("That Ship Doesn't Have A Hanger!",ch);
		return;
	}

	if (IS_IMMORTAL(ch))
	{
		/*if (ship->bayopen)*/
		if ( IS_SET( ship->flags, SHIP_BAYOPEN ) )
		{
			TOGGLE_BIT( ship->flags, SHIP_BAYOPEN );
			ship->bayopen = FALSE;
			sprintf( buf, "!!SOUND(BayClose U=http://mercury.spaceports.com/~gavin1/)&RClosing %s's bay doors." , ship->name );
			send_to_char(buf,ch);
			sound_to_ship(ship , "!!SOUND(BayClose U=http://mercury.spaceports.com/~gavin1/)" );
			sprintf( buf, "Closing bay doors.");
			echo_to_ship( AT_RED , ship , buf  );
			save_ship(ship);
		}
		else
		{
			ship->bayopen = TRUE;
			TOGGLE_BIT( ship->flags, SHIP_BAYOPEN );
			sprintf( buf, "!!SOUND(BayClose U=http://mercury.spaceports.com/~gavin1/)Opening bay doors.");
			echo_to_ship( AT_RED , ship , buf );
			sound_to_ship(ship , "!!SOUND(BayClose U=http://mercury.spaceports.com/~gavin1/)" );
			sprintf( buf, "&ROpening %s's bay doors." , ship->name );
			send_to_char(buf,ch);
			save_ship(ship);
		}
		return;
	}

	target = ship_from_cockpit( ch->in_room->vnum );
	if ( (ship_from_cockpit(ch->in_room->vnum)) == NULL )
	{
		send_to_char("&RYou must be in the cockpit of a ship to do that!\n\r",ch);
		return;
	}

	if ( ship->class > SHIP_PLATFORM )
	{
		send_to_char("&RThis isn't a spacecraft!\n\r",ch);
		return;
	}

	if ( target->starsystem != ship->starsystem && !IS_IMMORTAL(ch) ) {
		send_to_char("Wrong StarSystem!\n\r",ch);
		return;
	}

	if ( !check_pilot( ch , ship ) || !str_cmp( ship->owner , "Public" ) )
	{
		send_to_char("&RHey, thats not your ship!\n\r",ch);
		return;
	}
	else
	{
		chance = IS_NPC(ch) ? ch->top_level
		: (int)  (ch->pcdata->learned[gsn_shipsystems]) ;
		if ( number_percent( ) > chance )
		{
			send_to_char("&RYour notsure which switch to flip.\n\r",ch);
			learn_from_failure( ch, gsn_shipsystems );
			return;
		}

		act( AT_PLAIN, "$n flips a switch on the control panel.", ch, NULL, argument , TO_ROOM );
		/*if (ship->bayopen)*/
		if ( IS_SET( ship->flags, SHIP_BAYOPEN ))
		{
			TOGGLE_BIT( ship->flags, SHIP_BAYOPEN );
			ship->bayopen = FALSE;
			if ( IS_SET(ship->flags, SHIP_MASKED) )
			{
				sprintf( buf, "!!SOUND(BayClose U=http://mercury.spaceports.com/~gavin1/)Closing %s's bay doors." , ship->name );
				echo_to_system( AT_RED , target , buf , NULL );
			}
			sound_to_ship(ship , "!!SOUND(BayClose U=http://mercury.spaceports.com/~gavin1/)" );
			sprintf( buf, "Closing bay doors.");
			echo_to_ship( AT_RED , ship , buf  );
			save_ship(ship);
		}
		else
		{
			ship->bayopen = TRUE;
			TOGGLE_BIT( ship->flags, SHIP_BAYOPEN );
			if ( IS_SET(ship->flags, SHIP_MASKED) )
			{
				sprintf( buf, "!!SOUND(BayClose U=http://mercury.spaceports.com/~gavin1/)Opening %s's bay doors." , ship->name );
				echo_to_system( AT_RED , ship , buf , NULL );
			}
			sound_to_ship(ship , "!!SOUND(BayClose U=http://mercury.spaceports.com/~gavin1/)" );
			sprintf( buf, "Opening bay doors.");
			echo_to_ship( AT_RED , ship , buf );
			save_ship(ship);
		}

		/* sprintf( buf, "%s",ship->bayopen);
		send_to_char( buf, ch ); */
	}
}

void do_tractorbeam( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    int chance;
    SHIP_DATA *ship;
    SHIP_DATA *target;
	char buf[MAX_STRING_LENGTH];
    strcpy( arg, argument );

	if ( (ship = ship_from_cockpit(ch->in_room->vnum)) == NULL )
	{
		send_to_char("&RYou must be in the cockpit of a ship to do that!\n\r",ch);
		return;
	}

	if ( ship->class > SHIP_PLATFORM )
	{
		send_to_char("&RThis isn't a spacecraft!\n\r",ch);
		return;
	}

	if ( !check_pilot( ch , ship ) )
	{
		send_to_char("This isn't your ship!\n\r" , ch );
		return;
	}
	if ( IS_SET(ship->flags, SHIP_MASKED) )
	{
		echo_to_cockpit( AT_RED, ship, "&R[&WShip Status&R]&W You are unable todo so when masked.");
		return;
	}
	if ( ship->tractorbeam == 0 )
	{
		send_to_char("You might want to install a tractorbeam!\n\r" , ch );
		return;
	}

	if ( ship->hanger == 0 )
	{
		send_to_char("No hanger available.\n\r",ch);
		return;
	}
	if ( !IS_SET( ship->flags, SHIP_BAYOPEN ) )
	{
		send_to_char("Your hanger is closed.\n\r",ch);
		return;
	}

	if ( (ship = ship_from_pilotseat(ch->in_room->vnum)) == NULL )
	{
		send_to_char("&RYou need to be in the pilot seat!\n\r",ch);
		return;
	}

	if (ship->shipstate == SHIP_DISABLED)
	{
		send_to_char("&RThe ships drive is disabled. No power available.\n\r",ch);
		return;
	}

	if (ship->shipstate == SHIP_DOCKED || ship->shipstate == SHIP_SHIP2SHIP)
	{
		send_to_char("&RYour ship is docked!\n\r",ch);
		return;
	}

	if (ship->shipstate == SHIP_HYPERSPACE)
	{
		send_to_char("&RYou can only do that in realspace!\n\r",ch);
		return;
	}

	if (ship->shipstate != SHIP_READY)
	{
		send_to_char("&RPlease wait until the ship has finished its current manouver.\n\r",ch);
		return;
	}

	if ( argument[0] == '\0' )
	{
		send_to_char("&RCapture what?\n\r",ch);
		return;
	}

	target = get_ship_here( argument , ship->starsystem );

	if ( target == NULL )
	{
		send_to_char("&RI don't see that here.\n\r",ch);
		return;
	}

	if ( target == ship )
	{
		send_to_char("&RYou can't yourself!\n\r",ch);
		return;
	}

	if ( target->shipstate == SHIP_LAND )
	{
		send_to_char("&RThat ship is already in a landing sequence.\n\r", ch);
		return;
	}

	if (  (target->vx > ship->vx + 200) || (target->vx < ship->vx - 200) ||
	   (target->vy > ship->vy + 200) || (target->vy < ship->vy - 200) ||
	   (target->vz > ship->vz + 200) || (target->vz < ship->vz - 200) )
	{
		send_to_char("&R That ship is too far away! You'll have to fly a little closer.\n\r",ch);
		return;
	}

	if (ship->class <= target->class)
	{
		send_to_char("&RThat ship is too big for your hanger.\n\r",ch);
		return;
	}

	if  ( target->class == SHIP_PLATFORM )
	{
		send_to_char( "&RYou can't capture platforms.\n\r" , ch );
		return;
	}

	if ( target->class == CAPITAL_SHIP)
	{
		send_to_char("&RYou can't capture capital ships.\n\r",ch);
		return;
	}
	if ( ship->energy < (25 + 25*target->class) )
	{
		send_to_char("&RTheres not enough fuel!\n\r",ch);
		return;
	}
	chance = IS_NPC(ch) ? ch->top_level
	: (int)  (ch->pcdata->learned[gsn_tractorbeams]);

	/* This is just a first guess chance modifier, feel free to change if needed */

	chance = chance * ( ship->tractorbeam / (target->currspeed+1 ) );
	if ( number_percent( ) < chance )
	{
		set_char_color( AT_GREEN, ch );
		send_to_char( "Capture sequence initiated.\n\r", ch);
		act( AT_PLAIN, "$n begins the capture sequence.", ch,
			NULL, argument , TO_ROOM );
		echo_to_ship( AT_YELLOW , ship , "ALERT: Ship is being captured, all hands to docking bay." );
    	echo_to_ship( AT_YELLOW , target , "The ship shudders as a tractorbeam locks on." );
		sprintf( buf , "You are being captured by %s." , ship->name);
		echo_to_cockpit( AT_BLOOD , target , buf );

		if ( autofly(target) && !target->target0)
			target->target0 = ship;

		target->dest = STRALLOC(ship->name);
		target->shipstate = SHIP_LAND;
		target->currspeed = 0;

		learn_from_success( ch, gsn_tractorbeams );
		return;

	}
	send_to_char("You fail to work the controls properly.\n\r",ch);
   	echo_to_ship( AT_YELLOW , target , "The ship shudders and then stops as a tractorbeam attemps to lock on." );
	sprintf( buf , "The %s attempted to capture your ship!" , ship->name);
	echo_to_cockpit( AT_BLOOD , target , buf );
	if ( autofly(target) && !target->target0)
		target->target0 = ship;

	learn_from_failure( ch, gsn_tractorbeams );

   	return;
}

void undockship( SHIP_DATA *ship )
{
    char buf[MAX_STRING_LENGTH];
    SHIP_DATA *target;
    int plusminus;

/*	if (ship->starsystem)
		ship_to_starsystem( ship, ship->starsystem );
	else
		return;*/
/*	if (!ship->starsystem)
		ship_to_starsystem( ship, starsystem_from_vnum( ship->location ) );*/

/*	if (!ship->docked2)
		return;*/

    if ( ship->starsystem == NULL )
    {
       echo_to_room( AT_YELLOW , get_room_index(ship->pilotseat) , "Launch path blocked .. Undocking aborted.");
       echo_to_ship( AT_YELLOW , ship , "The ship slowly redocks.");
       sprintf( buf ,  "%s slowly redocks." ,ship->name );
       echo_to_room( AT_YELLOW , get_room_index(ship->docked2) , buf );
       ship->shipstate = SHIP_SHIP2SHIP;
       return;
    }

    if (ship->class == MIDSIZE_SHIP)
    {
       sound_to_room( get_room_index(ship->docked2) , "!!SOUND(falcon U=http://mercury.spaceports.com/~gavin1/)" );
       sound_to_ship(ship , "!!SOUND(falcon U=http://mercury.spaceports.com/~gavin1/)" );
    }
    else
    {
       sound_to_ship(ship , "!!SOUND(xwing U=http://mercury.spaceports.com/~gavin1/)" );
       sound_to_room( get_room_index(ship->docked2) , "!!SOUND(xwing U=http://mercury.spaceports.com/~gavin1/)" );
    }

    extract_ship(ship);

    ship->location = 0;

    if (ship->shipstate != SHIP_DISABLED)
       ship->shipstate = SHIP_READY;

    plusminus = number_range ( -1 , 2 );
    if (plusminus > 0 )
        ship->hx = 1;
    else
        ship->hx = -1;

    plusminus = number_range ( -1 , 2 );
    if (plusminus > 0 )
        ship->hy = 1;
    else
        ship->hy = -1;

    plusminus = number_range ( -1 , 2 );
    if (plusminus > 0 )
        ship->hz = 1;
    else
        ship->hz = -1;

/*
	for ( target = ship->starsystem->first_ship; target; target = target->next_in_starsystem )
	{
		if (ship_from_entrance( ship->docked2 ) == ship_from_entrance( target->entrance ))
		{
			ship->vx = target->vx;
			ship->vy = target->vy;
			ship->vz = target->vz;
			temp = ship->name;
		}
	}
*/
	target = ship_from_entrance( ship->docked2 );
	if (  target == NULL || target == ship)
	{
		bug("%s: Undockship : That ship isn't here!\n\r",ship->name);
		return;
	}

    ship->energy -= (100+100*ship->class);

    ship->vx += (ship->hx*ship->currspeed*2+15);
    ship->vy += (ship->hy*ship->currspeed*2+15);
    ship->vz += (ship->hz*ship->currspeed*2+15);

    echo_to_room( AT_GREEN , get_room_index(ship->location) , "Undocking complete");
    echo_to_system( AT_YELLOW , ship , "The ship leaves the other ship far behind as it flies away into space.", target );
/*   sprintf( buf ,"%s enters the starsystem at %.0f %.0f %.0f" , ship->name, ship->vx, ship->vy, ship->vz ); */
/*	sprintf( buf ,"%s has just undocked from %s has just taken off" , ship->name, target->name);*/

	sprintf( buf, "%s flys out into space.", ship->name );
    echo_to_system( AT_YELLOW, ship, buf , NULL );
    echo_to_room( AT_YELLOW , get_room_index(ship->docked2) , buf );
}


void do_closebay( CHAR_DATA *ch, char *argument )
{}

/*
 * Get an extra description from a list.
 */
char *get_hyperspeed( int hyper )
{
    if ( hyper > 0 && hyper <= 50)
		return "x5";
	if ( hyper > 50 && hyper <= 100 )
		return "x4";
	if ( hyper > 100 && hyper <= 150 )
		return "x3";
	if ( hyper > 150 && hyper <= 200 )
		return "x2";
	if ( hyper > 200 )
		return "x1";
    return "ERROR";
}

void do_bomb( CHAR_DATA *ch, char *argument )
{
	char buf  [MAX_STRING_LENGTH];
	char arg1 [MAX_INPUT_LENGTH];
	char arg [MAX_INPUT_LENGTH];
	PLANET_DATA *planet;
	CLAN_DATA *clan;
	SHIP_DATA *ship;
	DESCRIPTOR_DATA *d;
	int chance,number,number2;
	
	if ( IS_NPC(ch) || !ch->pcdata || !ch->in_room)
	{
		send_to_char( "What would be the point of that.\n\r", ch );
		return;
	}
	
	strcpy( arg, argument );
	
	if (!IS_NPC(ch) && ch->pcdata && ch->pcdata->clan )
		clan = ch->pcdata->clan;
	argument = one_argument( argument, arg1 );
	
	ship = ship_from_cockpit(ch->in_room->vnum);
	
	if ( !ship )
	{
		set_char_color( AT_RED, ch);
		send_to_char("You have to be in the cockpit of a ship to bomb a planet",ch);
		return;
	}
	if ( IS_SET(ship->flags, SHIP_MASKED) )
	{
		echo_to_cockpit( AT_RED, ship, "&R[&WShip Weapons&R]&W You are unable todo so when masked.");
		return;
	}
	
	if ( arg1[0] == '\0' )
	{
		send_to_char( "Bomb Which Planet??\n\r", ch );
		return;
	}
	
	if ( ( planet = get_planet( arg1 ) ) == NULL )
	{
		send_to_char( "No Such Planet.\n\r", ch );
		return;
	}
	
	if ( ch->position <= POS_SLEEPING )
	{
		send_to_char( "In your dreams or what?\n\r" , ch );
		return;
	}

	if ( ship->bombs <= 0 )
	{
		sprintf( buf , "&W[&R^zWARNING&W^x&G&W] You are out of bombs, trying to fire can damage your launcher!.");
		echo_to_cockpit( AT_RED , ship , buf );
		return;
	}
	
	if ( !planet->x || !planet->y || !planet->z )
	{
		send_to_char("Planet is bugged, Notify a imm, Preferably not Gavin or squall\n\r",ch);
		bug("Planet: %s doesn't work for bombing", planet->name);
		return;
	}
	
	if (  (planet->x > ship->vx + 200) || (planet->x < ship->vx - 200) ||
		(planet->y > ship->vy + 200) || (planet->y < ship->vy - 200) ||
		(planet->z > ship->vz + 200) || (planet->z < ship->vz - 200) )
	{
		send_to_char("&G&W[&R^zERROR&W^x] &RTarget is too far away!\n\r",ch);
		return;
	}
	
	act( AT_PLAIN, "$n presses the fire button marked \"Space Bombs\".", ch, NULL, argument , TO_ROOM );
	act( AT_PLAIN, "You press the fire button marked \"Space Bombs\".", ch, NULL, argument , TO_CHAR );
	
	ship->bombs--;
	
	WAIT_STATE( ch, skill_table[gsn_bomb]->beats );
	
	chance = IS_NPC(ch) ? ch->top_level : (int) (ch->pcdata->learned[gsn_bomb]);
	
	if ( number_percent() > chance )
	{
		sprintf( buf, "%s's space bomb veers off course and crashes into an uninhabited area of %s" , ship->name, planet->name);
		echo_to_system( AT_SAY , ship , buf , NULL );
		sprintf( buf , "Your space bomb flies wide of the target.");
		echo_to_cockpit( AT_YELLOW , ship , buf );
		return;
	}
	
	sprintf( buf, "&G&W[&R^zNOTICE&W^x] Sensors indicate %s drops a space bomb into the atmosphere of %s."
		, ship->name , planet->name);
	echo_to_system( AT_LBLUE , ship , buf , ship );
	
	sprintf( buf , "&G&W[&R^zNOTICE&W^x] A space bomb drops slowly towards the surface of %s" , planet->name);
	echo_to_cockpit( AT_YELLOW , ship , buf );
	
	planet->pop_support -= ch->top_level/50;
	
	number = number_range(0,4);
	number2 = number_range(0,2);
	
	if ( !IS_SET(planet->flags, PLANET_PSHIELD) )
	{
		if ( number_percent() <= 20 && planet->controls > 0)
		{
			ch_printf(ch,"You notice that the shield flickers as you hit a shield generator.\n\r");
			planet->controls--;
			if ( planet->controls <= 0 )
			{
				REMOVE_BIT(planet->flags, PLANET_PSHIELD);
				sprintf( buf, "&G&W[&R^zNOTICE&W^x] Sensors Indicate that %s's shields are now down" , planet->name);
				echo_to_system( AT_SAY , ship , buf , NULL );
				sprintf( buf, "&G&W[&R^zNOTICE&W^x] Sensors Indicate that %s's shields are now down" , planet->name);
				echo_to_cockpit( AT_YELLOW , ship , buf );
			}
		}
		if ( number_percent() <= 20 && planet->barracks > 0)
		{
			ch_printf(ch,"You notice that one of your bombs hits a giant military type building.\n\r");
			planet->barracks--;
		}
		
		for( d = first_descriptor; d; d = d->next )
		{
			CHAR_DATA *vch;
			vch = d->character;
			if( d->connected == CON_PLAYING )
			{
				if( !vch->in_room->area )
					continue;
				if( !vch->in_room->area->planet )
					continue;
				if( vch->in_room->area->planet == planet )
				{
					if ( IS_OUTSIDE(vch) )
					{
						switch ( number )
						{
							case 0:
							case 1:
							case 2:
								ch_printf( vch, "An explosion from a bomb shakes the ground violently!\n\r");
								ch_printf( vch, "And you loose your ballence and hit the ground hard!\n\r");
								ch_printf( vch, "&ROuch!\n\r\n\r" );
								vch->hit -= 100;
								break;
							case 3:
							case 4:
								ch_printf( vch, "You hear screams nearby from a space bomb impact!\n\r");
								ch_printf( vch, "Luckly you are out of the blast radious\n\r");
								break;
							default:
								ch_printf( vch, "You hear screams nearby from a space bomb impact!\n\r");
								ch_printf( vch, "Luckly you are out of the blast radious\n\r");
								break;
						}
					}
					else if ( !IS_OUTSIDE(vch) )
					{
						switch ( number2 )
						{
							case 0:
								ch_printf( vch, "An explosion from a bomb shakes the walls and the ground!\n\r");
								ch_printf( vch, "And you loose your ballence and hit the ground hard!\n\r");
								ch_printf( vch, "&ROuch!\n\r\n\r" );
								vch->hit -= 100;
								break;
							case 1:
								ch_printf( vch, "An explosion from a bomb causes small bits of ceiling tile to fall on your head.\n\r");
								ch_printf( vch, "&ROuch!\n\r\n\r" );
								vch->hit -= 100;
								break;
							case 2:
								ch_printf( vch, "You hear a bomb expload nearby, but this building seems unaffected!\n\r");
								break;
							default:
								ch_printf( vch, "You hear a bomb expload nearby, but this building seems unaffected!\n\r");
								break;
						}
					}
					else if ( IS_OUTSIDE(vch) || !IS_OUTSIDE(vch) )
					{
						ch_printf( vch, "An explosion from a distant bomb causes a small tremor in the ground.\n\r");
					}
					continue;
				}
			}
		}
	}/* End If pshield on */
	else if ( IS_SET(planet->flags, PLANET_PSHIELD) )
	{
		if ( number_percent() <= 50 && planet->controls > 0)
		{
			ch_printf(ch,"You notice that the shield flickers as you hit a shield generator.\n\r");
			planet->controls--;
			if ( planet->controls <= 0 )
			{
				REMOVE_BIT(planet->flags, PLANET_PSHIELD);
				sprintf( buf, "&G&W[&R^zNOTICE&W^x] Sensors Indicate that %s's shields are now down" , planet->name);
				echo_to_system( AT_SAY , ship , buf , NULL );
				sprintf( buf, "&G&W[&R^zNOTICE&W^x] Sensors Indicate that %s's shields are now down" , planet->name);
				echo_to_cockpit( AT_YELLOW , ship , buf );
			}
		}
		if ( number_percent() <= 20 && planet->barracks > 0)
		{
			ch_printf(ch,"You notice that one of your bombs hits a giant military type building.\n\r");
			planet->barracks--;
		}
		
		for( d = first_descriptor; d; d = d->next )
		{
			CHAR_DATA *vch;
			vch = d->character;
			if( d->connected == CON_PLAYING )
			{
				if( !vch->in_room->area )
					continue;
				if( !vch->in_room->area->planet )
					continue;
				if( vch->in_room->area->planet == planet )
				{
					if ( IS_OUTSIDE(vch) )
						ch_printf( vch, "Up above, you notice a bright light!\n\r");
					else if ( !IS_OUTSIDE(vch) )
						ch_printf( vch, "You hear an explosion high above you.!\n\r");
					else if ( IS_OUTSIDE(vch) || !IS_OUTSIDE(vch) )
						ch_printf( vch, "You hear an explosion high above you.!\n\r");
					continue;
				}
			}
		}
	}
	
	gain_exp(ch, (10 /*Shield Mod */)*100, PILOTING_ABILITY);
	ch_printf( ch , "You gain %d piloting experience.\n\r", (10 /*shield mod */)*100 );
	learn_from_success( ch, gsn_bomb );
	
	if ( planet->pop_support > 100 )
		planet->pop_support = 100;
	if ( planet->pop_support < -100 )
		planet->pop_support = -100;
	return;
}

bool hyper_allowed_FCZ (float x, float y, float z, SHIP_DATA *ship, SPACE_DATA *starsystem)
{
	if ( system_ship_status(ship,starsystem) == 0 )
		return TRUE;
	else
	{
		if ( starsystem->star1 && strcmp(starsystem->star1,"") &&
			abs(x - starsystem->s1x) < starsystem->fcz &&
			abs(y - starsystem->s1y) < starsystem->fcz &&
			abs(z - starsystem->s1z) < starsystem->fcz )
		{
			return FALSE;
		}
		else if ( starsystem->star2 && strcmp(starsystem->star2,"") &&
			abs(x - starsystem->s2x) < starsystem->fcz &&
			abs(y - starsystem->s2y) < starsystem->fcz &&
			abs(z - starsystem->s2z) < starsystem->fcz )
		{
			return FALSE;
		}
		else if ( starsystem->planet1 && strcmp(starsystem->planet1,"") &&
			abs(x - starsystem->p1x) < starsystem->fcz &&
			abs(y - starsystem->p1y) < starsystem->fcz &&
			abs(z - starsystem->p1z) < starsystem->fcz )
		{
			return FALSE;
		}
		else if ( starsystem->planet2 && strcmp(starsystem->planet2,"") &&
			abs(x - starsystem->p2x) < starsystem->fcz &&
			abs(y - starsystem->p2y) < starsystem->fcz &&
			abs(z - starsystem->p2z) < starsystem->fcz )
		{
			return FALSE;
		}
		else if ( starsystem->planet3 && strcmp(starsystem->planet3,"") &&
			abs(x - starsystem->p3x) < starsystem->fcz &&
			abs(y - starsystem->p3y) < starsystem->fcz &&
			abs(z - starsystem->p3z) < starsystem->fcz )
		{
			return FALSE;
		}
		return TRUE;
	}
}

int system_ship_status(SHIP_DATA *ship, SPACE_DATA *system)
{
	if ( IS_SET(ship->flags,SHIP_MOB) )
		return 0;

	if ( system->code ==0 )
		return 0;

	if ( system->code == ship->code )
		return 0;

	return system->alertstatus;

}

bool system_attack(SHIP_DATA *ship, SPACE_DATA *system)
{
	CLAN_DATA *clan;
	CLAN_DATA *system_clan;

	if ( !ship || ship == NULL || !system || system == NULL )
		return FALSE;

	if ( !system->governed_by || (system_clan = get_clan(system->governed_by->name)) == NULL)
		return FALSE;
	
	if ( (clan = get_clan(ship->owner)) != NULL )
	{
		if ( clan == system_clan)
			return FALSE;
		
		if ( system_ship_status(ship,system) == 2 )
			return TRUE;

		if ( system_ship_status(ship,system) == 1 )
		{
			if ( nifty_is_name( clan->name , system_clan->atwar ) )
					return TRUE;
		}
	}

	if ( IS_SET(ship->flags,SHIP_MOB) )
		return FALSE;

	return FALSE;

}

/*
 * do_ship_masking - A [ability] skill
 *
 * Info: this command is a like a cloaking field. temporarly masks this ships from other
 * peoples sensors. This system requires a huge amount of energy, so can only be used for 
 * short period of time. usually for escape.
 *
 * Coded by: Gavin of Unknown Regions ( ur_gavin@hotmail.com)
 *
 */

void do_ship_masking ( CHAR_DATA * ch, char * argument )
{
	SHIP_DATA * ship;
	int chance;

	if ( argument[0] == '\0' )
	{
		send_to_char( "&RUsage: &Wship_masking [on/off]\n\r",ch);
		return;
	}
	chance = IS_NPC(ch) ? ch->top_level: (int) (ch->pcdata->learned[gsn_ship_masking]);
	
	if ( (ship = ship_from_cockpit(ch->in_room->vnum)) == NULL )
	{
		send_to_char("&RYou must be in the cockpit of a ship to do that!\n\r",ch);
		return;
	}
	
	if ( str_cmp( "on", argument ) && str_cmp( "off", argument ) )
	{
		send_to_char( "&RUsage: &Wship_masking [on|off]\n\r",ch);
		return;
	}
	if ( number_percent( ) < chance )
	{
		if ( !str_cmp( "off", argument ) )
		{
			if ( IS_SET(ship->flags, SHIP_MASKED) )
			{
				send_to_char( "&R[&RShip Status&R] &WMasking Disabled\n\r",ch);
				learn_from_success( ch, gsn_ship_masking );
				REMOVE_BIT(ship->flags, SHIP_MASKED);
				ship->energy -= 250;
				return;
			}
			if ( !IS_SET(ship->flags, SHIP_MASKED) )
			{
				send_to_char( "&R[&RShip Status&R] &WMasking Already Disabled\n\r",ch);
				return;
			}
		}
		else if ( !str_cmp( "on", argument ) )
		{
			if ( ship->energy < 500 )
			{
				send_to_char( "&R[&WShip Status&R] &WYou do not have enough energy to mask your ship\n\r",ch);
				return;
			}
			if ( !IS_SET(ship->flags, SHIP_MASKED) )
			{
				send_to_char( "&R[&WShip Status&R] &WMasking Enabled\n\r",ch);
				ship->energy -= 250;
				SET_BIT(ship->flags, SHIP_MASKED);
				learn_from_success( ch, gsn_ship_masking );
				return;
			}
			if ( IS_SET(ship->flags, SHIP_MASKED) )
			{
				send_to_char( "&R[&WShip Status&R] &WMasking Already Enabled\n\r",ch);
				return;
			}
		}
	}
	else
	{
		learn_from_failure( ch, gsn_ship_masking );
		send_to_char( "You wasted alot of the ships energy trying to mask it from sensors, but fail.\n\r",ch);
		ship->energy = 140;
		return;
	}
}

void do_eject ( CHAR_DATA * ch, char * argument )
{
	SHIP_DATA * ship;

	if ( IS_NPC(ch) )
		return;

	ship = ship_from_cockpit(ch->in_room->vnum);
	if ( ship == NULL)
		ship = ship_from_entrance(ch->in_room->vnum);
	if ( ship == NULL)
		ship = ship_from_hanger(ch->in_room->vnum);
	if ( ship == NULL)
		ship = ship_from_cockpit(ch->in_room->vnum);
	if ( ship == NULL)
		ship = ship_from_coseat(ch->in_room->vnum);
	if ( ship == NULL)
		ship = ship_from_pilotseat(ch->in_room->vnum);
	if ( ship == NULL)
		ship = ship_from_turret(ch->in_room->vnum);
	if ( ship == NULL)
		ship = ship_from_engine(ch->in_room->vnum);
	if ( ship == NULL )
	{
		return;
	}
}
